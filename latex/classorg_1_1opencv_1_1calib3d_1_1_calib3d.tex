\hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d}{}\section{org.\+opencv.\+calib3d.\+Calib3d Class Reference}
\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d}\index{org.\+opencv.\+calib3d.\+Calib3d@{org.\+opencv.\+calib3d.\+Calib3d}}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static double \mbox{[}$\,$\mbox{]} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a25a9a7350da241cac233a16419ad3ebd}{R\+Q\+Decomp3x3}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mtxR, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mtxQ, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} Qx, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} Qy, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} Qz)
\item 
static double \mbox{[}$\,$\mbox{]} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a954aae0c68e0109ce75ebe6bb897eb19}{R\+Q\+Decomp3x3}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mtxR, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mtxQ)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a922c174e8c7e4564831abdb4ba8ba2dc}{Rodrigues}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} jacobian)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5b382445df7c31a34f6fabe2c7a404b3}{Rodrigues}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_abb2da586f9e7234fede7598a15426bfa}{calibrate\+Camera}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ object\+Points, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ image\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ rvecs, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ tvecs, int flags, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}} criteria)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a1cd08cb110fd228c1feac4c47e5f2129}{calibrate\+Camera}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ object\+Points, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ image\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ rvecs, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ tvecs, int flags)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaa55919083e3f9e4d55ad80fac0d156d}{calibrate\+Camera}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ object\+Points, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ image\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ rvecs, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ tvecs)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad9223e80b2aa0006c9ad4980cb8d36f7}{calibration\+Matrix\+Values}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, double aperture\+Width, double aperture\+Height, double\mbox{[}$\,$\mbox{]} fovx, double\mbox{[}$\,$\mbox{]} fovy, double\mbox{[}$\,$\mbox{]} focal\+Length, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} principal\+Point, double\mbox{[}$\,$\mbox{]} aspect\+Ratio)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad9164834d702ee2b284bd9f5286f211d}{compose\+RT}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec3, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec3, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dr3dr1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dr3dt1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dr3dr2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dr3dt2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dt3dr1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dt3dt1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dt3dr2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dt3dt2)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a0549bb2dcba12e0f5c504d6a6871f3a6}{compose\+RT}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec3, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec3)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5a2813b406a15a54fdb5b3ba8f9e74c6}{compute\+Correspond\+Epilines}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} points, int which\+Image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} F, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} lines)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aea48eb14657d4f20ebdf415b265c9a9b}{convert\+Points\+From\+Homogeneous}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a718a2c8745024b449e6d2435937cae4f}{convert\+Points\+To\+Homogeneous}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a1f9be07026d6dec97548b38d2e46199e}{correct\+Matches}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} F, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} points1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} points2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} new\+Points1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} new\+Points2)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a7ee2a1b10202fdb49551a6282323f4de}{decompose\+Projection\+Matrix}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} proj\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rot\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} trans\+Vect, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rot\+MatrixX, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rot\+MatrixY, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rot\+MatrixZ, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} euler\+Angles)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad9441ef699ef192fda9e5c506d6553e6}{decompose\+Projection\+Matrix}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} proj\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rot\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} trans\+Vect)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a8748d7dc71aff055017971b3f69cb4d1}{draw\+Chessboard\+Corners}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} pattern\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} corners, boolean pattern\+Was\+Found)
\item 
static int \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3b722ac9873a2ce03d1974df1da955c5}{estimate\+Affine3D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} out, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} inliers, double ransac\+Threshold, double confidence)
\item 
static int \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_af7bf72e6c32472fe5de24cbd8e749435}{estimate\+Affine3D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} out, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} inliers)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaf626e5e34382b1b5a594d4790501c20}{filter\+Speckles}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, double new\+Val, int max\+Speckle\+Size, double max\+Diff, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} buf)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aa3d550489967c6395ec1ca2f118ee06d}{filter\+Speckles}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, double new\+Val, int max\+Speckle\+Size, double max\+Diff)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5a4ea03ae303cf3c5a327ec5c85047a5}{find\+Chessboard\+Corners}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} pattern\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} corners, int flags)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aa309372b843626fe1d7195ea65bf01ce}{find\+Chessboard\+Corners}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} pattern\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} corners)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a1ca6a42bf6b43db65fc0f231db9d2117}{find\+Circles\+Grid\+Default}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} pattern\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} centers, int flags)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a07ab97ed42f8f202715b367a9e31d903}{find\+Circles\+Grid\+Default}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} pattern\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} centers)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3dedba28209d17c56b4470b9cce95596}{find\+Fundamental\+Mat}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} points1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} points2, int method, double param1, double param2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ab758a6250812f65ccec0421d386be1c8}{find\+Fundamental\+Mat}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} points1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} points2, int method, double param1, double param2)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ae4c04269538cdac95954f77f633c25a6}{find\+Fundamental\+Mat}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} points1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} points2)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a2c32d44d2f35dc41aa09d54eb6829ab8}{find\+Homography}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} src\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} dst\+Points, int method, double ransac\+Reproj\+Threshold, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad95dde1b1f976545692c0fc8b11d2c22}{find\+Homography}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} src\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} dst\+Points, int method, double ransac\+Reproj\+Threshold)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aa3e6fd7652b2fc4c4d19064b39523dae}{find\+Homography}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} src\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} dst\+Points)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaece56f4a02759da9d1e31d9269e6596}{get\+Optimal\+New\+Camera\+Matrix}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, double alpha, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} new\+Img\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} valid\+Pix\+R\+OI, boolean center\+Principal\+Point)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a6a86093a8d328292e60c8592ac5d7b22}{get\+Optimal\+New\+Camera\+Matrix}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, double alpha)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a48c12be1bc3f11177e060cbd807ab92e}{get\+Valid\+Disparity\+R\+OI}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} roi1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} roi2, int min\+Disparity, int number\+Of\+Disparities, int S\+A\+D\+Window\+Size)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a15df47d3a4b4a3ef48f13d1c09aae9cb}{init\+Camera\+Matrix2D}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}} $>$ object\+Points, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} $>$ image\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, double aspect\+Ratio)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a6f6b4970eeeaa930d31f4a6f8dc5ea5f}{init\+Camera\+Matrix2D}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}} $>$ object\+Points, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} $>$ image\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ac74d1c19f77ac11af4ec2e92df9cacf9}{mat\+Mul\+Deriv}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} B, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} d\+A\+BdA, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} d\+A\+BdB)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5461d27f043f4a420fea1fac01a745e4}{project\+Points}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}} object\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} image\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} jacobian, double aspect\+Ratio)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a7084118c49e74c2a442e461ccaa1c97c}{project\+Points}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}} object\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} image\+Points)
\item 
static float \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aebd8ac92e76f807fcf593fd780b79a65}{rectify3\+Collinear}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix3, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs3, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ imgpt1, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ imgpt3, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} R12, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} T12, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} R13, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} T13, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} R1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} R2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} R3, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} P1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} P2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} P3, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} Q, double alpha, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} new\+Img\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} roi1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} roi2, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ae31a018191ec424a007e73caf5b35e6b}{reproject\+Image\+To3D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} disparity, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \+\_\+3d\+Image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} Q, boolean handle\+Missing\+Values, int ddepth)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a50f6f6b67af40abd54cd9b8bebce4c34}{reproject\+Image\+To3D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} disparity, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \+\_\+3d\+Image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} Q, boolean handle\+Missing\+Values)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ab0607d0453e4adb44ff480027b3296b7}{reproject\+Image\+To3D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} disparity, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \+\_\+3d\+Image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} Q)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad53b5772231896ec5baf3bde5e9ba319}{solve\+PnP}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}} object\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} image\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec, boolean use\+Extrinsic\+Guess, int flags)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a763c6212499a27e160dfbc34439cfce5}{solve\+PnP}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}} object\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} image\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a32d3d3e19cf81dddf71cd8527fb806e5}{solve\+Pn\+P\+Ransac}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}} object\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} image\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec, boolean use\+Extrinsic\+Guess, int iterations\+Count, float reprojection\+Error, int min\+Inliers\+Count, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} inliers, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad131ba9179addf7f44158cbc41e98a63}{solve\+Pn\+P\+Ransac}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}} object\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} image\+Points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rvec, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tvec)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_af2197ce033076b13fef5ae2fc045aa62}{stereo\+Calibrate}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ object\+Points, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ image\+Points1, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ image\+Points2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} T, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} E, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} F, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}} criteria, int flags)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a20929337f50b54083cde223c9fc5f9f7}{stereo\+Calibrate}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ object\+Points, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ image\+Points1, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ image\+Points2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} T, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} E, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} F)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaa152754c3a955ee79761a5e69f0408f}{stereo\+Rectify}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} T, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} R1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} R2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} P1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} P2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} Q, int flags, double alpha, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} new\+Image\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} valid\+Pix\+R\+O\+I1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} valid\+Pix\+R\+O\+I2)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a757aa08075484d502a276b3eab449e7e}{stereo\+Rectify}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} T, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} R1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} R2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} P1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} P2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} Q)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a02b105cf69f68dd4d9a2c1e76b4f8a3f}{stereo\+Rectify\+Uncalibrated}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} points1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} points2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} F, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} img\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} H1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} H2, double threshold)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a0ddeeb9de8f3bd4e8dac6b7b4c531e8e}{stereo\+Rectify\+Uncalibrated}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} points1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} points2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} F, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} img\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} H1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} H2)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3da703062fa27931cd6e22d1a7493961}{triangulate\+Points}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} proj\+Matr1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} proj\+Matr2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} proj\+Points1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} proj\+Points2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} points4D)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5602a849111be88c91348e13795ba888}{validate\+Disparity}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} disparity, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} cost, int min\+Disparity, int number\+Of\+Disparities, int disp12\+Max\+Disp)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aadd44bca728908e8afff768d760e3a83}{validate\+Disparity}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} disparity, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} cost, int min\+Disparity, int number\+Of\+Disparities)
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static final int \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3f736627ca0cf3d33c043fc10a937081}{C\+V\+\_\+\+I\+T\+E\+R\+A\+T\+I\+VE}} = 0
\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_abb2da586f9e7234fede7598a15426bfa}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_abb2da586f9e7234fede7598a15426bfa}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!calibrate\+Camera@{calibrate\+Camera}}
\index{calibrate\+Camera@{calibrate\+Camera}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{calibrate\+Camera()}{calibrateCamera()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static double org.\+opencv.\+calib3d.\+Calib3d.\+calibrate\+Camera (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{object\+Points,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{image\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{rvecs,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{tvecs,  }\item[{int}]{flags,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}}}]{criteria }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.

The function estimates the intrinsic camera parameters and extrinsic parameters for each of the views. The algorithm is based on \mbox{[}Zhang2000\mbox{]} and \mbox{[}Bouguet\+M\+CT\mbox{]}. The coordinates of 3D object points and their corresponding 2D projections in each view must be specified. That may be achieved by using an object with a known geometry and easily detectable feature points. Such an object is called a calibration rig or calibration pattern, and Open\+CV has built-\/in support for a chessboard as a calibration rig (see \char`\"{}find\+Chessboard\+Corners\char`\"{}). Currently, initialization of intrinsic parameters (when {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} is not set) is only implemented for planar calibration patterns (where Z-\/coordinates of the object points must be all zeros). 3D calibration rigs can also be used as long as initial {\ttfamily camera\+Matrix} is provided.

The algorithm performs the following steps\+:


\begin{DoxyItemize}
\item Compute the initial intrinsic parameters (the option only available for planar calibration patterns) or read them from the input parameters. The distortion coefficients are all set to zeros initially unless some of {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+K?} are specified. 
\item Estimate the initial camera pose as if the intrinsic parameters have been already known. This is done using \char`\"{}solve\+Pn\+P\char`\"{}. 
\item Run the global Levenberg-\/\+Marquardt optimization algorithm to minimize the reprojection error, that is, the total sum of squared distances between the observed feature points {\ttfamily image\+Points} and the projected (using the current estimates for camera parameters and the poses) object points {\ttfamily object\+Points}. See \char`\"{}project\+Points\char`\"{} for details. 
\end{DoxyItemize}

The function returns the final re-\/projection error.

Note\+:

If you use a non-\/square (=non-\/\+NxN) grid and \char`\"{}find\+Chessboard\+Corners\char`\"{} for calibration, and {\ttfamily calibrate\+Camera} returns bad values (zero distortion coefficients, an image center very far from {\ttfamily (w/2-\/0.\+5,h/2-\/0.\+5)}, and/or large differences between {\itshape f\+\_\+x} and {\itshape f\+\_\+y} (ratios of 10\+:1 or more)), then you have probably used {\ttfamily pattern\+Size=cv\+Size(rows,cols)} instead of using {\ttfamily pattern\+Size=cv\+Size(cols,rows)} in \char`\"{}find\+Chessboard\+Corners\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em object\+Points} & In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space. The outer vector contains as many elements as the number of the pattern views. If the same calibration pattern is shown in each view and it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns, or even different patterns in different views. Then, the vectors will be different. The points are 3D, but since they are in a pattern coordinate system, then, if the rig is planar, it may make sense to put the model to a XY coordinate plane so that Z-\/coordinate of each input object point is 0.\\
\hline
\end{DoxyParams}


In the old interface all the vectors of object points from different views are concatenated together.


\begin{DoxyParams}{Parameters}
{\em image\+Points} & In the new interface it is a vector of vectors of the projections of calibration pattern points. {\ttfamily image\+Points.\+size()} and {\ttfamily object\+Points.\+size()} and {\ttfamily image\+Points\mbox{[}i\mbox{]}.size()} must be equal to {\ttfamily object\+Points\mbox{[}i\mbox{]}.size()} for each {\ttfamily i}.\\
\hline
\end{DoxyParams}


In the old interface all the vectors of object points from different views are concatenated together.


\begin{DoxyParams}{Parameters}
{\em image\+Size} & Size of the image used only to initialize the intrinsic camera matrix. \\
\hline
{\em camera\+Matrix} & Output 3x3 floating-\/point camera matrix {\itshape A = }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x 0 c\+\_\+x$\vert$ $\vert$0 f\+\_\+y c\+\_\+y$\vert$ $\vert$0 0 1$\vert$ . If {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} and/or {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+A\+S\+P\+E\+C\+T\+\_\+\+R\+A\+T\+IO} are specified, some or all of {\ttfamily fx, fy, cx, cy} must be initialized before calling the function.

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Output vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. \\
\hline
{\em rvecs} & Output vector of rotation vectors (see \char`\"{}\+Rodrigues\char`\"{}) estimated for each pattern view. That is, each k-\/th rotation vector together with the corresponding k-\/th translation vector (see the next output parameter description) brings the calibration pattern from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the calibration pattern in the k-\/th pattern view (k=0.. {\itshape M} -\/1). \\
\hline
{\em tvecs} & Output vector of translation vectors estimated for each pattern view. \\
\hline
{\em flags} & Different flags that may be zero or a combination of the following values\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS {\ttfamily camera\+Matrix} contains valid initial values of {\ttfamily fx, fy, cx, cy} that are optimized further. Otherwise, {\ttfamily (cx, cy)} is initially set to the image center ({\ttfamily image\+Size} is used), and focal distances are computed in a least-\/squares fashion. Note, that if intrinsic parameters are known, there is no need to use this function just to estimate extrinsic parameters. Use \char`\"{}solve\+Pn\+P\char`\"{} instead. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+P\+R\+I\+N\+C\+I\+P\+A\+L\+\_\+\+P\+O\+I\+NT The principal point is not changed during the global optimization. It stays at the center or at a different location specified when {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} is set too. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+A\+S\+P\+E\+C\+T\+\_\+\+R\+A\+T\+IO The functions considers only {\ttfamily fy} as a free parameter. The ratio {\ttfamily fx/fy} stays the same as in the input {\ttfamily camera\+Matrix}. When {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} is not set, the actual input values of {\ttfamily fx} and {\ttfamily fy} are ignored, only their ratio is computed and used further. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+Z\+E\+R\+O\+\_\+\+T\+A\+N\+G\+E\+N\+T\+\_\+\+D\+I\+ST Tangential distortion coefficients {\itshape (p\+\_\+1, p\+\_\+2)} are set to zeros and stay zero. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+K1,...,C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+K6 The corresponding radial distortion coefficient is not changed during the optimization. If {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} is set, the coefficient from the supplied {\ttfamily dist\+Coeffs} matrix is used. Otherwise, it is set to 0. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+R\+A\+T\+I\+O\+N\+A\+L\+\_\+\+M\+O\+D\+EL Coefficients k4, k5, and k6 are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the rational model and return 8 coefficients. If the flag is not set, the function computes and returns only 5 distortion coefficients. 
\end{DoxyItemize}\\
\hline
{\em criteria} & Termination criteria for the iterative optimization algorithm.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#calibratecamera}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+calibrate\+Camera} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a15df47d3a4b4a3ef48f13d1c09aae9cb}{org.\+opencv.\+calib3d.\+Calib3d\+::init\+Camera\+Matrix2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_af2197ce033076b13fef5ae2fc045aa62}{org.\+opencv.\+calib3d.\+Calib3d\+::stereo\+Calibrate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5a4ea03ae303cf3c5a327ec5c85047a5}{org.\+opencv.\+calib3d.\+Calib3d\+::find\+Chessboard\+Corners}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad53b5772231896ec5baf3bde5e9ba319}{org.\+opencv.\+calib3d.\+Calib3d\+::solve\+PnP}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0733bf11be8125dfc28b6ff4da746927}{org.\+opencv.\+imgproc.\+Imgproc\+::undistort}} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a1cd08cb110fd228c1feac4c47e5f2129}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a1cd08cb110fd228c1feac4c47e5f2129}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!calibrate\+Camera@{calibrate\+Camera}}
\index{calibrate\+Camera@{calibrate\+Camera}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{calibrate\+Camera()}{calibrateCamera()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static double org.\+opencv.\+calib3d.\+Calib3d.\+calibrate\+Camera (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{object\+Points,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{image\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{rvecs,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{tvecs,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.

The function estimates the intrinsic camera parameters and extrinsic parameters for each of the views. The algorithm is based on \mbox{[}Zhang2000\mbox{]} and \mbox{[}Bouguet\+M\+CT\mbox{]}. The coordinates of 3D object points and their corresponding 2D projections in each view must be specified. That may be achieved by using an object with a known geometry and easily detectable feature points. Such an object is called a calibration rig or calibration pattern, and Open\+CV has built-\/in support for a chessboard as a calibration rig (see \char`\"{}find\+Chessboard\+Corners\char`\"{}). Currently, initialization of intrinsic parameters (when {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} is not set) is only implemented for planar calibration patterns (where Z-\/coordinates of the object points must be all zeros). 3D calibration rigs can also be used as long as initial {\ttfamily camera\+Matrix} is provided.

The algorithm performs the following steps\+:


\begin{DoxyItemize}
\item Compute the initial intrinsic parameters (the option only available for planar calibration patterns) or read them from the input parameters. The distortion coefficients are all set to zeros initially unless some of {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+K?} are specified. 
\item Estimate the initial camera pose as if the intrinsic parameters have been already known. This is done using \char`\"{}solve\+Pn\+P\char`\"{}. 
\item Run the global Levenberg-\/\+Marquardt optimization algorithm to minimize the reprojection error, that is, the total sum of squared distances between the observed feature points {\ttfamily image\+Points} and the projected (using the current estimates for camera parameters and the poses) object points {\ttfamily object\+Points}. See \char`\"{}project\+Points\char`\"{} for details. 
\end{DoxyItemize}

The function returns the final re-\/projection error.

Note\+:

If you use a non-\/square (=non-\/\+NxN) grid and \char`\"{}find\+Chessboard\+Corners\char`\"{} for calibration, and {\ttfamily calibrate\+Camera} returns bad values (zero distortion coefficients, an image center very far from {\ttfamily (w/2-\/0.\+5,h/2-\/0.\+5)}, and/or large differences between {\itshape f\+\_\+x} and {\itshape f\+\_\+y} (ratios of 10\+:1 or more)), then you have probably used {\ttfamily pattern\+Size=cv\+Size(rows,cols)} instead of using {\ttfamily pattern\+Size=cv\+Size(cols,rows)} in \char`\"{}find\+Chessboard\+Corners\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em object\+Points} & In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space. The outer vector contains as many elements as the number of the pattern views. If the same calibration pattern is shown in each view and it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns, or even different patterns in different views. Then, the vectors will be different. The points are 3D, but since they are in a pattern coordinate system, then, if the rig is planar, it may make sense to put the model to a XY coordinate plane so that Z-\/coordinate of each input object point is 0.\\
\hline
\end{DoxyParams}


In the old interface all the vectors of object points from different views are concatenated together.


\begin{DoxyParams}{Parameters}
{\em image\+Points} & In the new interface it is a vector of vectors of the projections of calibration pattern points. {\ttfamily image\+Points.\+size()} and {\ttfamily object\+Points.\+size()} and {\ttfamily image\+Points\mbox{[}i\mbox{]}.size()} must be equal to {\ttfamily object\+Points\mbox{[}i\mbox{]}.size()} for each {\ttfamily i}.\\
\hline
\end{DoxyParams}


In the old interface all the vectors of object points from different views are concatenated together.


\begin{DoxyParams}{Parameters}
{\em image\+Size} & Size of the image used only to initialize the intrinsic camera matrix. \\
\hline
{\em camera\+Matrix} & Output 3x3 floating-\/point camera matrix {\itshape A = }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x 0 c\+\_\+x$\vert$ $\vert$0 f\+\_\+y c\+\_\+y$\vert$ $\vert$0 0 1$\vert$ . If {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} and/or {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+A\+S\+P\+E\+C\+T\+\_\+\+R\+A\+T\+IO} are specified, some or all of {\ttfamily fx, fy, cx, cy} must be initialized before calling the function.

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Output vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. \\
\hline
{\em rvecs} & Output vector of rotation vectors (see \char`\"{}\+Rodrigues\char`\"{}) estimated for each pattern view. That is, each k-\/th rotation vector together with the corresponding k-\/th translation vector (see the next output parameter description) brings the calibration pattern from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the calibration pattern in the k-\/th pattern view (k=0.. {\itshape M} -\/1). \\
\hline
{\em tvecs} & Output vector of translation vectors estimated for each pattern view. \\
\hline
{\em flags} & Different flags that may be zero or a combination of the following values\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS {\ttfamily camera\+Matrix} contains valid initial values of {\ttfamily fx, fy, cx, cy} that are optimized further. Otherwise, {\ttfamily (cx, cy)} is initially set to the image center ({\ttfamily image\+Size} is used), and focal distances are computed in a least-\/squares fashion. Note, that if intrinsic parameters are known, there is no need to use this function just to estimate extrinsic parameters. Use \char`\"{}solve\+Pn\+P\char`\"{} instead. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+P\+R\+I\+N\+C\+I\+P\+A\+L\+\_\+\+P\+O\+I\+NT The principal point is not changed during the global optimization. It stays at the center or at a different location specified when {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} is set too. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+A\+S\+P\+E\+C\+T\+\_\+\+R\+A\+T\+IO The functions considers only {\ttfamily fy} as a free parameter. The ratio {\ttfamily fx/fy} stays the same as in the input {\ttfamily camera\+Matrix}. When {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} is not set, the actual input values of {\ttfamily fx} and {\ttfamily fy} are ignored, only their ratio is computed and used further. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+Z\+E\+R\+O\+\_\+\+T\+A\+N\+G\+E\+N\+T\+\_\+\+D\+I\+ST Tangential distortion coefficients {\itshape (p\+\_\+1, p\+\_\+2)} are set to zeros and stay zero. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+K1,...,C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+K6 The corresponding radial distortion coefficient is not changed during the optimization. If {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} is set, the coefficient from the supplied {\ttfamily dist\+Coeffs} matrix is used. Otherwise, it is set to 0. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+R\+A\+T\+I\+O\+N\+A\+L\+\_\+\+M\+O\+D\+EL Coefficients k4, k5, and k6 are enabled. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the rational model and return 8 coefficients. If the flag is not set, the function computes and returns only 5 distortion coefficients. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#calibratecamera}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+calibrate\+Camera} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a15df47d3a4b4a3ef48f13d1c09aae9cb}{org.\+opencv.\+calib3d.\+Calib3d\+::init\+Camera\+Matrix2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_af2197ce033076b13fef5ae2fc045aa62}{org.\+opencv.\+calib3d.\+Calib3d\+::stereo\+Calibrate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5a4ea03ae303cf3c5a327ec5c85047a5}{org.\+opencv.\+calib3d.\+Calib3d\+::find\+Chessboard\+Corners}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad53b5772231896ec5baf3bde5e9ba319}{org.\+opencv.\+calib3d.\+Calib3d\+::solve\+PnP}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0733bf11be8125dfc28b6ff4da746927}{org.\+opencv.\+imgproc.\+Imgproc\+::undistort}} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaa55919083e3f9e4d55ad80fac0d156d}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaa55919083e3f9e4d55ad80fac0d156d}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!calibrate\+Camera@{calibrate\+Camera}}
\index{calibrate\+Camera@{calibrate\+Camera}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{calibrate\+Camera()}{calibrateCamera()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static double org.\+opencv.\+calib3d.\+Calib3d.\+calibrate\+Camera (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{object\+Points,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{image\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{rvecs,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{tvecs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the camera intrinsic and extrinsic parameters from several views of a calibration pattern.

The function estimates the intrinsic camera parameters and extrinsic parameters for each of the views. The algorithm is based on \mbox{[}Zhang2000\mbox{]} and \mbox{[}Bouguet\+M\+CT\mbox{]}. The coordinates of 3D object points and their corresponding 2D projections in each view must be specified. That may be achieved by using an object with a known geometry and easily detectable feature points. Such an object is called a calibration rig or calibration pattern, and Open\+CV has built-\/in support for a chessboard as a calibration rig (see \char`\"{}find\+Chessboard\+Corners\char`\"{}). Currently, initialization of intrinsic parameters (when {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} is not set) is only implemented for planar calibration patterns (where Z-\/coordinates of the object points must be all zeros). 3D calibration rigs can also be used as long as initial {\ttfamily camera\+Matrix} is provided.

The algorithm performs the following steps\+:


\begin{DoxyItemize}
\item Compute the initial intrinsic parameters (the option only available for planar calibration patterns) or read them from the input parameters. The distortion coefficients are all set to zeros initially unless some of {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+K?} are specified. 
\item Estimate the initial camera pose as if the intrinsic parameters have been already known. This is done using \char`\"{}solve\+Pn\+P\char`\"{}. 
\item Run the global Levenberg-\/\+Marquardt optimization algorithm to minimize the reprojection error, that is, the total sum of squared distances between the observed feature points {\ttfamily image\+Points} and the projected (using the current estimates for camera parameters and the poses) object points {\ttfamily object\+Points}. See \char`\"{}project\+Points\char`\"{} for details. 
\end{DoxyItemize}

The function returns the final re-\/projection error.

Note\+:

If you use a non-\/square (=non-\/\+NxN) grid and \char`\"{}find\+Chessboard\+Corners\char`\"{} for calibration, and {\ttfamily calibrate\+Camera} returns bad values (zero distortion coefficients, an image center very far from {\ttfamily (w/2-\/0.\+5,h/2-\/0.\+5)}, and/or large differences between {\itshape f\+\_\+x} and {\itshape f\+\_\+y} (ratios of 10\+:1 or more)), then you have probably used {\ttfamily pattern\+Size=cv\+Size(rows,cols)} instead of using {\ttfamily pattern\+Size=cv\+Size(cols,rows)} in \char`\"{}find\+Chessboard\+Corners\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em object\+Points} & In the new interface it is a vector of vectors of calibration pattern points in the calibration pattern coordinate space. The outer vector contains as many elements as the number of the pattern views. If the same calibration pattern is shown in each view and it is fully visible, all the vectors will be the same. Although, it is possible to use partially occluded patterns, or even different patterns in different views. Then, the vectors will be different. The points are 3D, but since they are in a pattern coordinate system, then, if the rig is planar, it may make sense to put the model to a XY coordinate plane so that Z-\/coordinate of each input object point is 0.\\
\hline
\end{DoxyParams}


In the old interface all the vectors of object points from different views are concatenated together.


\begin{DoxyParams}{Parameters}
{\em image\+Points} & In the new interface it is a vector of vectors of the projections of calibration pattern points. {\ttfamily image\+Points.\+size()} and {\ttfamily object\+Points.\+size()} and {\ttfamily image\+Points\mbox{[}i\mbox{]}.size()} must be equal to {\ttfamily object\+Points\mbox{[}i\mbox{]}.size()} for each {\ttfamily i}.\\
\hline
\end{DoxyParams}


In the old interface all the vectors of object points from different views are concatenated together.


\begin{DoxyParams}{Parameters}
{\em image\+Size} & Size of the image used only to initialize the intrinsic camera matrix. \\
\hline
{\em camera\+Matrix} & Output 3x3 floating-\/point camera matrix {\itshape A = }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x 0 c\+\_\+x$\vert$ $\vert$0 f\+\_\+y c\+\_\+y$\vert$ $\vert$0 0 1$\vert$ . If {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} and/or {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+A\+S\+P\+E\+C\+T\+\_\+\+R\+A\+T\+IO} are specified, some or all of {\ttfamily fx, fy, cx, cy} must be initialized before calling the function.

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Output vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. \\
\hline
{\em rvecs} & Output vector of rotation vectors (see \char`\"{}\+Rodrigues\char`\"{}) estimated for each pattern view. That is, each k-\/th rotation vector together with the corresponding k-\/th translation vector (see the next output parameter description) brings the calibration pattern from the model coordinate space (in which object points are specified) to the world coordinate space, that is, a real position of the calibration pattern in the k-\/th pattern view (k=0.. {\itshape M} -\/1). \\
\hline
{\em tvecs} & Output vector of translation vectors estimated for each pattern view.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#calibratecamera}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+calibrate\+Camera} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a15df47d3a4b4a3ef48f13d1c09aae9cb}{org.\+opencv.\+calib3d.\+Calib3d\+::init\+Camera\+Matrix2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_af2197ce033076b13fef5ae2fc045aa62}{org.\+opencv.\+calib3d.\+Calib3d\+::stereo\+Calibrate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5a4ea03ae303cf3c5a327ec5c85047a5}{org.\+opencv.\+calib3d.\+Calib3d\+::find\+Chessboard\+Corners}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad53b5772231896ec5baf3bde5e9ba319}{org.\+opencv.\+calib3d.\+Calib3d\+::solve\+PnP}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0733bf11be8125dfc28b6ff4da746927}{org.\+opencv.\+imgproc.\+Imgproc\+::undistort}} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad9223e80b2aa0006c9ad4980cb8d36f7}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad9223e80b2aa0006c9ad4980cb8d36f7}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!calibration\+Matrix\+Values@{calibration\+Matrix\+Values}}
\index{calibration\+Matrix\+Values@{calibration\+Matrix\+Values}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{calibration\+Matrix\+Values()}{calibrationMatrixValues()}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+calibration\+Matrix\+Values (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{double}]{aperture\+Width,  }\item[{double}]{aperture\+Height,  }\item[{double \mbox{[}$\,$\mbox{]}}]{fovx,  }\item[{double \mbox{[}$\,$\mbox{]}}]{fovy,  }\item[{double \mbox{[}$\,$\mbox{]}}]{focal\+Length,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{principal\+Point,  }\item[{double \mbox{[}$\,$\mbox{]}}]{aspect\+Ratio }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes useful camera characteristics from the camera matrix.

The function computes various useful camera characteristics from the previously estimated camera matrix.


\begin{DoxyParams}{Parameters}
{\em camera\+Matrix} & Input camera matrix that can be estimated by \char`\"{}calibrate\+Camera\char`\"{} or \char`\"{}stereo\+Calibrate\char`\"{}. \\
\hline
{\em image\+Size} & Input image size in pixels. \\
\hline
{\em aperture\+Width} & Physical width of the sensor. \\
\hline
{\em aperture\+Height} & Physical height of the sensor. \\
\hline
{\em fovx} & Output field of view in degrees along the horizontal sensor axis. \\
\hline
{\em fovy} & Output field of view in degrees along the vertical sensor axis. \\
\hline
{\em focal\+Length} & Focal length of the lens in mm. \\
\hline
{\em principal\+Point} & Principal point in pixels. \\
\hline
{\em aspect\+Ratio} & {\itshape f\+\_\+y/f\+\_\+x}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#calibrationmatrixvalues}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+calibration\+Matrix\+Values} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad9164834d702ee2b284bd9f5286f211d}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad9164834d702ee2b284bd9f5286f211d}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!compose\+RT@{compose\+RT}}
\index{compose\+RT@{compose\+RT}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{compose\+R\+T()}{composeRT()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+compose\+RT (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec3,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec3,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dr3dr1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dr3dt1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dr3dr2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dr3dt2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dt3dr1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dt3dt1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dt3dr2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dt3dt2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Combines two rotation-\/and-\/shift transformations.

The functions compute\+:

{\itshape rvec3 = rodrigues $^\wedge$(-\/1)(rodrigues(rvec2) $\ast$ rodrigues(rvec1)) tvec3 = rodrigues(rvec2) $\ast$ tvec1 + tvec2,}

where {\itshape rodrigues} denotes a rotation vector to a rotation matrix transformation, and {\itshape rodrigues$^\wedge$(-\/1)} denotes the inverse transformation. See \char`\"{}\+Rodrigues\char`\"{} for details.

Also, the functions can compute the derivatives of the output vectors with regards to the input vectors (see \char`\"{}mat\+Mul\+Deriv\char`\"{}). The functions are used inside \char`\"{}stereo\+Calibrate\char`\"{} but can also be used in your own code where Levenberg-\/\+Marquardt or another gradient-\/based solver is used to optimize a function that contains a matrix multiplication.


\begin{DoxyParams}{Parameters}
{\em rvec1} & First rotation vector. \\
\hline
{\em tvec1} & First translation vector. \\
\hline
{\em rvec2} & Second rotation vector. \\
\hline
{\em tvec2} & Second translation vector. \\
\hline
{\em rvec3} & Output rotation vector of the superposition. \\
\hline
{\em tvec3} & Output translation vector of the superposition. \\
\hline
{\em dr3dr1} & Optional output derivatives of {\ttfamily rvec3} or {\ttfamily tvec3} with regard to {\ttfamily rvec1}, {\ttfamily rvec2}, {\ttfamily tvec1} and {\ttfamily tvec2}, respectively. \\
\hline
{\em dr3dt1} & Optional output derivatives of {\ttfamily rvec3} or {\ttfamily tvec3} with regard to {\ttfamily rvec1}, {\ttfamily rvec2}, {\ttfamily tvec1} and {\ttfamily tvec2}, respectively. \\
\hline
{\em dr3dr2} & Optional output derivatives of {\ttfamily rvec3} or {\ttfamily tvec3} with regard to {\ttfamily rvec1}, {\ttfamily rvec2}, {\ttfamily tvec1} and {\ttfamily tvec2}, respectively. \\
\hline
{\em dr3dt2} & Optional output derivatives of {\ttfamily rvec3} or {\ttfamily tvec3} with regard to {\ttfamily rvec1}, {\ttfamily rvec2}, {\ttfamily tvec1} and {\ttfamily tvec2}, respectively. \\
\hline
{\em dt3dr1} & Optional output derivatives of {\ttfamily rvec3} or {\ttfamily tvec3} with regard to {\ttfamily rvec1}, {\ttfamily rvec2}, {\ttfamily tvec1} and {\ttfamily tvec2}, respectively. \\
\hline
{\em dt3dt1} & Optional output derivatives of {\ttfamily rvec3} or {\ttfamily tvec3} with regard to {\ttfamily rvec1}, {\ttfamily rvec2}, {\ttfamily tvec1} and {\ttfamily tvec2}, respectively. \\
\hline
{\em dt3dr2} & Optional output derivatives of {\ttfamily rvec3} or {\ttfamily tvec3} with regard to {\ttfamily rvec1}, {\ttfamily rvec2}, {\ttfamily tvec1} and {\ttfamily tvec2}, respectively. \\
\hline
{\em dt3dt2} & Optional output derivatives of {\ttfamily rvec3} or {\ttfamily tvec3} with regard to {\ttfamily rvec1}, {\ttfamily rvec2}, {\ttfamily tvec1} and {\ttfamily tvec2}, respectively.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#composert}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+compose\+RT} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a0549bb2dcba12e0f5c504d6a6871f3a6}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a0549bb2dcba12e0f5c504d6a6871f3a6}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!compose\+RT@{compose\+RT}}
\index{compose\+RT@{compose\+RT}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{compose\+R\+T()}{composeRT()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+compose\+RT (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec3,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec3 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Combines two rotation-\/and-\/shift transformations.

The functions compute\+:

{\itshape rvec3 = rodrigues $^\wedge$(-\/1)(rodrigues(rvec2) $\ast$ rodrigues(rvec1)) tvec3 = rodrigues(rvec2) $\ast$ tvec1 + tvec2,}

where {\itshape rodrigues} denotes a rotation vector to a rotation matrix transformation, and {\itshape rodrigues$^\wedge$(-\/1)} denotes the inverse transformation. See \char`\"{}\+Rodrigues\char`\"{} for details.

Also, the functions can compute the derivatives of the output vectors with regards to the input vectors (see \char`\"{}mat\+Mul\+Deriv\char`\"{}). The functions are used inside \char`\"{}stereo\+Calibrate\char`\"{} but can also be used in your own code where Levenberg-\/\+Marquardt or another gradient-\/based solver is used to optimize a function that contains a matrix multiplication.


\begin{DoxyParams}{Parameters}
{\em rvec1} & First rotation vector. \\
\hline
{\em tvec1} & First translation vector. \\
\hline
{\em rvec2} & Second rotation vector. \\
\hline
{\em tvec2} & Second translation vector. \\
\hline
{\em rvec3} & Output rotation vector of the superposition. \\
\hline
{\em tvec3} & Output translation vector of the superposition.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#composert}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+compose\+RT} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5a2813b406a15a54fdb5b3ba8f9e74c6}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5a2813b406a15a54fdb5b3ba8f9e74c6}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!compute\+Correspond\+Epilines@{compute\+Correspond\+Epilines}}
\index{compute\+Correspond\+Epilines@{compute\+Correspond\+Epilines}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{compute\+Correspond\+Epilines()}{computeCorrespondEpilines()}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+compute\+Correspond\+Epilines (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{points,  }\item[{int}]{which\+Image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{F,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{lines }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

For points in an image of a stereo pair, computes the corresponding epilines in the other image.

For every point in one of the two images of a stereo pair, the function finds the equation of the corresponding epipolar line in the other image.

From the fundamental matrix definition (see \char`\"{}find\+Fundamental\+Mat\char`\"{}), line {\itshape l$^\wedge$2\+\_\+i} in the second image for the point {\itshape p$^\wedge$1\+\_\+i} in the first image (when {\ttfamily which\+Image=1}) is computed as\+:

{\itshape l$^\wedge$2\+\_\+i = F p$^\wedge$1\+\_\+i}

And vice versa, when {\ttfamily which\+Image=2}, {\itshape l$^\wedge$1\+\_\+i} is computed from {\itshape p$^\wedge$2\+\_\+i} as\+:

{\itshape l$^\wedge$1\+\_\+i = F$^\wedge$T p$^\wedge$2\+\_\+i}

Line coefficients are defined up to a scale. They are normalized so that {\itshape a\+\_\+i$^\wedge$2+b\+\_\+i$^\wedge$2=1}.


\begin{DoxyParams}{Parameters}
{\em points} & Input points. {\itshape N x 1} or {\itshape 1 x N} matrix of type {\ttfamily C\+V\+\_\+32\+F\+C2} or {\ttfamily vector$<$\+Point2f$>$}. \\
\hline
{\em which\+Image} & Index of the image (1 or 2) that contains the {\ttfamily points}. \\
\hline
{\em F} & Fundamental matrix that can be estimated using \char`\"{}find\+Fundamental\+Mat\char`\"{} or \char`\"{}stereo\+Rectify\char`\"{}. \\
\hline
{\em lines} & Output vector of the epipolar lines corresponding to the points in the other image. Each line {\itshape ax + by + c=0} is encoded by 3 numbers {\itshape (a, b, c)}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#computecorrespondepilines}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+compute\+Correspond\+Epilines} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aea48eb14657d4f20ebdf415b265c9a9b}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aea48eb14657d4f20ebdf415b265c9a9b}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!convert\+Points\+From\+Homogeneous@{convert\+Points\+From\+Homogeneous}}
\index{convert\+Points\+From\+Homogeneous@{convert\+Points\+From\+Homogeneous}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{convert\+Points\+From\+Homogeneous()}{convertPointsFromHomogeneous()}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+convert\+Points\+From\+Homogeneous (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Converts points from homogeneous to Euclidean space.

The function converts points homogeneous to Euclidean space using perspective projection. That is, each point {\ttfamily (x1, x2,... x(n-\/1), xn)} is converted to {\ttfamily (x1/xn, x2/xn,..., x(n-\/1)/xn)}. When {\ttfamily xn=0}, the output point coordinates will be {\ttfamily (0,0,0,...)}.


\begin{DoxyParams}{Parameters}
{\em src} & Input vector of {\ttfamily N}-\/dimensional points. \\
\hline
{\em dst} & Output vector of {\ttfamily N-\/1}-\/dimensional points.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#convertpointsfromhomogeneous}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+convert\+Points\+From\+Homogeneous} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a718a2c8745024b449e6d2435937cae4f}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a718a2c8745024b449e6d2435937cae4f}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!convert\+Points\+To\+Homogeneous@{convert\+Points\+To\+Homogeneous}}
\index{convert\+Points\+To\+Homogeneous@{convert\+Points\+To\+Homogeneous}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{convert\+Points\+To\+Homogeneous()}{convertPointsToHomogeneous()}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+convert\+Points\+To\+Homogeneous (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Converts points from Euclidean to homogeneous space.

The function converts points from Euclidean to homogeneous space by appending 1\textquotesingle{}s to the tuple of point coordinates. That is, each point {\ttfamily (x1, x2,..., xn)} is converted to {\ttfamily (x1, x2,..., xn, 1)}.


\begin{DoxyParams}{Parameters}
{\em src} & Input vector of {\ttfamily N}-\/dimensional points. \\
\hline
{\em dst} & Output vector of {\ttfamily N+1}-\/dimensional points.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#convertpointstohomogeneous}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+convert\+Points\+To\+Homogeneous} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a1f9be07026d6dec97548b38d2e46199e}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a1f9be07026d6dec97548b38d2e46199e}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!correct\+Matches@{correct\+Matches}}
\index{correct\+Matches@{correct\+Matches}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{correct\+Matches()}{correctMatches()}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+correct\+Matches (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{F,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{points1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{points2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{new\+Points1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{new\+Points2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Refines coordinates of corresponding points.

The function implements the Optimal Triangulation Method (see Multiple View Geometry for details). For each given point correspondence points1\mbox{[}i\mbox{]} $<$-\/$>$ points2\mbox{[}i\mbox{]}, and a fundamental matrix F, it computes the corrected correspondences new\+Points1\mbox{[}i\mbox{]} $<$-\/$>$ new\+Points2\mbox{[}i\mbox{]} that minimize the geometric error {\itshape d(points1\mbox{[}i\mbox{]}, new\+Points1\mbox{[}i\mbox{]})$^\wedge$2 + d(points2\mbox{[}i\mbox{]},new\+Points2\mbox{[}i\mbox{]})$^\wedge$2} (where {\itshape d(a,b)} is the geometric distance between points {\itshape a} and {\itshape b}) subject to the epipolar constraint {\itshape new\+Points2$^\wedge$T $\ast$ F $\ast$ new\+Points1 = 0}.


\begin{DoxyParams}{Parameters}
{\em F} & 3x3 fundamental matrix. \\
\hline
{\em points1} & 1xN array containing the first set of points. \\
\hline
{\em points2} & 1xN array containing the second set of points. \\
\hline
{\em new\+Points1} & The optimized points1. \\
\hline
{\em new\+Points2} & The optimized points2.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#correctmatches}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+correct\+Matches} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a7ee2a1b10202fdb49551a6282323f4de}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a7ee2a1b10202fdb49551a6282323f4de}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!decompose\+Projection\+Matrix@{decompose\+Projection\+Matrix}}
\index{decompose\+Projection\+Matrix@{decompose\+Projection\+Matrix}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{decompose\+Projection\+Matrix()}{decomposeProjectionMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+decompose\+Projection\+Matrix (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{proj\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rot\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{trans\+Vect,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rot\+MatrixX,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rot\+MatrixY,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rot\+MatrixZ,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{euler\+Angles }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Decomposes a projection matrix into a rotation matrix and a camera matrix.

The function computes a decomposition of a projection matrix into a calibration and a rotation matrix and the position of a camera.

It optionally returns three rotation matrices, one for each axis, and three Euler angles that could be used in Open\+GL. Note, there is always more than one sequence of rotations about the three principle axes that results in the same orientation of an object, eg. see \mbox{[}Slabaugh\mbox{]}. Returned tree rotation matrices and corresponding three Euler angules are only one of the possible solutions.

The function is based on \char`\"{}\+R\+Q\+Decomp3x3\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em proj\+Matrix} & 3x4 input projection matrix P. \\
\hline
{\em camera\+Matrix} & Output 3x3 camera matrix K. \\
\hline
{\em rot\+Matrix} & Output 3x3 external rotation matrix \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}. \\
\hline
{\em trans\+Vect} & Output 4x1 translation vector T. \\
\hline
{\em rot\+MatrixX} & a rot\+MatrixX \\
\hline
{\em rot\+MatrixY} & a rot\+MatrixY \\
\hline
{\em rot\+MatrixZ} & a rot\+MatrixZ \\
\hline
{\em euler\+Angles} & Optional three-\/element vector containing three Euler angles of rotation in degrees.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#decomposeprojectionmatrix}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+decompose\+Projection\+Matrix} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad9441ef699ef192fda9e5c506d6553e6}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad9441ef699ef192fda9e5c506d6553e6}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!decompose\+Projection\+Matrix@{decompose\+Projection\+Matrix}}
\index{decompose\+Projection\+Matrix@{decompose\+Projection\+Matrix}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{decompose\+Projection\+Matrix()}{decomposeProjectionMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+decompose\+Projection\+Matrix (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{proj\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rot\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{trans\+Vect }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Decomposes a projection matrix into a rotation matrix and a camera matrix.

The function computes a decomposition of a projection matrix into a calibration and a rotation matrix and the position of a camera.

It optionally returns three rotation matrices, one for each axis, and three Euler angles that could be used in Open\+GL. Note, there is always more than one sequence of rotations about the three principle axes that results in the same orientation of an object, eg. see \mbox{[}Slabaugh\mbox{]}. Returned tree rotation matrices and corresponding three Euler angules are only one of the possible solutions.

The function is based on \char`\"{}\+R\+Q\+Decomp3x3\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em proj\+Matrix} & 3x4 input projection matrix P. \\
\hline
{\em camera\+Matrix} & Output 3x3 camera matrix K. \\
\hline
{\em rot\+Matrix} & Output 3x3 external rotation matrix \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}. \\
\hline
{\em trans\+Vect} & Output 4x1 translation vector T.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#decomposeprojectionmatrix}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+decompose\+Projection\+Matrix} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a8748d7dc71aff055017971b3f69cb4d1}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a8748d7dc71aff055017971b3f69cb4d1}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!draw\+Chessboard\+Corners@{draw\+Chessboard\+Corners}}
\index{draw\+Chessboard\+Corners@{draw\+Chessboard\+Corners}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{draw\+Chessboard\+Corners()}{drawChessboardCorners()}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+draw\+Chessboard\+Corners (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{pattern\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{corners,  }\item[{boolean}]{pattern\+Was\+Found }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Renders the detected chessboard corners.

The function draws individual chessboard corners detected either as red circles if the board was not found, or as colored corners connected with lines if the board was found.


\begin{DoxyParams}{Parameters}
{\em image} & Destination image. It must be an 8-\/bit color image. \\
\hline
{\em pattern\+Size} & Number of inner corners per a chessboard row and column {\ttfamily (pattern\+Size = cv.\+Size(points\+\_\+per\+\_\+row,points\+\_\+per\+\_\+column))}. \\
\hline
{\em corners} & Array of detected corners, the output of {\ttfamily find\+Chessboard\+Corners}. \\
\hline
{\em pattern\+Was\+Found} & Parameter indicating whether the complete board was found or not. The return value of \char`\"{}find\+Chessboard\+Corners\char`\"{} should be passed here.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#drawchessboardcorners}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+draw\+Chessboard\+Corners} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3b722ac9873a2ce03d1974df1da955c5}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3b722ac9873a2ce03d1974df1da955c5}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!estimate\+Affine3D@{estimate\+Affine3D}}
\index{estimate\+Affine3D@{estimate\+Affine3D}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{estimate\+Affine3\+D()}{estimateAffine3D()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static int org.\+opencv.\+calib3d.\+Calib3d.\+estimate\+Affine3D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{out,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{inliers,  }\item[{double}]{ransac\+Threshold,  }\item[{double}]{confidence }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes an optimal affine transformation between two 3D point sets.

The function estimates an optimal 3D affine transformation between two 3D point sets using the R\+A\+N\+S\+AC algorithm.


\begin{DoxyParams}{Parameters}
{\em src} & First input 3D point set. \\
\hline
{\em dst} & Second input 3D point set. \\
\hline
{\em out} & Output 3D affine transformation matrix {\itshape 3 x 4}. \\
\hline
{\em inliers} & Output vector indicating which points are inliers. \\
\hline
{\em ransac\+Threshold} & Maximum reprojection error in the R\+A\+N\+S\+AC algorithm to consider a point as an inlier. \\
\hline
{\em confidence} & Confidence level, between 0 and 1, for the estimated transformation. Anything between 0.\+95 and 0.\+99 is usually good enough. Values too close to 1 can slow down the estimation significantly. Values lower than 0.\+8-\/0.\+9 can result in an incorrectly estimated transformation.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#estimateaffine3d}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+estimate\+Affine3D} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_af7bf72e6c32472fe5de24cbd8e749435}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_af7bf72e6c32472fe5de24cbd8e749435}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!estimate\+Affine3D@{estimate\+Affine3D}}
\index{estimate\+Affine3D@{estimate\+Affine3D}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{estimate\+Affine3\+D()}{estimateAffine3D()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static int org.\+opencv.\+calib3d.\+Calib3d.\+estimate\+Affine3D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{out,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{inliers }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes an optimal affine transformation between two 3D point sets.

The function estimates an optimal 3D affine transformation between two 3D point sets using the R\+A\+N\+S\+AC algorithm.


\begin{DoxyParams}{Parameters}
{\em src} & First input 3D point set. \\
\hline
{\em dst} & Second input 3D point set. \\
\hline
{\em out} & Output 3D affine transformation matrix {\itshape 3 x 4}. \\
\hline
{\em inliers} & Output vector indicating which points are inliers.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#estimateaffine3d}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+estimate\+Affine3D} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaf626e5e34382b1b5a594d4790501c20}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaf626e5e34382b1b5a594d4790501c20}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!filter\+Speckles@{filter\+Speckles}}
\index{filter\+Speckles@{filter\+Speckles}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{filter\+Speckles()}{filterSpeckles()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+filter\+Speckles (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{double}]{new\+Val,  }\item[{int}]{max\+Speckle\+Size,  }\item[{double}]{max\+Diff,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Filters off small noise blobs (speckles) in the disparity map


\begin{DoxyParams}{Parameters}
{\em img} & The input 16-\/bit signed disparity image \\
\hline
{\em new\+Val} & The disparity value used to paint-\/off the speckles \\
\hline
{\em max\+Speckle\+Size} & The maximum speckle size to consider it a speckle. Larger blobs are not affected by the algorithm \\
\hline
{\em max\+Diff} & Maximum difference between neighbor disparity pixels to put them into the same blob. Note that since \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_stereo_b_m}{Stereo\+BM}}, \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_stereo_s_g_b_m}{Stereo\+S\+G\+BM}} and may be other algorithms return a fixed-\/point disparity map, where disparity values are multiplied by 16, this scale factor should be taken into account when specifying this parameter value. \\
\hline
{\em buf} & The optional temporary buffer to avoid memory allocation within the function.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#filterspeckles}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+filter\+Speckles} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aa3d550489967c6395ec1ca2f118ee06d}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aa3d550489967c6395ec1ca2f118ee06d}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!filter\+Speckles@{filter\+Speckles}}
\index{filter\+Speckles@{filter\+Speckles}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{filter\+Speckles()}{filterSpeckles()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+filter\+Speckles (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{double}]{new\+Val,  }\item[{int}]{max\+Speckle\+Size,  }\item[{double}]{max\+Diff }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Filters off small noise blobs (speckles) in the disparity map


\begin{DoxyParams}{Parameters}
{\em img} & The input 16-\/bit signed disparity image \\
\hline
{\em new\+Val} & The disparity value used to paint-\/off the speckles \\
\hline
{\em max\+Speckle\+Size} & The maximum speckle size to consider it a speckle. Larger blobs are not affected by the algorithm \\
\hline
{\em max\+Diff} & Maximum difference between neighbor disparity pixels to put them into the same blob. Note that since \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_stereo_b_m}{Stereo\+BM}}, \mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_stereo_s_g_b_m}{Stereo\+S\+G\+BM}} and may be other algorithms return a fixed-\/point disparity map, where disparity values are multiplied by 16, this scale factor should be taken into account when specifying this parameter value.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#filterspeckles}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+filter\+Speckles} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5a4ea03ae303cf3c5a327ec5c85047a5}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5a4ea03ae303cf3c5a327ec5c85047a5}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!find\+Chessboard\+Corners@{find\+Chessboard\+Corners}}
\index{find\+Chessboard\+Corners@{find\+Chessboard\+Corners}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{find\+Chessboard\+Corners()}{findChessboardCorners()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+calib3d.\+Calib3d.\+find\+Chessboard\+Corners (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{pattern\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{corners,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the positions of internal corners of the chessboard.

The function attempts to determine whether the input image is a view of the chessboard pattern and locate the internal chessboard corners. The function returns a non-\/zero value if all of the corners are found and they are placed in a certain order (row by row, left to right in every row). Otherwise, if the function fails to find all the corners or reorder them, it returns 0. For example, a regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that is, points where the black squares touch each other. The detected coordinates are approximate, and to determine their positions more accurately, the function calls \char`\"{}corner\+Sub\+Pix\char`\"{}. You also may use the function \char`\"{}corner\+Sub\+Pix\char`\"{} with different parameters if returned coordinates are not accurate enough. Sample usage of detecting and drawing chessboard corners\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily Size patternsize(8,6); //interior number of corners}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat gray =....; //source image}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point2f$>$ corners; //this will be filled by the detected corners}

{\ttfamily }

{\ttfamily }

{\ttfamily //\+C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+F\+A\+S\+T\+\_\+\+C\+H\+E\+CK saves a lot of time on images}

{\ttfamily }

{\ttfamily }

{\ttfamily //that do not contain any chessboard corners}

{\ttfamily }

{\ttfamily }

{\ttfamily bool patternfound = find\+Chessboard\+Corners(gray, patternsize, corners,}

{\ttfamily }

{\ttfamily }

{\ttfamily C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+A\+D\+A\+P\+T\+I\+V\+E\+\_\+\+T\+H\+R\+E\+SH + C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+E\+\_\+\+I\+M\+A\+GE}

{\ttfamily }

{\ttfamily }

{\ttfamily + C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+F\+A\+S\+T\+\_\+\+C\+H\+E\+CK);}

{\ttfamily }

{\ttfamily }

{\ttfamily if(patternfound)}

{\ttfamily }

{\ttfamily }

{\ttfamily corner\+Sub\+Pix(gray, corners, Size(11, 11), Size(-\/1, -\/1),}

{\ttfamily }

{\ttfamily }

{\ttfamily Term\+Criteria(C\+V\+\_\+\+T\+E\+R\+M\+C\+R\+I\+T\+\_\+\+E\+PS + C\+V\+\_\+\+T\+E\+R\+M\+C\+R\+I\+T\+\_\+\+I\+T\+ER, 30, 0.\+1));}

{\ttfamily }

{\ttfamily }

{\ttfamily draw\+Chessboard\+Corners(img, patternsize, Mat(corners), patternfound);}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: The function requires white space (like a square-\/thick border, the wider the better) around the board to make the detection more robust in various environments. Otherwise, if there is no border and the background is dark, the outer black squares cannot be segmented properly and so the square grouping and ordering algorithm fails. }


\begin{DoxyParams}{Parameters}
{\em image} & Source chessboard view. It must be an 8-\/bit grayscale or color image. \\
\hline
{\em pattern\+Size} & Number of inner corners per a chessboard row and column {\ttfamily (pattern\+Size = cv\+Size(points\+\_\+per\+\_\+row,points\+\_\+per\+\_\+colum) = cv\+Size(columns,rows))}. \\
\hline
{\em corners} & Output array of detected corners. \\
\hline
{\em flags} & Various operation flags that can be zero or a combination of the following values\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+A\+D\+A\+P\+T\+I\+V\+E\+\_\+\+T\+H\+R\+E\+SH Use adaptive thresholding to convert the image to black and white, rather than a fixed threshold level (computed from the average image brightness). 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+E\+\_\+\+I\+M\+A\+GE Normalize the image gamma with \char`\"{}equalize\+Hist\char`\"{} before applying fixed or adaptive thresholding. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+F\+I\+L\+T\+E\+R\+\_\+\+Q\+U\+A\+DS Use additional criteria (like contour area, perimeter, square-\/like shape) to filter out false quads extracted at the contour retrieval stage. 
\item C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+F\+A\+S\+T\+\_\+\+C\+H\+E\+CK Run a fast check on the image that looks for chessboard corners, and shortcut the call if none is found. This can drastically speed up the call in the degenerate condition when no chessboard is observed. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findchessboardcorners}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+find\+Chessboard\+Corners} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aa309372b843626fe1d7195ea65bf01ce}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aa309372b843626fe1d7195ea65bf01ce}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!find\+Chessboard\+Corners@{find\+Chessboard\+Corners}}
\index{find\+Chessboard\+Corners@{find\+Chessboard\+Corners}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{find\+Chessboard\+Corners()}{findChessboardCorners()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+calib3d.\+Calib3d.\+find\+Chessboard\+Corners (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{pattern\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{corners }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the positions of internal corners of the chessboard.

The function attempts to determine whether the input image is a view of the chessboard pattern and locate the internal chessboard corners. The function returns a non-\/zero value if all of the corners are found and they are placed in a certain order (row by row, left to right in every row). Otherwise, if the function fails to find all the corners or reorder them, it returns 0. For example, a regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that is, points where the black squares touch each other. The detected coordinates are approximate, and to determine their positions more accurately, the function calls \char`\"{}corner\+Sub\+Pix\char`\"{}. You also may use the function \char`\"{}corner\+Sub\+Pix\char`\"{} with different parameters if returned coordinates are not accurate enough. Sample usage of detecting and drawing chessboard corners\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily Size patternsize(8,6); //interior number of corners}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat gray =....; //source image}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point2f$>$ corners; //this will be filled by the detected corners}

{\ttfamily }

{\ttfamily }

{\ttfamily //\+C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+F\+A\+S\+T\+\_\+\+C\+H\+E\+CK saves a lot of time on images}

{\ttfamily }

{\ttfamily }

{\ttfamily //that do not contain any chessboard corners}

{\ttfamily }

{\ttfamily }

{\ttfamily bool patternfound = find\+Chessboard\+Corners(gray, patternsize, corners,}

{\ttfamily }

{\ttfamily }

{\ttfamily C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+A\+D\+A\+P\+T\+I\+V\+E\+\_\+\+T\+H\+R\+E\+SH + C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+E\+\_\+\+I\+M\+A\+GE}

{\ttfamily }

{\ttfamily }

{\ttfamily + C\+A\+L\+I\+B\+\_\+\+C\+B\+\_\+\+F\+A\+S\+T\+\_\+\+C\+H\+E\+CK);}

{\ttfamily }

{\ttfamily }

{\ttfamily if(patternfound)}

{\ttfamily }

{\ttfamily }

{\ttfamily corner\+Sub\+Pix(gray, corners, Size(11, 11), Size(-\/1, -\/1),}

{\ttfamily }

{\ttfamily }

{\ttfamily Term\+Criteria(C\+V\+\_\+\+T\+E\+R\+M\+C\+R\+I\+T\+\_\+\+E\+PS + C\+V\+\_\+\+T\+E\+R\+M\+C\+R\+I\+T\+\_\+\+I\+T\+ER, 30, 0.\+1));}

{\ttfamily }

{\ttfamily }

{\ttfamily draw\+Chessboard\+Corners(img, patternsize, Mat(corners), patternfound);}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: The function requires white space (like a square-\/thick border, the wider the better) around the board to make the detection more robust in various environments. Otherwise, if there is no border and the background is dark, the outer black squares cannot be segmented properly and so the square grouping and ordering algorithm fails. }


\begin{DoxyParams}{Parameters}
{\em image} & Source chessboard view. It must be an 8-\/bit grayscale or color image. \\
\hline
{\em pattern\+Size} & Number of inner corners per a chessboard row and column {\ttfamily (pattern\+Size = cv\+Size(points\+\_\+per\+\_\+row,points\+\_\+per\+\_\+colum) = cv\+Size(columns,rows))}. \\
\hline
{\em corners} & Output array of detected corners.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findchessboardcorners}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+find\+Chessboard\+Corners} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a1ca6a42bf6b43db65fc0f231db9d2117}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a1ca6a42bf6b43db65fc0f231db9d2117}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!find\+Circles\+Grid\+Default@{find\+Circles\+Grid\+Default}}
\index{find\+Circles\+Grid\+Default@{find\+Circles\+Grid\+Default}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{find\+Circles\+Grid\+Default()}{findCirclesGridDefault()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+calib3d.\+Calib3d.\+find\+Circles\+Grid\+Default (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{pattern\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{centers,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a07ab97ed42f8f202715b367a9e31d903}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a07ab97ed42f8f202715b367a9e31d903}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!find\+Circles\+Grid\+Default@{find\+Circles\+Grid\+Default}}
\index{find\+Circles\+Grid\+Default@{find\+Circles\+Grid\+Default}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{find\+Circles\+Grid\+Default()}{findCirclesGridDefault()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+calib3d.\+Calib3d.\+find\+Circles\+Grid\+Default (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{pattern\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{centers }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3dedba28209d17c56b4470b9cce95596}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3dedba28209d17c56b4470b9cce95596}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!find\+Fundamental\+Mat@{find\+Fundamental\+Mat}}
\index{find\+Fundamental\+Mat@{find\+Fundamental\+Mat}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{find\+Fundamental\+Mat()}{findFundamentalMat()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+calib3d.\+Calib3d.\+find\+Fundamental\+Mat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{points1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{points2,  }\item[{int}]{method,  }\item[{double}]{param1,  }\item[{double}]{param2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a fundamental matrix from the corresponding points in two images.

The epipolar geometry is described by the following equation\+:

{\itshape \mbox{[}p\+\_\+2; 1\mbox{]}$^\wedge$T F \mbox{[}p\+\_\+1; 1\mbox{]} = 0}

where {\itshape F} is a fundamental matrix, {\itshape p\+\_\+1} and {\itshape p\+\_\+2} are corresponding points in the first and the second images, respectively.

The function calculates the fundamental matrix using one of four methods listed above and returns the found fundamental matrix. Normally just one matrix is found. But in case of the 7-\/point algorithm, the function may return up to 3 solutions ({\itshape 9 x 3} matrix that stores all 3 matrices sequentially).

The calculated fundamental matrix may be passed further to \char`\"{}compute\+Correspond\+Epilines\char`\"{} that finds the epipolar lines corresponding to the specified points. It can also be passed to\char`\"{}stereo\+Rectify\+Uncalibrated\char`\"{} to compute the rectification transformation. {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // Example. Estimation of fundamental matrix using the R\+A\+N\+S\+AC algorithm}

{\ttfamily }

{\ttfamily }

{\ttfamily int point\+\_\+count = 100;}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point2f$>$ points1(point\+\_\+count);}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point2f$>$ points2(point\+\_\+count);}

{\ttfamily }

{\ttfamily }

{\ttfamily // initialize the points here... $\ast$ /}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int i = 0; i $<$ point\+\_\+count; i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily points1\mbox{[}i\mbox{]} =...;}

{\ttfamily }

{\ttfamily }

{\ttfamily points2\mbox{[}i\mbox{]} =...;}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat fundamental\+\_\+matrix =}

{\ttfamily }

{\ttfamily }

{\ttfamily find\+Fundamental\+Mat(points1, points2, F\+M\+\_\+\+R\+A\+N\+S\+AC, 3, 0.\+99);}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em points1} & Array of {\ttfamily N} points from the first image. The point coordinates should be floating-\/point (single or double precision). \\
\hline
{\em points2} & Array of the second image points of the same size and format as {\ttfamily points1}. \\
\hline
{\em method} & Method for computing a fundamental matrix. 
\begin{DoxyItemize}
\item C\+V\+\_\+\+F\+M\+\_\+7\+P\+O\+I\+NT for a 7-\/point algorithm. {\itshape N = 7} 
\item C\+V\+\_\+\+F\+M\+\_\+8\+P\+O\+I\+NT for an 8-\/point algorithm. {\itshape N $>$= 8} 
\item C\+V\+\_\+\+F\+M\+\_\+\+R\+A\+N\+S\+AC for the R\+A\+N\+S\+AC algorithm. {\itshape N $>$= 8} 
\item C\+V\+\_\+\+F\+M\+\_\+\+L\+M\+E\+DS for the L\+MedS algorithm. {\itshape N $>$= 8} 
\end{DoxyItemize}\\
\hline
{\em param1} & Parameter used for R\+A\+N\+S\+AC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-\/3, depending on the accuracy of the point localization, image resolution, and the image noise. \\
\hline
{\em param2} & Parameter used for the R\+A\+N\+S\+AC or L\+MedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct. \\
\hline
{\em mask} & a mask\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findfundamentalmat}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+find\+Fundamental\+Mat} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ab758a6250812f65ccec0421d386be1c8}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ab758a6250812f65ccec0421d386be1c8}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!find\+Fundamental\+Mat@{find\+Fundamental\+Mat}}
\index{find\+Fundamental\+Mat@{find\+Fundamental\+Mat}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{find\+Fundamental\+Mat()}{findFundamentalMat()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+calib3d.\+Calib3d.\+find\+Fundamental\+Mat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{points1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{points2,  }\item[{int}]{method,  }\item[{double}]{param1,  }\item[{double}]{param2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a fundamental matrix from the corresponding points in two images.

The epipolar geometry is described by the following equation\+:

{\itshape \mbox{[}p\+\_\+2; 1\mbox{]}$^\wedge$T F \mbox{[}p\+\_\+1; 1\mbox{]} = 0}

where {\itshape F} is a fundamental matrix, {\itshape p\+\_\+1} and {\itshape p\+\_\+2} are corresponding points in the first and the second images, respectively.

The function calculates the fundamental matrix using one of four methods listed above and returns the found fundamental matrix. Normally just one matrix is found. But in case of the 7-\/point algorithm, the function may return up to 3 solutions ({\itshape 9 x 3} matrix that stores all 3 matrices sequentially).

The calculated fundamental matrix may be passed further to \char`\"{}compute\+Correspond\+Epilines\char`\"{} that finds the epipolar lines corresponding to the specified points. It can also be passed to\char`\"{}stereo\+Rectify\+Uncalibrated\char`\"{} to compute the rectification transformation. {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // Example. Estimation of fundamental matrix using the R\+A\+N\+S\+AC algorithm}

{\ttfamily }

{\ttfamily }

{\ttfamily int point\+\_\+count = 100;}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point2f$>$ points1(point\+\_\+count);}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point2f$>$ points2(point\+\_\+count);}

{\ttfamily }

{\ttfamily }

{\ttfamily // initialize the points here... $\ast$ /}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int i = 0; i $<$ point\+\_\+count; i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily points1\mbox{[}i\mbox{]} =...;}

{\ttfamily }

{\ttfamily }

{\ttfamily points2\mbox{[}i\mbox{]} =...;}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat fundamental\+\_\+matrix =}

{\ttfamily }

{\ttfamily }

{\ttfamily find\+Fundamental\+Mat(points1, points2, F\+M\+\_\+\+R\+A\+N\+S\+AC, 3, 0.\+99);}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em points1} & Array of {\ttfamily N} points from the first image. The point coordinates should be floating-\/point (single or double precision). \\
\hline
{\em points2} & Array of the second image points of the same size and format as {\ttfamily points1}. \\
\hline
{\em method} & Method for computing a fundamental matrix. 
\begin{DoxyItemize}
\item C\+V\+\_\+\+F\+M\+\_\+7\+P\+O\+I\+NT for a 7-\/point algorithm. {\itshape N = 7} 
\item C\+V\+\_\+\+F\+M\+\_\+8\+P\+O\+I\+NT for an 8-\/point algorithm. {\itshape N $>$= 8} 
\item C\+V\+\_\+\+F\+M\+\_\+\+R\+A\+N\+S\+AC for the R\+A\+N\+S\+AC algorithm. {\itshape N $>$= 8} 
\item C\+V\+\_\+\+F\+M\+\_\+\+L\+M\+E\+DS for the L\+MedS algorithm. {\itshape N $>$= 8} 
\end{DoxyItemize}\\
\hline
{\em param1} & Parameter used for R\+A\+N\+S\+AC. It is the maximum distance from a point to an epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. It can be set to something like 1-\/3, depending on the accuracy of the point localization, image resolution, and the image noise. \\
\hline
{\em param2} & Parameter used for the R\+A\+N\+S\+AC or L\+MedS methods only. It specifies a desirable level of confidence (probability) that the estimated matrix is correct.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findfundamentalmat}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+find\+Fundamental\+Mat} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ae4c04269538cdac95954f77f633c25a6}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ae4c04269538cdac95954f77f633c25a6}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!find\+Fundamental\+Mat@{find\+Fundamental\+Mat}}
\index{find\+Fundamental\+Mat@{find\+Fundamental\+Mat}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{find\+Fundamental\+Mat()}{findFundamentalMat()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+calib3d.\+Calib3d.\+find\+Fundamental\+Mat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{points1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{points2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a fundamental matrix from the corresponding points in two images.

The epipolar geometry is described by the following equation\+:

{\itshape \mbox{[}p\+\_\+2; 1\mbox{]}$^\wedge$T F \mbox{[}p\+\_\+1; 1\mbox{]} = 0}

where {\itshape F} is a fundamental matrix, {\itshape p\+\_\+1} and {\itshape p\+\_\+2} are corresponding points in the first and the second images, respectively.

The function calculates the fundamental matrix using one of four methods listed above and returns the found fundamental matrix. Normally just one matrix is found. But in case of the 7-\/point algorithm, the function may return up to 3 solutions ({\itshape 9 x 3} matrix that stores all 3 matrices sequentially).

The calculated fundamental matrix may be passed further to \char`\"{}compute\+Correspond\+Epilines\char`\"{} that finds the epipolar lines corresponding to the specified points. It can also be passed to\char`\"{}stereo\+Rectify\+Uncalibrated\char`\"{} to compute the rectification transformation. {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // Example. Estimation of fundamental matrix using the R\+A\+N\+S\+AC algorithm}

{\ttfamily }

{\ttfamily }

{\ttfamily int point\+\_\+count = 100;}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point2f$>$ points1(point\+\_\+count);}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point2f$>$ points2(point\+\_\+count);}

{\ttfamily }

{\ttfamily }

{\ttfamily // initialize the points here... $\ast$ /}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int i = 0; i $<$ point\+\_\+count; i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily points1\mbox{[}i\mbox{]} =...;}

{\ttfamily }

{\ttfamily }

{\ttfamily points2\mbox{[}i\mbox{]} =...;}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat fundamental\+\_\+matrix =}

{\ttfamily }

{\ttfamily }

{\ttfamily find\+Fundamental\+Mat(points1, points2, F\+M\+\_\+\+R\+A\+N\+S\+AC, 3, 0.\+99);}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em points1} & Array of {\ttfamily N} points from the first image. The point coordinates should be floating-\/point (single or double precision). \\
\hline
{\em points2} & Array of the second image points of the same size and format as {\ttfamily points1}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findfundamentalmat}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+find\+Fundamental\+Mat} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a2c32d44d2f35dc41aa09d54eb6829ab8}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a2c32d44d2f35dc41aa09d54eb6829ab8}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!find\+Homography@{find\+Homography}}
\index{find\+Homography@{find\+Homography}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{find\+Homography()}{findHomography()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+calib3d.\+Calib3d.\+find\+Homography (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{src\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{dst\+Points,  }\item[{int}]{method,  }\item[{double}]{ransac\+Reproj\+Threshold,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds a perspective transformation between two planes.

The functions find and return the perspective transformation {\itshape H} between the source and the destination planes\+:

{\itshape s\+\_\+i \mbox{[}x\textquotesingle{}\+\_\+i y\textquotesingle{}\+\_\+i 1\mbox{]} $\sim$ H \mbox{[}x\+\_\+i y\+\_\+i 1\mbox{]}}

so that the back-\/projection error

{\itshape sum {\itshape i(x\textquotesingle{}\+\_\+i-\/ (h\+\_\+11 x\+\_\+i + h\+\_\+12 y\+\_\+i + h\+\_\+13)/(h}(31) x\+\_\+i + h\+\_\+32 y\+\_\+i + h\+\_\+33))$^\wedge$2+ (y\textquotesingle{}{\itshape i-\/ (h\+\_\+21 x\+\_\+i + h\+\_\+22 y\+\_\+i + h\+\_\+23)/(h}(31) x\+\_\+i + h\+\_\+32 y\+\_\+i + h\+\_\+33))$^\wedge$2}

is minimized. If the parameter {\ttfamily method} is set to the default value 0, the function uses all the point pairs to compute an initial homography estimate with a simple least-\/squares scheme.

However, if not all of the point pairs ({\itshape src\+Points\+\_\+i},{\itshape dst\+Points\+\_\+i}) fit the rigid perspective transformation (that is, there are some outliers), this initial estimate will be poor. In this case, you can use one of the two robust methods. Both methods, {\ttfamily R\+A\+N\+S\+AC} and {\ttfamily L\+Me\+DS}, try many different random subsets of the corresponding point pairs (of four pairs each), estimate the homography matrix using this subset and a simple least-\/square algorithm, and then compute the quality/goodness of the computed homography (which is the number of inliers for R\+A\+N\+S\+AC or the median re-\/projection error for L\+Me\+Ds). The best subset is then used to produce the initial estimate of the homography matrix and the mask of inliers/outliers.

Regardless of the method, robust or not, the computed homography matrix is refined further (using inliers only in case of a robust method) with the Levenberg-\/\+Marquardt method to reduce the re-\/projection error even more.

The method {\ttfamily R\+A\+N\+S\+AC} can handle practically any ratio of outliers but it needs a threshold to distinguish inliers from outliers. The method {\ttfamily L\+Me\+DS} does not need any threshold but it works correctly only when there are more than 50\% of inliers. Finally, if there are no outliers and the noise is rather small, use the default method ({\ttfamily method=0}).

The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is determined up to a scale. Thus, it is normalized so that {\itshape h\+\_\+33=1}.

Note\+:


\begin{DoxyItemize}
\item A example on calculating a homography for image matching can be found at opencv\+\_\+source\+\_\+code/samples/cpp/video\+\_\+homography.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src\+Points} & Coordinates of the points in the original plane, a matrix of the type {\ttfamily C\+V\+\_\+32\+F\+C2} or {\ttfamily vector$<$\+Point2f$>$}. \\
\hline
{\em dst\+Points} & Coordinates of the points in the target plane, a matrix of the type {\ttfamily C\+V\+\_\+32\+F\+C2} or a {\ttfamily vector$<$\+Point2f$>$}. \\
\hline
{\em method} & Method used to computed a homography matrix. The following methods are possible\+: 
\begin{DoxyItemize}
\item 0 -\/ a regular method using all the points 
\item C\+V\+\_\+\+R\+A\+N\+S\+AC -\/ R\+A\+N\+S\+A\+C-\/based robust method 
\item C\+V\+\_\+\+L\+M\+E\+DS -\/ Least-\/\+Median robust method 
\end{DoxyItemize}\\
\hline
{\em ransac\+Reproj\+Threshold} & Maximum allowed reprojection error to treat a point pair as an inlier (used in the R\+A\+N\+S\+AC method only). That is, if\\
\hline
\end{DoxyParams}


{\itshape $\vert$ dst\+Points \+\_\+i -\/ convert\+Points\+Homogeneous(\+H $\ast$ src\+Points \+\_\+i)$\vert$ \&gt ransac\+Reproj\+Threshold}

then the point {\itshape i} is considered an outlier. If {\ttfamily src\+Points} and {\ttfamily dst\+Points} are measured in pixels, it usually makes sense to set this parameter somewhere in the range of 1 to 10.


\begin{DoxyParams}{Parameters}
{\em mask} & Optional output mask set by a robust method ({\ttfamily C\+V\+\_\+\+R\+A\+N\+S\+AC} or {\ttfamily C\+V\+\_\+\+L\+M\+E\+DS}). Note that the input mask values are ignored.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findhomography}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+find\+Homography} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1ff0eace0f00e79af5228fdae120342a}{org.\+opencv.\+core.\+Core\+::perspective\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1video_1_1_video_ad9c2fbb377a485b9619be2c78eaf7cee}{org.\+opencv.\+video.\+Video\+::estimate\+Rigid\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a283e61c00d4e6ba9625264d8d7f5f8db}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Affine\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab3727363e269af640d5254f76e14ddb6}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Perspective\+Transform}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad95dde1b1f976545692c0fc8b11d2c22}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad95dde1b1f976545692c0fc8b11d2c22}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!find\+Homography@{find\+Homography}}
\index{find\+Homography@{find\+Homography}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{find\+Homography()}{findHomography()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+calib3d.\+Calib3d.\+find\+Homography (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{src\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{dst\+Points,  }\item[{int}]{method,  }\item[{double}]{ransac\+Reproj\+Threshold }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds a perspective transformation between two planes.

The functions find and return the perspective transformation {\itshape H} between the source and the destination planes\+:

{\itshape s\+\_\+i \mbox{[}x\textquotesingle{}\+\_\+i y\textquotesingle{}\+\_\+i 1\mbox{]} $\sim$ H \mbox{[}x\+\_\+i y\+\_\+i 1\mbox{]}}

so that the back-\/projection error

{\itshape sum {\itshape i(x\textquotesingle{}\+\_\+i-\/ (h\+\_\+11 x\+\_\+i + h\+\_\+12 y\+\_\+i + h\+\_\+13)/(h}(31) x\+\_\+i + h\+\_\+32 y\+\_\+i + h\+\_\+33))$^\wedge$2+ (y\textquotesingle{}{\itshape i-\/ (h\+\_\+21 x\+\_\+i + h\+\_\+22 y\+\_\+i + h\+\_\+23)/(h}(31) x\+\_\+i + h\+\_\+32 y\+\_\+i + h\+\_\+33))$^\wedge$2}

is minimized. If the parameter {\ttfamily method} is set to the default value 0, the function uses all the point pairs to compute an initial homography estimate with a simple least-\/squares scheme.

However, if not all of the point pairs ({\itshape src\+Points\+\_\+i},{\itshape dst\+Points\+\_\+i}) fit the rigid perspective transformation (that is, there are some outliers), this initial estimate will be poor. In this case, you can use one of the two robust methods. Both methods, {\ttfamily R\+A\+N\+S\+AC} and {\ttfamily L\+Me\+DS}, try many different random subsets of the corresponding point pairs (of four pairs each), estimate the homography matrix using this subset and a simple least-\/square algorithm, and then compute the quality/goodness of the computed homography (which is the number of inliers for R\+A\+N\+S\+AC or the median re-\/projection error for L\+Me\+Ds). The best subset is then used to produce the initial estimate of the homography matrix and the mask of inliers/outliers.

Regardless of the method, robust or not, the computed homography matrix is refined further (using inliers only in case of a robust method) with the Levenberg-\/\+Marquardt method to reduce the re-\/projection error even more.

The method {\ttfamily R\+A\+N\+S\+AC} can handle practically any ratio of outliers but it needs a threshold to distinguish inliers from outliers. The method {\ttfamily L\+Me\+DS} does not need any threshold but it works correctly only when there are more than 50\% of inliers. Finally, if there are no outliers and the noise is rather small, use the default method ({\ttfamily method=0}).

The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is determined up to a scale. Thus, it is normalized so that {\itshape h\+\_\+33=1}.

Note\+:


\begin{DoxyItemize}
\item A example on calculating a homography for image matching can be found at opencv\+\_\+source\+\_\+code/samples/cpp/video\+\_\+homography.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src\+Points} & Coordinates of the points in the original plane, a matrix of the type {\ttfamily C\+V\+\_\+32\+F\+C2} or {\ttfamily vector$<$\+Point2f$>$}. \\
\hline
{\em dst\+Points} & Coordinates of the points in the target plane, a matrix of the type {\ttfamily C\+V\+\_\+32\+F\+C2} or a {\ttfamily vector$<$\+Point2f$>$}. \\
\hline
{\em method} & Method used to computed a homography matrix. The following methods are possible\+: 
\begin{DoxyItemize}
\item 0 -\/ a regular method using all the points 
\item C\+V\+\_\+\+R\+A\+N\+S\+AC -\/ R\+A\+N\+S\+A\+C-\/based robust method 
\item C\+V\+\_\+\+L\+M\+E\+DS -\/ Least-\/\+Median robust method 
\end{DoxyItemize}\\
\hline
{\em ransac\+Reproj\+Threshold} & Maximum allowed reprojection error to treat a point pair as an inlier (used in the R\+A\+N\+S\+AC method only). That is, if\\
\hline
\end{DoxyParams}


{\itshape $\vert$ dst\+Points \+\_\+i -\/ convert\+Points\+Homogeneous(\+H $\ast$ src\+Points \+\_\+i)$\vert$ \&gt ransac\+Reproj\+Threshold}

then the point {\itshape i} is considered an outlier. If {\ttfamily src\+Points} and {\ttfamily dst\+Points} are measured in pixels, it usually makes sense to set this parameter somewhere in the range of 1 to 10.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findhomography}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+find\+Homography} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1ff0eace0f00e79af5228fdae120342a}{org.\+opencv.\+core.\+Core\+::perspective\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1video_1_1_video_ad9c2fbb377a485b9619be2c78eaf7cee}{org.\+opencv.\+video.\+Video\+::estimate\+Rigid\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a283e61c00d4e6ba9625264d8d7f5f8db}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Affine\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab3727363e269af640d5254f76e14ddb6}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Perspective\+Transform}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aa3e6fd7652b2fc4c4d19064b39523dae}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aa3e6fd7652b2fc4c4d19064b39523dae}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!find\+Homography@{find\+Homography}}
\index{find\+Homography@{find\+Homography}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{find\+Homography()}{findHomography()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+calib3d.\+Calib3d.\+find\+Homography (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{src\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{dst\+Points }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds a perspective transformation between two planes.

The functions find and return the perspective transformation {\itshape H} between the source and the destination planes\+:

{\itshape s\+\_\+i \mbox{[}x\textquotesingle{}\+\_\+i y\textquotesingle{}\+\_\+i 1\mbox{]} $\sim$ H \mbox{[}x\+\_\+i y\+\_\+i 1\mbox{]}}

so that the back-\/projection error

{\itshape sum {\itshape i(x\textquotesingle{}\+\_\+i-\/ (h\+\_\+11 x\+\_\+i + h\+\_\+12 y\+\_\+i + h\+\_\+13)/(h}(31) x\+\_\+i + h\+\_\+32 y\+\_\+i + h\+\_\+33))$^\wedge$2+ (y\textquotesingle{}{\itshape i-\/ (h\+\_\+21 x\+\_\+i + h\+\_\+22 y\+\_\+i + h\+\_\+23)/(h}(31) x\+\_\+i + h\+\_\+32 y\+\_\+i + h\+\_\+33))$^\wedge$2}

is minimized. If the parameter {\ttfamily method} is set to the default value 0, the function uses all the point pairs to compute an initial homography estimate with a simple least-\/squares scheme.

However, if not all of the point pairs ({\itshape src\+Points\+\_\+i},{\itshape dst\+Points\+\_\+i}) fit the rigid perspective transformation (that is, there are some outliers), this initial estimate will be poor. In this case, you can use one of the two robust methods. Both methods, {\ttfamily R\+A\+N\+S\+AC} and {\ttfamily L\+Me\+DS}, try many different random subsets of the corresponding point pairs (of four pairs each), estimate the homography matrix using this subset and a simple least-\/square algorithm, and then compute the quality/goodness of the computed homography (which is the number of inliers for R\+A\+N\+S\+AC or the median re-\/projection error for L\+Me\+Ds). The best subset is then used to produce the initial estimate of the homography matrix and the mask of inliers/outliers.

Regardless of the method, robust or not, the computed homography matrix is refined further (using inliers only in case of a robust method) with the Levenberg-\/\+Marquardt method to reduce the re-\/projection error even more.

The method {\ttfamily R\+A\+N\+S\+AC} can handle practically any ratio of outliers but it needs a threshold to distinguish inliers from outliers. The method {\ttfamily L\+Me\+DS} does not need any threshold but it works correctly only when there are more than 50\% of inliers. Finally, if there are no outliers and the noise is rather small, use the default method ({\ttfamily method=0}).

The function is used to find initial intrinsic and extrinsic matrices. Homography matrix is determined up to a scale. Thus, it is normalized so that {\itshape h\+\_\+33=1}.

Note\+:


\begin{DoxyItemize}
\item A example on calculating a homography for image matching can be found at opencv\+\_\+source\+\_\+code/samples/cpp/video\+\_\+homography.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src\+Points} & Coordinates of the points in the original plane, a matrix of the type {\ttfamily C\+V\+\_\+32\+F\+C2} or {\ttfamily vector$<$\+Point2f$>$}. \\
\hline
{\em dst\+Points} & Coordinates of the points in the target plane, a matrix of the type {\ttfamily C\+V\+\_\+32\+F\+C2} or a {\ttfamily vector$<$\+Point2f$>$}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#findhomography}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+find\+Homography} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1ff0eace0f00e79af5228fdae120342a}{org.\+opencv.\+core.\+Core\+::perspective\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1video_1_1_video_ad9c2fbb377a485b9619be2c78eaf7cee}{org.\+opencv.\+video.\+Video\+::estimate\+Rigid\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a283e61c00d4e6ba9625264d8d7f5f8db}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Affine\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab3727363e269af640d5254f76e14ddb6}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Perspective\+Transform}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaece56f4a02759da9d1e31d9269e6596}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaece56f4a02759da9d1e31d9269e6596}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!get\+Optimal\+New\+Camera\+Matrix@{get\+Optimal\+New\+Camera\+Matrix}}
\index{get\+Optimal\+New\+Camera\+Matrix@{get\+Optimal\+New\+Camera\+Matrix}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{get\+Optimal\+New\+Camera\+Matrix()}{getOptimalNewCameraMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+calib3d.\+Calib3d.\+get\+Optimal\+New\+Camera\+Matrix (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{double}]{alpha,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{new\+Img\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{valid\+Pix\+R\+OI,  }\item[{boolean}]{center\+Principal\+Point }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the new camera matrix based on the free scaling parameter.

The function computes and returns the optimal new camera matrix based on the free scaling parameter. By varying this parameter, you may retrieve only sensible pixels {\ttfamily alpha=0}, keep all the original image pixels if there is valuable information in the corners {\ttfamily alpha=1}, or get something in between. When {\ttfamily alpha$>$0}, the undistortion result is likely to have some black pixels corresponding to \char`\"{}virtual\char`\"{} pixels outside of the captured distorted image. The original camera matrix, distortion coefficients, the computed new camera matrix, and {\ttfamily new\+Image\+Size} should be passed to \char`\"{}init\+Undistort\+Rectify\+Map\char`\"{} to produce the maps for \char`\"{}remap\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em camera\+Matrix} & Input camera matrix. \\
\hline
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed. \\
\hline
{\em image\+Size} & Original image size. \\
\hline
{\em alpha} & Free scaling parameter between 0 (when all the pixels in the undistorted image are valid) and 1 (when all the source image pixels are retained in the undistorted image). See \char`\"{}stereo\+Rectify\char`\"{} for details. \\
\hline
{\em new\+Img\+Size} & a new\+Img\+Size \\
\hline
{\em valid\+Pix\+R\+OI} & Optional output rectangle that outlines all-\/good-\/pixels region in the undistorted image. See {\ttfamily roi1, roi2} description in \char`\"{}stereo\+Rectify\char`\"{}. \\
\hline
{\em center\+Principal\+Point} & Optional flag that indicates whether in the new camera matrix the principal point should be at the image center or not. By default, the principal point is chosen to best fit a subset of the source image (determined by {\ttfamily alpha}) to the corrected image.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#getoptimalnewcameramatrix}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+get\+Optimal\+New\+Camera\+Matrix} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a6a86093a8d328292e60c8592ac5d7b22}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a6a86093a8d328292e60c8592ac5d7b22}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!get\+Optimal\+New\+Camera\+Matrix@{get\+Optimal\+New\+Camera\+Matrix}}
\index{get\+Optimal\+New\+Camera\+Matrix@{get\+Optimal\+New\+Camera\+Matrix}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{get\+Optimal\+New\+Camera\+Matrix()}{getOptimalNewCameraMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+calib3d.\+Calib3d.\+get\+Optimal\+New\+Camera\+Matrix (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{double}]{alpha }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the new camera matrix based on the free scaling parameter.

The function computes and returns the optimal new camera matrix based on the free scaling parameter. By varying this parameter, you may retrieve only sensible pixels {\ttfamily alpha=0}, keep all the original image pixels if there is valuable information in the corners {\ttfamily alpha=1}, or get something in between. When {\ttfamily alpha$>$0}, the undistortion result is likely to have some black pixels corresponding to \char`\"{}virtual\char`\"{} pixels outside of the captured distorted image. The original camera matrix, distortion coefficients, the computed new camera matrix, and {\ttfamily new\+Image\+Size} should be passed to \char`\"{}init\+Undistort\+Rectify\+Map\char`\"{} to produce the maps for \char`\"{}remap\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em camera\+Matrix} & Input camera matrix. \\
\hline
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed. \\
\hline
{\em image\+Size} & Original image size. \\
\hline
{\em alpha} & Free scaling parameter between 0 (when all the pixels in the undistorted image are valid) and 1 (when all the source image pixels are retained in the undistorted image). See \char`\"{}stereo\+Rectify\char`\"{} for details.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#getoptimalnewcameramatrix}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+get\+Optimal\+New\+Camera\+Matrix} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a48c12be1bc3f11177e060cbd807ab92e}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a48c12be1bc3f11177e060cbd807ab92e}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!get\+Valid\+Disparity\+R\+OI@{get\+Valid\+Disparity\+R\+OI}}
\index{get\+Valid\+Disparity\+R\+OI@{get\+Valid\+Disparity\+R\+OI}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{get\+Valid\+Disparity\+R\+O\+I()}{getValidDisparityROI()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} org.\+opencv.\+calib3d.\+Calib3d.\+get\+Valid\+Disparity\+R\+OI (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{roi1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{roi2,  }\item[{int}]{min\+Disparity,  }\item[{int}]{number\+Of\+Disparities,  }\item[{int}]{S\+A\+D\+Window\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a15df47d3a4b4a3ef48f13d1c09aae9cb}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a15df47d3a4b4a3ef48f13d1c09aae9cb}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!init\+Camera\+Matrix2D@{init\+Camera\+Matrix2D}}
\index{init\+Camera\+Matrix2D@{init\+Camera\+Matrix2D}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{init\+Camera\+Matrix2\+D()}{initCameraMatrix2D()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+calib3d.\+Calib3d.\+init\+Camera\+Matrix2D (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}} $>$}]{object\+Points,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} $>$}]{image\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{double}]{aspect\+Ratio }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds an initial camera matrix from 3\+D-\/2D point correspondences.

The function estimates and returns an initial camera matrix for the camera calibration process. Currently, the function only supports planar calibration patterns, which are patterns where each object point has z-\/coordinate =0.


\begin{DoxyParams}{Parameters}
{\em object\+Points} & Vector of vectors of the calibration pattern points in the calibration pattern coordinate space. In the old interface all the per-\/view vectors are concatenated. See \char`\"{}calibrate\+Camera\char`\"{} for details. \\
\hline
{\em image\+Points} & Vector of vectors of the projections of the calibration pattern points. In the old interface all the per-\/view vectors are concatenated. \\
\hline
{\em image\+Size} & Image size in pixels used to initialize the principal point. \\
\hline
{\em aspect\+Ratio} & If it is zero or negative, both {\itshape f\+\_\+x} and {\itshape f\+\_\+y} are estimated independently. Otherwise, {\itshape f\+\_\+x = f\+\_\+y $\ast$ aspect\+Ratio}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#initcameramatrix2d}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+init\+Camera\+Matrix2D} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a6f6b4970eeeaa930d31f4a6f8dc5ea5f}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a6f6b4970eeeaa930d31f4a6f8dc5ea5f}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!init\+Camera\+Matrix2D@{init\+Camera\+Matrix2D}}
\index{init\+Camera\+Matrix2D@{init\+Camera\+Matrix2D}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{init\+Camera\+Matrix2\+D()}{initCameraMatrix2D()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+calib3d.\+Calib3d.\+init\+Camera\+Matrix2D (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}} $>$}]{object\+Points,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} $>$}]{image\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds an initial camera matrix from 3\+D-\/2D point correspondences.

The function estimates and returns an initial camera matrix for the camera calibration process. Currently, the function only supports planar calibration patterns, which are patterns where each object point has z-\/coordinate =0.


\begin{DoxyParams}{Parameters}
{\em object\+Points} & Vector of vectors of the calibration pattern points in the calibration pattern coordinate space. In the old interface all the per-\/view vectors are concatenated. See \char`\"{}calibrate\+Camera\char`\"{} for details. \\
\hline
{\em image\+Points} & Vector of vectors of the projections of the calibration pattern points. In the old interface all the per-\/view vectors are concatenated. \\
\hline
{\em image\+Size} & Image size in pixels used to initialize the principal point.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#initcameramatrix2d}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+init\+Camera\+Matrix2D} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ac74d1c19f77ac11af4ec2e92df9cacf9}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ac74d1c19f77ac11af4ec2e92df9cacf9}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!mat\+Mul\+Deriv@{mat\+Mul\+Deriv}}
\index{mat\+Mul\+Deriv@{mat\+Mul\+Deriv}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{mat\+Mul\+Deriv()}{matMulDeriv()}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+mat\+Mul\+Deriv (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{A,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{B,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{d\+A\+BdA,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{d\+A\+BdB }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes partial derivatives of the matrix product for each multiplied matrix.

The function computes partial derivatives of the elements of the matrix product {\itshape A$\ast$B} with regard to the elements of each of the two input matrices. The function is used to compute the Jacobian matrices in \char`\"{}stereo\+Calibrate\char`\"{} but can also be used in any other similar optimization function.


\begin{DoxyParams}{Parameters}
{\em A} & First multiplied matrix. \\
\hline
{\em B} & Second multiplied matrix. \\
\hline
{\em d\+A\+BdA} & First output derivative matrix {\ttfamily d(\+A$\ast$\+B)/dA} of size {\itshape A.\+rows$\ast$B.cols x (A.\+rows$\ast$A.cols)}. \\
\hline
{\em d\+A\+BdB} & Second output derivative matrix {\ttfamily d(\+A$\ast$\+B)/dB} of size {\itshape A.\+rows$\ast$B.cols x (B.\+rows$\ast$B.cols)}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#matmulderiv}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+mat\+Mul\+Deriv} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5461d27f043f4a420fea1fac01a745e4}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5461d27f043f4a420fea1fac01a745e4}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!project\+Points@{project\+Points}}
\index{project\+Points@{project\+Points}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{project\+Points()}{projectPoints()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+project\+Points (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}}}]{object\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{image\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{jacobian,  }\item[{double}]{aspect\+Ratio }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Projects 3D points to an image plane.

The function computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes Jacobians -\/ matrices of partial derivatives of image points coordinates (as functions of all the input parameters) with respect to the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global optimization in \char`\"{}calibrate\+Camera\char`\"{}, \char`\"{}solve\+Pn\+P\char`\"{}, and \char`\"{}stereo\+Calibrate\char`\"{}. The function itself can also be used to compute a re-\/projection error given the current intrinsic and extrinsic parameters.

Note\+: By setting {\ttfamily rvec=tvec=(0,0,0)} or by setting {\ttfamily camera\+Matrix} to a 3x3 identity matrix, or by passing zero distortion coefficients, you can get various useful partial cases of the function. This means that you can compute the distorted coordinates for a sparse set of points or apply a perspective transformation (and also compute the derivatives) in the ideal zero-\/distortion setup.


\begin{DoxyParams}{Parameters}
{\em object\+Points} & Array of object points, 3x\+N/\+Nx3 1-\/channel or 1x\+N/\+Nx1 3-\/channel (or {\ttfamily vector$<$\+Point3f$>$}), where N is the number of points in the view. \\
\hline
{\em rvec} & Rotation vector. See \char`\"{}\+Rodrigues\char`\"{} for details. \\
\hline
{\em tvec} & Translation vector. \\
\hline
{\em camera\+Matrix} & Camera matrix {\itshape A = }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x 0 c\+\_\+x$\vert$ $\vert$0 f\+\_\+y c\+\_\+y$\vert$ $\vert$0 0 \+\_\+1$\vert$ .

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed. \\
\hline
{\em image\+Points} & Output array of image points, 2x\+N/\+Nx2 1-\/channel or 1x\+N/\+Nx1 2-\/channel, or {\ttfamily vector$<$\+Point2f$>$}. \\
\hline
{\em jacobian} & Optional output 2\+Nx(10+$<$num\+Dist\+Coeffs$>$) jacobian matrix of derivatives of image points with respect to components of the rotation vector, translation vector, focal lengths, coordinates of the principal point and the distortion coefficients. In the old interface different components of the jacobian are returned via different output parameters. \\
\hline
{\em aspect\+Ratio} & Optional \char`\"{}fixed aspect ratio\char`\"{} parameter. If the parameter is not 0, the function assumes that the aspect ratio ({\itshape fx/fy}) is fixed and correspondingly adjusts the jacobian matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#projectpoints}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+project\+Points} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a7084118c49e74c2a442e461ccaa1c97c}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a7084118c49e74c2a442e461ccaa1c97c}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!project\+Points@{project\+Points}}
\index{project\+Points@{project\+Points}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{project\+Points()}{projectPoints()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+project\+Points (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}}}]{object\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{image\+Points }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Projects 3D points to an image plane.

The function computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes Jacobians -\/ matrices of partial derivatives of image points coordinates (as functions of all the input parameters) with respect to the particular parameters, intrinsic and/or extrinsic. The Jacobians are used during the global optimization in \char`\"{}calibrate\+Camera\char`\"{}, \char`\"{}solve\+Pn\+P\char`\"{}, and \char`\"{}stereo\+Calibrate\char`\"{}. The function itself can also be used to compute a re-\/projection error given the current intrinsic and extrinsic parameters.

Note\+: By setting {\ttfamily rvec=tvec=(0,0,0)} or by setting {\ttfamily camera\+Matrix} to a 3x3 identity matrix, or by passing zero distortion coefficients, you can get various useful partial cases of the function. This means that you can compute the distorted coordinates for a sparse set of points or apply a perspective transformation (and also compute the derivatives) in the ideal zero-\/distortion setup.


\begin{DoxyParams}{Parameters}
{\em object\+Points} & Array of object points, 3x\+N/\+Nx3 1-\/channel or 1x\+N/\+Nx1 3-\/channel (or {\ttfamily vector$<$\+Point3f$>$}), where N is the number of points in the view. \\
\hline
{\em rvec} & Rotation vector. See \char`\"{}\+Rodrigues\char`\"{} for details. \\
\hline
{\em tvec} & Translation vector. \\
\hline
{\em camera\+Matrix} & Camera matrix {\itshape A = }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x 0 c\+\_\+x$\vert$ $\vert$0 f\+\_\+y c\+\_\+y$\vert$ $\vert$0 0 \+\_\+1$\vert$ .

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed. \\
\hline
{\em image\+Points} & Output array of image points, 2x\+N/\+Nx2 1-\/channel or 1x\+N/\+Nx1 2-\/channel, or {\ttfamily vector$<$\+Point2f$>$}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#projectpoints}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+project\+Points} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aebd8ac92e76f807fcf593fd780b79a65}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aebd8ac92e76f807fcf593fd780b79a65}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!rectify3\+Collinear@{rectify3\+Collinear}}
\index{rectify3\+Collinear@{rectify3\+Collinear}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{rectify3\+Collinear()}{rectify3Collinear()}}
{\footnotesize\ttfamily static float org.\+opencv.\+calib3d.\+Calib3d.\+rectify3\+Collinear (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix3,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs3,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{imgpt1,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{imgpt3,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R12,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{T12,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R13,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{T13,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R3,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{P1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{P2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{P3,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{Q,  }\item[{double}]{alpha,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{new\+Img\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{roi1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{roi2,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ae31a018191ec424a007e73caf5b35e6b}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ae31a018191ec424a007e73caf5b35e6b}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!reproject\+Image\+To3D@{reproject\+Image\+To3D}}
\index{reproject\+Image\+To3D@{reproject\+Image\+To3D}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{reproject\+Image\+To3\+D()}{reprojectImageTo3D()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+reproject\+Image\+To3D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{disparity,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{\+\_\+3d\+Image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{Q,  }\item[{boolean}]{handle\+Missing\+Values,  }\item[{int}]{ddepth }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Reprojects a disparity image to 3D space.

The function transforms a single-\/channel disparity map to a 3-\/channel image representing a 3D surface. That is, for each pixel {\ttfamily (x,y)} andthe corresponding disparity {\ttfamily d=disparity(x,y)}, it computes\+:

{\itshape \mbox{[}X Y Z W\mbox{]}$^\wedge$T = Q $\ast$\mbox{[}x y disparity(x,y) 1\mbox{]}$^\wedge$T \+\_\+3d\+Image(x,y) = (X/W, Y/W, Z/W) }

The matrix {\ttfamily Q} can be an arbitrary {\itshape 4 x 4} matrix (for example, the one computed by \char`\"{}stereo\+Rectify\char`\"{}). To reproject a sparse set of points \{(x,y,d),...\} to 3D space, use \char`\"{}perspective\+Transform\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em disparity} & Input single-\/channel 8-\/bit unsigned, 16-\/bit signed, 32-\/bit signed or 32-\/bit floating-\/point disparity image. \\
\hline
{\em \+\_\+3d\+Image} & Output 3-\/channel floating-\/point image of the same size as {\ttfamily disparity}. Each element of {\ttfamily \+\_\+3d\+Image(x,y)} contains 3D coordinates of the point {\ttfamily (x,y)} computed from the disparity map. \\
\hline
{\em Q} & {\itshape 4 x 4} perspective transformation matrix that can be obtained with \char`\"{}stereo\+Rectify\char`\"{}. \\
\hline
{\em handle\+Missing\+Values} & Indicates, whether the function should handle missing values (i.\+e. points where the disparity was not computed). If {\ttfamily handle\+Missing\+Values=true}, then pixels with the minimal disparity that corresponds to the outliers (see \+:ocv\+:funcx\+:\char`\"{}\+Stereo\+B\+M.\+operator()\char`\"{}) are transformed to 3D points with a very large Z value (currently set to 10000). \\
\hline
{\em ddepth} & The optional output array depth. If it is {\ttfamily -\/1}, the output image will have {\ttfamily C\+V\+\_\+32F} depth. {\ttfamily ddepth} can also be set to {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32S} or {\ttfamily C\+V\+\_\+32F}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+reproject\+Image\+To3D} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a50f6f6b67af40abd54cd9b8bebce4c34}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a50f6f6b67af40abd54cd9b8bebce4c34}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!reproject\+Image\+To3D@{reproject\+Image\+To3D}}
\index{reproject\+Image\+To3D@{reproject\+Image\+To3D}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{reproject\+Image\+To3\+D()}{reprojectImageTo3D()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+reproject\+Image\+To3D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{disparity,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{\+\_\+3d\+Image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{Q,  }\item[{boolean}]{handle\+Missing\+Values }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Reprojects a disparity image to 3D space.

The function transforms a single-\/channel disparity map to a 3-\/channel image representing a 3D surface. That is, for each pixel {\ttfamily (x,y)} andthe corresponding disparity {\ttfamily d=disparity(x,y)}, it computes\+:

{\itshape \mbox{[}X Y Z W\mbox{]}$^\wedge$T = Q $\ast$\mbox{[}x y disparity(x,y) 1\mbox{]}$^\wedge$T \+\_\+3d\+Image(x,y) = (X/W, Y/W, Z/W) }

The matrix {\ttfamily Q} can be an arbitrary {\itshape 4 x 4} matrix (for example, the one computed by \char`\"{}stereo\+Rectify\char`\"{}). To reproject a sparse set of points \{(x,y,d),...\} to 3D space, use \char`\"{}perspective\+Transform\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em disparity} & Input single-\/channel 8-\/bit unsigned, 16-\/bit signed, 32-\/bit signed or 32-\/bit floating-\/point disparity image. \\
\hline
{\em \+\_\+3d\+Image} & Output 3-\/channel floating-\/point image of the same size as {\ttfamily disparity}. Each element of {\ttfamily \+\_\+3d\+Image(x,y)} contains 3D coordinates of the point {\ttfamily (x,y)} computed from the disparity map. \\
\hline
{\em Q} & {\itshape 4 x 4} perspective transformation matrix that can be obtained with \char`\"{}stereo\+Rectify\char`\"{}. \\
\hline
{\em handle\+Missing\+Values} & Indicates, whether the function should handle missing values (i.\+e. points where the disparity was not computed). If {\ttfamily handle\+Missing\+Values=true}, then pixels with the minimal disparity that corresponds to the outliers (see \+:ocv\+:funcx\+:\char`\"{}\+Stereo\+B\+M.\+operator()\char`\"{}) are transformed to 3D points with a very large Z value (currently set to 10000).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+reproject\+Image\+To3D} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ab0607d0453e4adb44ff480027b3296b7}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ab0607d0453e4adb44ff480027b3296b7}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!reproject\+Image\+To3D@{reproject\+Image\+To3D}}
\index{reproject\+Image\+To3D@{reproject\+Image\+To3D}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{reproject\+Image\+To3\+D()}{reprojectImageTo3D()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+reproject\+Image\+To3D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{disparity,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{\+\_\+3d\+Image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{Q }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Reprojects a disparity image to 3D space.

The function transforms a single-\/channel disparity map to a 3-\/channel image representing a 3D surface. That is, for each pixel {\ttfamily (x,y)} andthe corresponding disparity {\ttfamily d=disparity(x,y)}, it computes\+:

{\itshape \mbox{[}X Y Z W\mbox{]}$^\wedge$T = Q $\ast$\mbox{[}x y disparity(x,y) 1\mbox{]}$^\wedge$T \+\_\+3d\+Image(x,y) = (X/W, Y/W, Z/W) }

The matrix {\ttfamily Q} can be an arbitrary {\itshape 4 x 4} matrix (for example, the one computed by \char`\"{}stereo\+Rectify\char`\"{}). To reproject a sparse set of points \{(x,y,d),...\} to 3D space, use \char`\"{}perspective\+Transform\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em disparity} & Input single-\/channel 8-\/bit unsigned, 16-\/bit signed, 32-\/bit signed or 32-\/bit floating-\/point disparity image. \\
\hline
{\em \+\_\+3d\+Image} & Output 3-\/channel floating-\/point image of the same size as {\ttfamily disparity}. Each element of {\ttfamily \+\_\+3d\+Image(x,y)} contains 3D coordinates of the point {\ttfamily (x,y)} computed from the disparity map. \\
\hline
{\em Q} & {\itshape 4 x 4} perspective transformation matrix that can be obtained with \char`\"{}stereo\+Rectify\char`\"{}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#reprojectimageto3d}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+reproject\+Image\+To3D} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a922c174e8c7e4564831abdb4ba8ba2dc}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a922c174e8c7e4564831abdb4ba8ba2dc}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!Rodrigues@{Rodrigues}}
\index{Rodrigues@{Rodrigues}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{Rodrigues()}{Rodrigues()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+Rodrigues (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{jacobian }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Converts a rotation matrix to a rotation vector or vice versa.

{\itshape theta $<$-\/ norm(r) r $<$-\/ r/ theta \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} = cos(theta) I + (1-\/ cos(theta)) r r$^\wedge$T + sin(theta) $\vert$0 -\/r\+\_\+z r\+\_\+y$\vert$ $\vert$r\+\_\+z 0 -\/r\+\_\+x$\vert$ $\vert$-\/r\+\_\+y r\+\_\+x 0$\vert$ }

Inverse transformation can be also done easily, since

{\itshape sin(theta) $\vert$0 -\/r\+\_\+z r\+\_\+y$\vert$ $\vert$r\+\_\+z 0 -\/r\+\_\+x$\vert$ $\vert$-\/r\+\_\+y r\+\_\+x 0$\vert$ = (\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} -\/ R$^\wedge$T)/2}

A rotation vector is a convenient and most compact representation of a rotation matrix (since any rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry optimization procedures like \char`\"{}calibrate\+Camera\char`\"{}, \char`\"{}stereo\+Calibrate\char`\"{}, or \char`\"{}solve\+Pn\+P\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em src} & Input rotation vector (3x1 or 1x3) or rotation matrix (3x3). \\
\hline
{\em dst} & Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively. \\
\hline
{\em jacobian} & Optional output Jacobian matrix, 3x9 or 9x3, which is a matrix of partial derivatives of the output array components with respect to the input array components.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#rodrigues}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+Rodrigues} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5b382445df7c31a34f6fabe2c7a404b3}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5b382445df7c31a34f6fabe2c7a404b3}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!Rodrigues@{Rodrigues}}
\index{Rodrigues@{Rodrigues}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{Rodrigues()}{Rodrigues()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+Rodrigues (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Converts a rotation matrix to a rotation vector or vice versa.

{\itshape theta $<$-\/ norm(r) r $<$-\/ r/ theta \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} = cos(theta) I + (1-\/ cos(theta)) r r$^\wedge$T + sin(theta) $\vert$0 -\/r\+\_\+z r\+\_\+y$\vert$ $\vert$r\+\_\+z 0 -\/r\+\_\+x$\vert$ $\vert$-\/r\+\_\+y r\+\_\+x 0$\vert$ }

Inverse transformation can be also done easily, since

{\itshape sin(theta) $\vert$0 -\/r\+\_\+z r\+\_\+y$\vert$ $\vert$r\+\_\+z 0 -\/r\+\_\+x$\vert$ $\vert$-\/r\+\_\+y r\+\_\+x 0$\vert$ = (\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} -\/ R$^\wedge$T)/2}

A rotation vector is a convenient and most compact representation of a rotation matrix (since any rotation matrix has just 3 degrees of freedom). The representation is used in the global 3D geometry optimization procedures like \char`\"{}calibrate\+Camera\char`\"{}, \char`\"{}stereo\+Calibrate\char`\"{}, or \char`\"{}solve\+Pn\+P\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em src} & Input rotation vector (3x1 or 1x3) or rotation matrix (3x3). \\
\hline
{\em dst} & Output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#rodrigues}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+Rodrigues} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a25a9a7350da241cac233a16419ad3ebd}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a25a9a7350da241cac233a16419ad3ebd}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!R\+Q\+Decomp3x3@{R\+Q\+Decomp3x3}}
\index{R\+Q\+Decomp3x3@{R\+Q\+Decomp3x3}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{R\+Q\+Decomp3x3()}{RQDecomp3x3()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static double \mbox{[}$\,$\mbox{]} org.\+opencv.\+calib3d.\+Calib3d.\+R\+Q\+Decomp3x3 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mtxR,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mtxQ,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{Qx,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{Qy,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{Qz }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes an RQ decomposition of 3x3 matrices.

The function computes a RQ decomposition using the given rotations. This function is used in \char`\"{}decompose\+Projection\+Matrix\char`\"{} to decompose the left 3x3 submatrix of a projection matrix into a camera and a rotation matrix.

It optionally returns three rotation matrices, one for each axis, and the three Euler angles in degrees (as the return value) that could be used in Open\+GL. Note, there is always more than one sequence of rotations about the three principle axes that results in the same orientation of an object, eg. see \mbox{[}Slabaugh\mbox{]}. Returned tree rotation matrices and corresponding three Euler angules are only one of the possible solutions.


\begin{DoxyParams}{Parameters}
{\em src} & 3x3 input matrix. \\
\hline
{\em mtxR} & Output 3x3 upper-\/triangular matrix. \\
\hline
{\em mtxQ} & Output 3x3 orthogonal matrix. \\
\hline
{\em Qx} & Optional output 3x3 rotation matrix around x-\/axis. \\
\hline
{\em Qy} & Optional output 3x3 rotation matrix around y-\/axis. \\
\hline
{\em Qz} & Optional output 3x3 rotation matrix around z-\/axis.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#rqdecomp3x3}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+R\+Q\+Decomp3x3} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a954aae0c68e0109ce75ebe6bb897eb19}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a954aae0c68e0109ce75ebe6bb897eb19}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!R\+Q\+Decomp3x3@{R\+Q\+Decomp3x3}}
\index{R\+Q\+Decomp3x3@{R\+Q\+Decomp3x3}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{R\+Q\+Decomp3x3()}{RQDecomp3x3()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static double \mbox{[}$\,$\mbox{]} org.\+opencv.\+calib3d.\+Calib3d.\+R\+Q\+Decomp3x3 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mtxR,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mtxQ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes an RQ decomposition of 3x3 matrices.

The function computes a RQ decomposition using the given rotations. This function is used in \char`\"{}decompose\+Projection\+Matrix\char`\"{} to decompose the left 3x3 submatrix of a projection matrix into a camera and a rotation matrix.

It optionally returns three rotation matrices, one for each axis, and the three Euler angles in degrees (as the return value) that could be used in Open\+GL. Note, there is always more than one sequence of rotations about the three principle axes that results in the same orientation of an object, eg. see \mbox{[}Slabaugh\mbox{]}. Returned tree rotation matrices and corresponding three Euler angules are only one of the possible solutions.


\begin{DoxyParams}{Parameters}
{\em src} & 3x3 input matrix. \\
\hline
{\em mtxR} & Output 3x3 upper-\/triangular matrix. \\
\hline
{\em mtxQ} & Output 3x3 orthogonal matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#rqdecomp3x3}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+R\+Q\+Decomp3x3} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad53b5772231896ec5baf3bde5e9ba319}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad53b5772231896ec5baf3bde5e9ba319}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!solve\+PnP@{solve\+PnP}}
\index{solve\+PnP@{solve\+PnP}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{solve\+Pn\+P()}{solvePnP()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+calib3d.\+Calib3d.\+solve\+PnP (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}}}]{object\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{image\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec,  }\item[{boolean}]{use\+Extrinsic\+Guess,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds an object pose from 3\+D-\/2D point correspondences.

The function estimates the object pose given a set of object points, their corresponding image projections, as well as the camera matrix and the distortion coefficients.

Note\+:


\begin{DoxyItemize}
\item An example of how to use solve\+P\+NP for planar augmented reality can be found at opencv\+\_\+source\+\_\+code/samples/python2/plane\+\_\+ar.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em object\+Points} & Array of object points in the object coordinate space, 3x\+N/\+Nx3 1-\/channel or 1x\+N/\+Nx1 3-\/channel, where N is the number of points. {\ttfamily vector$<$\+Point3f$>$} can be also passed here. \\
\hline
{\em image\+Points} & Array of corresponding image points, 2x\+N/\+Nx2 1-\/channel or 1x\+N/\+Nx1 2-\/channel, where N is the number of points. {\ttfamily vector$<$\+Point2f$>$} can be also passed here. \\
\hline
{\em camera\+Matrix} & Input camera matrix {\itshape A = }\\
\hline
\end{DoxyParams}
$\vert$fx 0 cx$\vert$ $\vert$0 fy cy$\vert$ $\vert$0 0 1$\vert$ .

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed. \\
\hline
{\em rvec} & Output rotation vector (see \char`\"{}\+Rodrigues\char`\"{}) that, together with {\ttfamily tvec}, brings points from the model coordinate system to the camera coordinate system. \\
\hline
{\em tvec} & Output translation vector. \\
\hline
{\em use\+Extrinsic\+Guess} & If true (1), the function uses the provided {\ttfamily rvec} and {\ttfamily tvec} values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them. \\
\hline
{\em flags} & Method for solving a PnP problem\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+I\+T\+E\+R\+A\+T\+I\+VE Iterative method is based on Levenberg-\/\+Marquardt optimization. In this case the function finds such a pose that minimizes reprojection error, that is the sum of squared distances between the observed projections {\ttfamily image\+Points} and the projected (using \char`\"{}project\+Points\char`\"{}) {\ttfamily object\+Points}. 
\item C\+V\+\_\+\+P3P Method is based on the paper of X.\+S. Gao, X.-\/R. Hou, J. Tang, H.-\/F. Chang \char`\"{}\+Complete Solution Classification for the Perspective-\/\+Three-\/\+Point
\+Problem\char`\"{}. In this case the function requires exactly four object and image points. 
\item C\+V\+\_\+\+E\+P\+NP Method has been introduced by F.\+Moreno-\/\+Noguer, V.\+Lepetit and P.\+Fua in the paper \char`\"{}\+E\+Pn\+P\+: Efficient Perspective-\/n-\/\+Point Camera Pose
\+Estimation\char`\"{}. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#solvepnp}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+solve\+PnP} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a763c6212499a27e160dfbc34439cfce5}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a763c6212499a27e160dfbc34439cfce5}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!solve\+PnP@{solve\+PnP}}
\index{solve\+PnP@{solve\+PnP}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{solve\+Pn\+P()}{solvePnP()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+calib3d.\+Calib3d.\+solve\+PnP (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}}}]{object\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{image\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds an object pose from 3\+D-\/2D point correspondences.

The function estimates the object pose given a set of object points, their corresponding image projections, as well as the camera matrix and the distortion coefficients.

Note\+:


\begin{DoxyItemize}
\item An example of how to use solve\+P\+NP for planar augmented reality can be found at opencv\+\_\+source\+\_\+code/samples/python2/plane\+\_\+ar.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em object\+Points} & Array of object points in the object coordinate space, 3x\+N/\+Nx3 1-\/channel or 1x\+N/\+Nx1 3-\/channel, where N is the number of points. {\ttfamily vector$<$\+Point3f$>$} can be also passed here. \\
\hline
{\em image\+Points} & Array of corresponding image points, 2x\+N/\+Nx2 1-\/channel or 1x\+N/\+Nx1 2-\/channel, where N is the number of points. {\ttfamily vector$<$\+Point2f$>$} can be also passed here. \\
\hline
{\em camera\+Matrix} & Input camera matrix {\itshape A = }\\
\hline
\end{DoxyParams}
$\vert$fx 0 cx$\vert$ $\vert$0 fy cy$\vert$ $\vert$0 0 1$\vert$ .

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed. \\
\hline
{\em rvec} & Output rotation vector (see \char`\"{}\+Rodrigues\char`\"{}) that, together with {\ttfamily tvec}, brings points from the model coordinate system to the camera coordinate system. \\
\hline
{\em tvec} & Output translation vector.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#solvepnp}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+solve\+PnP} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a32d3d3e19cf81dddf71cd8527fb806e5}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a32d3d3e19cf81dddf71cd8527fb806e5}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!solve\+Pn\+P\+Ransac@{solve\+Pn\+P\+Ransac}}
\index{solve\+Pn\+P\+Ransac@{solve\+Pn\+P\+Ransac}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{solve\+Pn\+P\+Ransac()}{solvePnPRansac()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+solve\+Pn\+P\+Ransac (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}}}]{object\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{image\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec,  }\item[{boolean}]{use\+Extrinsic\+Guess,  }\item[{int}]{iterations\+Count,  }\item[{float}]{reprojection\+Error,  }\item[{int}]{min\+Inliers\+Count,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{inliers,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds an object pose from 3\+D-\/2D point correspondences using the R\+A\+N\+S\+AC scheme.

The function estimates an object pose given a set of object points, their corresponding image projections, as well as the camera matrix and the distortion coefficients. This function finds such a pose that minimizes reprojection error, that is, the sum of squared distances between the observed projections {\ttfamily image\+Points} and the projected (using \char`\"{}project\+Points\char`\"{}) {\ttfamily object\+Points}. The use of R\+A\+N\+S\+AC makes the function resistant to outliers. The function is parallelized with the T\+BB library.


\begin{DoxyParams}{Parameters}
{\em object\+Points} & Array of object points in the object coordinate space, 3x\+N/\+Nx3 1-\/channel or 1x\+N/\+Nx1 3-\/channel, where N is the number of points. {\ttfamily vector$<$\+Point3f$>$} can be also passed here. \\
\hline
{\em image\+Points} & Array of corresponding image points, 2x\+N/\+Nx2 1-\/channel or 1x\+N/\+Nx1 2-\/channel, where N is the number of points. {\ttfamily vector$<$\+Point2f$>$} can be also passed here. \\
\hline
{\em camera\+Matrix} & Input camera matrix {\itshape A = }\\
\hline
\end{DoxyParams}
$\vert$fx 0 cx$\vert$ $\vert$0 fy cy$\vert$ $\vert$0 0 1$\vert$ .

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed. \\
\hline
{\em rvec} & Output rotation vector (see \char`\"{}\+Rodrigues\char`\"{}) that, together with {\ttfamily tvec}, brings points from the model coordinate system to the camera coordinate system. \\
\hline
{\em tvec} & Output translation vector. \\
\hline
{\em use\+Extrinsic\+Guess} & If true (1), the function uses the provided {\ttfamily rvec} and {\ttfamily tvec} values as initial approximations of the rotation and translation vectors, respectively, and further optimizes them. \\
\hline
{\em iterations\+Count} & Number of iterations. \\
\hline
{\em reprojection\+Error} & Inlier threshold value used by the R\+A\+N\+S\+AC procedure. The parameter value is the maximum allowed distance between the observed and computed point projections to consider it an inlier. \\
\hline
{\em min\+Inliers\+Count} & Number of inliers. If the algorithm at some stage finds more inliers than {\ttfamily min\+Inliers\+Count}, it finishes. \\
\hline
{\em inliers} & Output vector that contains indices of inliers in {\ttfamily object\+Points} and {\ttfamily image\+Points}. \\
\hline
{\em flags} & Method for solving a PnP problem (see \char`\"{}solve\+Pn\+P\char`\"{}).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#solvepnpransac}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+solve\+Pn\+P\+Ransac} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad131ba9179addf7f44158cbc41e98a63}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ad131ba9179addf7f44158cbc41e98a63}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!solve\+Pn\+P\+Ransac@{solve\+Pn\+P\+Ransac}}
\index{solve\+Pn\+P\+Ransac@{solve\+Pn\+P\+Ransac}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{solve\+Pn\+P\+Ransac()}{solvePnPRansac()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+solve\+Pn\+P\+Ransac (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point3f}{Mat\+Of\+Point3f}}}]{object\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{image\+Points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rvec,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tvec }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds an object pose from 3\+D-\/2D point correspondences using the R\+A\+N\+S\+AC scheme.

The function estimates an object pose given a set of object points, their corresponding image projections, as well as the camera matrix and the distortion coefficients. This function finds such a pose that minimizes reprojection error, that is, the sum of squared distances between the observed projections {\ttfamily image\+Points} and the projected (using \char`\"{}project\+Points\char`\"{}) {\ttfamily object\+Points}. The use of R\+A\+N\+S\+AC makes the function resistant to outliers. The function is parallelized with the T\+BB library.


\begin{DoxyParams}{Parameters}
{\em object\+Points} & Array of object points in the object coordinate space, 3x\+N/\+Nx3 1-\/channel or 1x\+N/\+Nx1 3-\/channel, where N is the number of points. {\ttfamily vector$<$\+Point3f$>$} can be also passed here. \\
\hline
{\em image\+Points} & Array of corresponding image points, 2x\+N/\+Nx2 1-\/channel or 1x\+N/\+Nx1 2-\/channel, where N is the number of points. {\ttfamily vector$<$\+Point2f$>$} can be also passed here. \\
\hline
{\em camera\+Matrix} & Input camera matrix {\itshape A = }\\
\hline
\end{DoxyParams}
$\vert$fx 0 cx$\vert$ $\vert$0 fy cy$\vert$ $\vert$0 0 1$\vert$ .

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed. \\
\hline
{\em rvec} & Output rotation vector (see \char`\"{}\+Rodrigues\char`\"{}) that, together with {\ttfamily tvec}, brings points from the model coordinate system to the camera coordinate system. \\
\hline
{\em tvec} & Output translation vector.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#solvepnpransac}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+solve\+Pn\+P\+Ransac} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_af2197ce033076b13fef5ae2fc045aa62}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_af2197ce033076b13fef5ae2fc045aa62}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!stereo\+Calibrate@{stereo\+Calibrate}}
\index{stereo\+Calibrate@{stereo\+Calibrate}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{stereo\+Calibrate()}{stereoCalibrate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static double org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Calibrate (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{object\+Points,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{image\+Points1,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{image\+Points2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{T,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{E,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{F,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}}}]{criteria,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calibrates the stereo camera.

The function estimates transformation between two cameras making a stereo pair. If you have a stereo camera where the relative position and orientation of two cameras is fixed, and if you computed poses of an object relative to the first camera and to the second camera, (R1, T1) and (R2, T2), respectively (this can be done with \char`\"{}solve\+Pn\+P\char`\"{}), then those poses definitely relate to each other. This means that, given ({\itshape R\+\_\+1},{\itshape T\+\_\+1}), it should be possible to compute ({\itshape R\+\_\+2},{\itshape T\+\_\+2}). You only need to know the position and orientation of the second camera relative to the first camera. This is what the described function does. It computes ({\itshape \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}},{\itshape T}) so that\+:

{\itshape R\+\_\+2=R$\ast$\+R\+\_\+1\&lt\+BR\&gt\+T\+\_\+2=R$\ast$\+T\+\_\+1 + T,}

Optionally, it computes the essential matrix E\+:

{\itshape E= $\vert$0 -\/\+T\+\_\+2 T\+\_\+1$\vert$ $\vert$\+T\+\_\+2 0 -\/\+T\+\_\+0$\vert$ $\vert$-\/\+T\+\_\+1 T\+\_\+0 0$\vert$}

{\itshape  
\begin{DoxyItemize}
\item \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} 
\end{DoxyItemize}}

{\itshape }

{\itshape where {\itshape T\+\_\+i} are components of the translation vector {\itshape T} \+: {\itshape T=\mbox{[}T\+\_\+0, T\+\_\+1, T\+\_\+2\mbox{]}$^\wedge$T}. And the function can also compute the fundamental matrix F\+:}

{\itshape }

{\itshape }

{\itshape {\itshape F = camera\+Matrix2$^\wedge$(-\/T) E camera\+Matrix1$^\wedge$(-\/1)}}

{\itshape }

{\itshape }

{\itshape Besides the stereo-\/related information, the function can also perform a full calibration of each of two cameras. However, due to the high dimensionality of the parameter space and noise in the input data, the function can diverge from the correct solution. If the intrinsic parameters can be estimated with high accuracy for each of the cameras individually (for example, using \char`\"{}calibrate\+Camera\char`\"{}), you are recommended to do so and then pass {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+I\+N\+T\+R\+I\+N\+S\+IC} flag to the function along with the computed intrinsic parameters. Otherwise, if all the parameters are estimated at once, it makes sense to restrict some parameters, for example, pass {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+S\+A\+M\+E\+\_\+\+F\+O\+C\+A\+L\+\_\+\+L\+E\+N\+G\+TH} and {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+Z\+E\+R\+O\+\_\+\+T\+A\+N\+G\+E\+N\+T\+\_\+\+D\+I\+ST} flags, which is usually a reasonable assumption.}

{\itshape }

{\itshape }

{\itshape Similarly to \char`\"{}calibrate\+Camera\char`\"{}, the function minimizes the total re-\/projection error for all the points in all the available views from both cameras. The function returns the final value of the re-\/projection error.}

{\itshape }

{\itshape 
\begin{DoxyParams}{Parameters}
{\em object\+Points} & Vector of vectors of the calibration pattern points. \\
\hline
{\em image\+Points1} & Vector of vectors of the projections of the calibration pattern points, observed by the first camera. \\
\hline
{\em image\+Points2} & Vector of vectors of the projections of the calibration pattern points, observed by the second camera. \\
\hline
{\em camera\+Matrix1} & Input/output first camera matrix\+: {\itshape  }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x$^\wedge$j 0 c\+\_\+x$^\wedge$j$\vert$ $\vert$0 f\+\_\+y$^\wedge$j c\+\_\+y$^\wedge$j$\vert$ $\vert$0 0 1$\vert$ }, {\itshape j = 0, 1}. If any of {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS}, {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+A\+S\+P\+E\+C\+T\+\_\+\+R\+A\+T\+IO}, {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+I\+N\+T\+R\+I\+N\+S\+IC}, or {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+F\+O\+C\+A\+L\+\_\+\+L\+E\+N\+G\+TH} are specified, some or all of the matrix components must be initialized. See the flags description for details.

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs1} & Input/output vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. The output vector length depends on the flags. \\
\hline
{\em camera\+Matrix2} & Input/output second camera matrix. The parameter is similar to {\ttfamily camera\+Matrix1}. \\
\hline
{\em dist\+Coeffs2} & Input/output lens distortion coefficients for the second camera. The parameter is similar to {\ttfamily dist\+Coeffs1}. \\
\hline
{\em image\+Size} & Size of the image used only to initialize intrinsic camera matrix. \\
\hline
{\em \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}} & Output rotation matrix between the 1st and the 2nd camera coordinate systems. \\
\hline
{\em T} & Output translation vector between the coordinate systems of the cameras. \\
\hline
{\em E} & Output essential matrix. \\
\hline
{\em F} & Output fundamental matrix. \\
\hline
{\em criteria} & a criteria \\
\hline
{\em flags} & Different flags that may be zero or a combination of the following values\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+I\+N\+T\+R\+I\+N\+S\+IC Fix {\ttfamily camera\+Matrix?} and {\ttfamily dist\+Coeffs?} so that only {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, T, E}, and {\ttfamily F} matrices are estimated. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS Optimize some or all of the intrinsic parameters according to the specified flags. Initial values are provided by the user. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+P\+R\+I\+N\+C\+I\+P\+A\+L\+\_\+\+P\+O\+I\+NT Fix the principal points during the optimization. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+F\+O\+C\+A\+L\+\_\+\+L\+E\+N\+G\+TH Fix {\itshape f$^\wedge$j\+\_\+x} and {\itshape f$^\wedge$j\+\_\+y}. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+A\+S\+P\+E\+C\+T\+\_\+\+R\+A\+T\+IO Optimize {\itshape f$^\wedge$j\+\_\+y}. Fix the ratio {\itshape f$^\wedge$j\+\_\+x/f$^\wedge$j\+\_\+y}. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+S\+A\+M\+E\+\_\+\+F\+O\+C\+A\+L\+\_\+\+L\+E\+N\+G\+TH Enforce {\itshape f$^\wedge$0\+\_\+x=f$^\wedge$1\+\_\+x} and {\itshape f$^\wedge$0\+\_\+y=f$^\wedge$1\+\_\+y}. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+Z\+E\+R\+O\+\_\+\+T\+A\+N\+G\+E\+N\+T\+\_\+\+D\+I\+ST Set tangential distortion coefficients for each camera to zeros and fix there. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+K1,...,C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+K6 Do not change the corresponding radial distortion coefficient during the optimization. If {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS} is set, the coefficient from the supplied {\ttfamily dist\+Coeffs} matrix is used. Otherwise, it is set to 0. 
\item C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+R\+A\+T\+I\+O\+N\+A\+L\+\_\+\+M\+O\+D\+EL Enable coefficients k4, k5, and k6. To provide the backward compatibility, this extra flag should be explicitly specified to make the calibration function use the rational model and return 8 coefficients. If the flag is not set, the function computes and returns only 5 distortion coefficients. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereocalibrate}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Calibrate} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a20929337f50b54083cde223c9fc5f9f7}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a20929337f50b54083cde223c9fc5f9f7}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!stereo\+Calibrate@{stereo\+Calibrate}}
\index{stereo\+Calibrate@{stereo\+Calibrate}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{stereo\+Calibrate()}{stereoCalibrate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static double org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Calibrate (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{object\+Points,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{image\+Points1,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{image\+Points2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{T,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{E,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{F }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calibrates the stereo camera.

The function estimates transformation between two cameras making a stereo pair. If you have a stereo camera where the relative position and orientation of two cameras is fixed, and if you computed poses of an object relative to the first camera and to the second camera, (R1, T1) and (R2, T2), respectively (this can be done with \char`\"{}solve\+Pn\+P\char`\"{}), then those poses definitely relate to each other. This means that, given ({\itshape R\+\_\+1},{\itshape T\+\_\+1}), it should be possible to compute ({\itshape R\+\_\+2},{\itshape T\+\_\+2}). You only need to know the position and orientation of the second camera relative to the first camera. This is what the described function does. It computes ({\itshape \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}},{\itshape T}) so that\+:

{\itshape R\+\_\+2=R$\ast$\+R\+\_\+1\&lt\+BR\&gt\+T\+\_\+2=R$\ast$\+T\+\_\+1 + T,}

Optionally, it computes the essential matrix E\+:

{\itshape E= $\vert$0 -\/\+T\+\_\+2 T\+\_\+1$\vert$ $\vert$\+T\+\_\+2 0 -\/\+T\+\_\+0$\vert$ $\vert$-\/\+T\+\_\+1 T\+\_\+0 0$\vert$}

{\itshape  
\begin{DoxyItemize}
\item \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} 
\end{DoxyItemize}}

{\itshape }

{\itshape where {\itshape T\+\_\+i} are components of the translation vector {\itshape T} \+: {\itshape T=\mbox{[}T\+\_\+0, T\+\_\+1, T\+\_\+2\mbox{]}$^\wedge$T}. And the function can also compute the fundamental matrix F\+:}

{\itshape }

{\itshape }

{\itshape {\itshape F = camera\+Matrix2$^\wedge$(-\/T) E camera\+Matrix1$^\wedge$(-\/1)}}

{\itshape }

{\itshape }

{\itshape Besides the stereo-\/related information, the function can also perform a full calibration of each of two cameras. However, due to the high dimensionality of the parameter space and noise in the input data, the function can diverge from the correct solution. If the intrinsic parameters can be estimated with high accuracy for each of the cameras individually (for example, using \char`\"{}calibrate\+Camera\char`\"{}), you are recommended to do so and then pass {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+I\+N\+T\+R\+I\+N\+S\+IC} flag to the function along with the computed intrinsic parameters. Otherwise, if all the parameters are estimated at once, it makes sense to restrict some parameters, for example, pass {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+S\+A\+M\+E\+\_\+\+F\+O\+C\+A\+L\+\_\+\+L\+E\+N\+G\+TH} and {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+Z\+E\+R\+O\+\_\+\+T\+A\+N\+G\+E\+N\+T\+\_\+\+D\+I\+ST} flags, which is usually a reasonable assumption.}

{\itshape }

{\itshape }

{\itshape Similarly to \char`\"{}calibrate\+Camera\char`\"{}, the function minimizes the total re-\/projection error for all the points in all the available views from both cameras. The function returns the final value of the re-\/projection error.}

{\itshape }

{\itshape 
\begin{DoxyParams}{Parameters}
{\em object\+Points} & Vector of vectors of the calibration pattern points. \\
\hline
{\em image\+Points1} & Vector of vectors of the projections of the calibration pattern points, observed by the first camera. \\
\hline
{\em image\+Points2} & Vector of vectors of the projections of the calibration pattern points, observed by the second camera. \\
\hline
{\em camera\+Matrix1} & Input/output first camera matrix\+: {\itshape  }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x$^\wedge$j 0 c\+\_\+x$^\wedge$j$\vert$ $\vert$0 f\+\_\+y$^\wedge$j c\+\_\+y$^\wedge$j$\vert$ $\vert$0 0 1$\vert$ }, {\itshape j = 0, 1}. If any of {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+U\+S\+E\+\_\+\+I\+N\+T\+R\+I\+N\+S\+I\+C\+\_\+\+G\+U\+E\+SS}, {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+A\+S\+P\+E\+C\+T\+\_\+\+R\+A\+T\+IO}, {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+I\+N\+T\+R\+I\+N\+S\+IC}, or {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+F\+I\+X\+\_\+\+F\+O\+C\+A\+L\+\_\+\+L\+E\+N\+G\+TH} are specified, some or all of the matrix components must be initialized. See the flags description for details.

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs1} & Input/output vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. The output vector length depends on the flags. \\
\hline
{\em camera\+Matrix2} & Input/output second camera matrix. The parameter is similar to {\ttfamily camera\+Matrix1}. \\
\hline
{\em dist\+Coeffs2} & Input/output lens distortion coefficients for the second camera. The parameter is similar to {\ttfamily dist\+Coeffs1}. \\
\hline
{\em image\+Size} & Size of the image used only to initialize intrinsic camera matrix. \\
\hline
{\em \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}} & Output rotation matrix between the 1st and the 2nd camera coordinate systems. \\
\hline
{\em T} & Output translation vector between the coordinate systems of the cameras. \\
\hline
{\em E} & Output essential matrix. \\
\hline
{\em F} & Output fundamental matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereocalibrate}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Calibrate} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaa152754c3a955ee79761a5e69f0408f}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aaa152754c3a955ee79761a5e69f0408f}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!stereo\+Rectify@{stereo\+Rectify}}
\index{stereo\+Rectify@{stereo\+Rectify}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{stereo\+Rectify()}{stereoRectify()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Rectify (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{T,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{P1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{P2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{Q,  }\item[{int}]{flags,  }\item[{double}]{alpha,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{new\+Image\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{valid\+Pix\+R\+O\+I1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{valid\+Pix\+R\+O\+I2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes rectification transforms for each head of a calibrated stereo camera.

The function computes the rotation matrices for each camera that (virtually) make both camera image planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies the dense stereo correspondence problem. The function takes the matrices computed by \char`\"{}stereo\+Calibrate\char`\"{} as input. As output, it provides two rotation matrices and also two projection matrices in the new coordinates. The function distinguishes the following two cases\+:


\begin{DoxyItemize}
\item Horizontal stereo\+: the first and the second camera views are shifted relative to each other mainly along the x axis (with possible small vertical shift). In the rectified images, the corresponding epipolar lines in the left and right cameras are horizontal and have the same y-\/coordinate. P1 and P2 look like\+: 
\end{DoxyItemize}

{\itshape P1 = f 0 cx\+\_\+1 0 0 f cy 0 0 0 1 0 }

{\itshape P2 = f 0 cx\+\_\+2 T\+\_\+x$\ast$f 0 f cy 0 0 0 1 0,}

where {\itshape T\+\_\+x} is a horizontal shift between the cameras and {\itshape cx\+\_\+1=cx\+\_\+2} if {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+Z\+E\+R\+O\+\_\+\+D\+I\+S\+P\+A\+R\+I\+TY} is set.


\begin{DoxyItemize}
\item Vertical stereo\+: the first and the second camera views are shifted relative to each other mainly in vertical direction (and probably a bit in the horizontal direction too). The epipolar lines in the rectified images are vertical and have the same x-\/coordinate. P1 and P2 look like\+: 
\end{DoxyItemize}

{\itshape P1 = f 0 cx 0 0 f cy\+\_\+1 0 0 0 1 0 }

{\itshape P2 = f 0 cx 0 0 f cy\+\_\+2 T\+\_\+y$\ast$f 0 0 1 0,}

where {\itshape T\+\_\+y} is a vertical shift between the cameras and {\itshape cy\+\_\+1=cy\+\_\+2} if {\ttfamily C\+A\+L\+I\+B\+\_\+\+Z\+E\+R\+O\+\_\+\+D\+I\+S\+P\+A\+R\+I\+TY} is set.

As you can see, the first three columns of {\ttfamily P1} and {\ttfamily P2} will effectively be the new \char`\"{}rectified\char`\"{} camera matrices. The matrices, together with {\ttfamily R1} and {\ttfamily R2}, can then be passed to \char`\"{}init\+Undistort\+Rectify\+Map\char`\"{} to initialize the rectification map for each camera.

See below the screenshot from the {\ttfamily stereo\+\_\+calib.\+cpp} sample. Some red horizontal lines pass through the corresponding image regions. This means that the images are well rectified, which is what most stereo correspondence algorithms rely on. The green rectangles are {\ttfamily roi1} and {\ttfamily roi2}. You see that their interiors are all valid pixels.


\begin{DoxyParams}{Parameters}
{\em camera\+Matrix1} & First camera matrix. \\
\hline
{\em dist\+Coeffs1} & First camera distortion parameters. \\
\hline
{\em camera\+Matrix2} & Second camera matrix. \\
\hline
{\em dist\+Coeffs2} & Second camera distortion parameters. \\
\hline
{\em image\+Size} & Size of the image used for stereo calibration. \\
\hline
{\em \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}} & Rotation matrix between the coordinate systems of the first and the second cameras. \\
\hline
{\em T} & Translation vector between coordinate systems of the cameras. \\
\hline
{\em R1} & Output 3x3 rectification transform (rotation matrix) for the first camera. \\
\hline
{\em R2} & Output 3x3 rectification transform (rotation matrix) for the second camera. \\
\hline
{\em P1} & Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera. \\
\hline
{\em P2} & Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera. \\
\hline
{\em Q} & Output {\itshape 4 x 4} disparity-\/to-\/depth mapping matrix (see \char`\"{}reproject\+Image\+To3\+D\char`\"{}). \\
\hline
{\em flags} & Operation flags that may be zero or {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+Z\+E\+R\+O\+\_\+\+D\+I\+S\+P\+A\+R\+I\+TY}. If the flag is set, the function makes the principal points of each camera have the same pixel coordinates in the rectified views. And if the flag is not set, the function may still shift the images in the horizontal or vertical direction (depending on the orientation of epipolar lines) to maximize the useful image area. \\
\hline
{\em alpha} & Free scaling parameter. If it is -\/1 or absent, the function performs the default scaling. Otherwise, the parameter should be between 0 and 1. {\ttfamily alpha=0} means that the rectified images are zoomed and shifted so that only valid pixels are visible (no black areas after rectification). {\ttfamily alpha=1} means that the rectified image is decimated and shifted so that all the pixels from the original images from the cameras are retained in the rectified images (no source image pixels are lost). Obviously, any intermediate value yields an intermediate result between those two extreme cases. \\
\hline
{\em new\+Image\+Size} & New image resolution after rectification. The same size should be passed to \char`\"{}init\+Undistort\+Rectify\+Map\char`\"{} (see the {\ttfamily stereo\+\_\+calib.\+cpp} sample in Open\+CV samples directory). When (0,0) is passed (default), it is set to the original {\ttfamily image\+Size}. Setting it to larger value can help you preserve details in the original image, especially when there is a big radial distortion. \\
\hline
{\em valid\+Pix\+R\+O\+I1} & Optional output rectangles inside the rectified images where all the pixels are valid. If {\ttfamily alpha=0}, the R\+O\+Is cover the whole images. Otherwise, they are likely to be smaller (see the picture below). \\
\hline
{\em valid\+Pix\+R\+O\+I2} & Optional output rectangles inside the rectified images where all the pixels are valid. If {\ttfamily alpha=0}, the R\+O\+Is cover the whole images. Otherwise, they are likely to be smaller (see the picture below).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereorectify}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Rectify} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a757aa08075484d502a276b3eab449e7e}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a757aa08075484d502a276b3eab449e7e}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!stereo\+Rectify@{stereo\+Rectify}}
\index{stereo\+Rectify@{stereo\+Rectify}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{stereo\+Rectify()}{stereoRectify()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Rectify (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{T,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{P1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{P2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{Q }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes rectification transforms for each head of a calibrated stereo camera.

The function computes the rotation matrices for each camera that (virtually) make both camera image planes the same plane. Consequently, this makes all the epipolar lines parallel and thus simplifies the dense stereo correspondence problem. The function takes the matrices computed by \char`\"{}stereo\+Calibrate\char`\"{} as input. As output, it provides two rotation matrices and also two projection matrices in the new coordinates. The function distinguishes the following two cases\+:


\begin{DoxyItemize}
\item Horizontal stereo\+: the first and the second camera views are shifted relative to each other mainly along the x axis (with possible small vertical shift). In the rectified images, the corresponding epipolar lines in the left and right cameras are horizontal and have the same y-\/coordinate. P1 and P2 look like\+: 
\end{DoxyItemize}

{\itshape P1 = f 0 cx\+\_\+1 0 0 f cy 0 0 0 1 0 }

{\itshape P2 = f 0 cx\+\_\+2 T\+\_\+x$\ast$f 0 f cy 0 0 0 1 0,}

where {\itshape T\+\_\+x} is a horizontal shift between the cameras and {\itshape cx\+\_\+1=cx\+\_\+2} if {\ttfamily C\+V\+\_\+\+C\+A\+L\+I\+B\+\_\+\+Z\+E\+R\+O\+\_\+\+D\+I\+S\+P\+A\+R\+I\+TY} is set.


\begin{DoxyItemize}
\item Vertical stereo\+: the first and the second camera views are shifted relative to each other mainly in vertical direction (and probably a bit in the horizontal direction too). The epipolar lines in the rectified images are vertical and have the same x-\/coordinate. P1 and P2 look like\+: 
\end{DoxyItemize}

{\itshape P1 = f 0 cx 0 0 f cy\+\_\+1 0 0 0 1 0 }

{\itshape P2 = f 0 cx 0 0 f cy\+\_\+2 T\+\_\+y$\ast$f 0 0 1 0,}

where {\itshape T\+\_\+y} is a vertical shift between the cameras and {\itshape cy\+\_\+1=cy\+\_\+2} if {\ttfamily C\+A\+L\+I\+B\+\_\+\+Z\+E\+R\+O\+\_\+\+D\+I\+S\+P\+A\+R\+I\+TY} is set.

As you can see, the first three columns of {\ttfamily P1} and {\ttfamily P2} will effectively be the new \char`\"{}rectified\char`\"{} camera matrices. The matrices, together with {\ttfamily R1} and {\ttfamily R2}, can then be passed to \char`\"{}init\+Undistort\+Rectify\+Map\char`\"{} to initialize the rectification map for each camera.

See below the screenshot from the {\ttfamily stereo\+\_\+calib.\+cpp} sample. Some red horizontal lines pass through the corresponding image regions. This means that the images are well rectified, which is what most stereo correspondence algorithms rely on. The green rectangles are {\ttfamily roi1} and {\ttfamily roi2}. You see that their interiors are all valid pixels.


\begin{DoxyParams}{Parameters}
{\em camera\+Matrix1} & First camera matrix. \\
\hline
{\em dist\+Coeffs1} & First camera distortion parameters. \\
\hline
{\em camera\+Matrix2} & Second camera matrix. \\
\hline
{\em dist\+Coeffs2} & Second camera distortion parameters. \\
\hline
{\em image\+Size} & Size of the image used for stereo calibration. \\
\hline
{\em \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}} & Rotation matrix between the coordinate systems of the first and the second cameras. \\
\hline
{\em T} & Translation vector between coordinate systems of the cameras. \\
\hline
{\em R1} & Output 3x3 rectification transform (rotation matrix) for the first camera. \\
\hline
{\em R2} & Output 3x3 rectification transform (rotation matrix) for the second camera. \\
\hline
{\em P1} & Output 3x4 projection matrix in the new (rectified) coordinate systems for the first camera. \\
\hline
{\em P2} & Output 3x4 projection matrix in the new (rectified) coordinate systems for the second camera. \\
\hline
{\em Q} & Output {\itshape 4 x 4} disparity-\/to-\/depth mapping matrix (see \char`\"{}reproject\+Image\+To3\+D\char`\"{}).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereorectify}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Rectify} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a02b105cf69f68dd4d9a2c1e76b4f8a3f}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a02b105cf69f68dd4d9a2c1e76b4f8a3f}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!stereo\+Rectify\+Uncalibrated@{stereo\+Rectify\+Uncalibrated}}
\index{stereo\+Rectify\+Uncalibrated@{stereo\+Rectify\+Uncalibrated}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{stereo\+Rectify\+Uncalibrated()}{stereoRectifyUncalibrated()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Rectify\+Uncalibrated (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{points1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{points2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{F,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{img\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{H1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{H2,  }\item[{double}]{threshold }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes a rectification transform for an uncalibrated stereo camera.

The function computes the rectification transformations without knowing intrinsic parameters of the cameras and their relative position in the space, which explains the suffix \char`\"{}uncalibrated\char`\"{}. Another related difference from \char`\"{}stereo\+Rectify\char`\"{} is that the function outputs not the rectification transformations in the object (3D) space, but the planar perspective transformations encoded by the homography matrices {\ttfamily H1} and {\ttfamily H2}. The function implements the algorithm \mbox{[}Hartley99\mbox{]}.

Note\+:

While the algorithm does not need to know the intrinsic parameters of the cameras, it heavily depends on the epipolar geometry. Therefore, if the camera lenses have a significant distortion, it would be better to correct it before computing the fundamental matrix and calling this function. For example, distortion coefficients can be estimated for each head of stereo camera separately by using \char`\"{}calibrate\+Camera\char`\"{}. Then, the images can be corrected using \char`\"{}undistort\char`\"{}, or just the point coordinates can be corrected with \char`\"{}undistort\+Points\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em points1} & Array of feature points in the first image. \\
\hline
{\em points2} & The corresponding points in the second image. The same formats as in \char`\"{}find\+Fundamental\+Mat\char`\"{} are supported. \\
\hline
{\em F} & Input fundamental matrix. It can be computed from the same set of point pairs using \char`\"{}find\+Fundamental\+Mat\char`\"{}. \\
\hline
{\em img\+Size} & Size of the image. \\
\hline
{\em H1} & Output rectification homography matrix for the first image. \\
\hline
{\em H2} & Output rectification homography matrix for the second image. \\
\hline
{\em threshold} & Optional threshold used to filter out the outliers. If the parameter is greater than zero, all the point pairs that do not comply with the epipolar geometry (that is, the points for which {\itshape $\vert$points2\mbox{[}i\mbox{]}$^\wedge$\+T$\ast$\+F$\ast$points1\mbox{[}i\mbox{]}$\vert$\&gtthreshold}) are rejected prior to computing the homographies. Otherwise,all the points are considered inliers.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereorectifyuncalibrated}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Rectify\+Uncalibrated} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a0ddeeb9de8f3bd4e8dac6b7b4c531e8e}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a0ddeeb9de8f3bd4e8dac6b7b4c531e8e}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!stereo\+Rectify\+Uncalibrated@{stereo\+Rectify\+Uncalibrated}}
\index{stereo\+Rectify\+Uncalibrated@{stereo\+Rectify\+Uncalibrated}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{stereo\+Rectify\+Uncalibrated()}{stereoRectifyUncalibrated()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Rectify\+Uncalibrated (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{points1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{points2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{F,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{img\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{H1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{H2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes a rectification transform for an uncalibrated stereo camera.

The function computes the rectification transformations without knowing intrinsic parameters of the cameras and their relative position in the space, which explains the suffix \char`\"{}uncalibrated\char`\"{}. Another related difference from \char`\"{}stereo\+Rectify\char`\"{} is that the function outputs not the rectification transformations in the object (3D) space, but the planar perspective transformations encoded by the homography matrices {\ttfamily H1} and {\ttfamily H2}. The function implements the algorithm \mbox{[}Hartley99\mbox{]}.

Note\+:

While the algorithm does not need to know the intrinsic parameters of the cameras, it heavily depends on the epipolar geometry. Therefore, if the camera lenses have a significant distortion, it would be better to correct it before computing the fundamental matrix and calling this function. For example, distortion coefficients can be estimated for each head of stereo camera separately by using \char`\"{}calibrate\+Camera\char`\"{}. Then, the images can be corrected using \char`\"{}undistort\char`\"{}, or just the point coordinates can be corrected with \char`\"{}undistort\+Points\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em points1} & Array of feature points in the first image. \\
\hline
{\em points2} & The corresponding points in the second image. The same formats as in \char`\"{}find\+Fundamental\+Mat\char`\"{} are supported. \\
\hline
{\em F} & Input fundamental matrix. It can be computed from the same set of point pairs using \char`\"{}find\+Fundamental\+Mat\char`\"{}. \\
\hline
{\em img\+Size} & Size of the image. \\
\hline
{\em H1} & Output rectification homography matrix for the first image. \\
\hline
{\em H2} & Output rectification homography matrix for the second image.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#stereorectifyuncalibrated}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+stereo\+Rectify\+Uncalibrated} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3da703062fa27931cd6e22d1a7493961}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3da703062fa27931cd6e22d1a7493961}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!triangulate\+Points@{triangulate\+Points}}
\index{triangulate\+Points@{triangulate\+Points}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{triangulate\+Points()}{triangulatePoints()}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+triangulate\+Points (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{proj\+Matr1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{proj\+Matr2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{proj\+Points1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{proj\+Points2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{points4D }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Reconstructs points by triangulation.

The function reconstructs 3-\/dimensional points (in homogeneous coordinates) by using their observations with a stereo camera. Projections matrices can be obtained from \char`\"{}stereo\+Rectify\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em proj\+Matr1} & 3x4 projection matrix of the first camera. \\
\hline
{\em proj\+Matr2} & 3x4 projection matrix of the second camera. \\
\hline
{\em proj\+Points1} & 2xN array of feature points in the first image. In case of c++ version it can be also a vector of feature points or two-\/channel matrix of size 1xN or Nx1. \\
\hline
{\em proj\+Points2} & 2xN array of corresponding points in the second image. In case of c++ version it can be also a vector of feature points or two-\/channel matrix of size 1xN or Nx1. \\
\hline
{\em points4D} & 4xN array of reconstructed points in homogeneous coordinates.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#triangulatepoints}{\tt org.\+opencv.\+calib3d.\+Calib3d.\+triangulate\+Points} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_ae31a018191ec424a007e73caf5b35e6b}{org.\+opencv.\+calib3d.\+Calib3d\+::reproject\+Image\+To3D}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5602a849111be88c91348e13795ba888}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a5602a849111be88c91348e13795ba888}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!validate\+Disparity@{validate\+Disparity}}
\index{validate\+Disparity@{validate\+Disparity}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{validate\+Disparity()}{validateDisparity()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+validate\+Disparity (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{disparity,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{cost,  }\item[{int}]{min\+Disparity,  }\item[{int}]{number\+Of\+Disparities,  }\item[{int}]{disp12\+Max\+Disp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aadd44bca728908e8afff768d760e3a83}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_aadd44bca728908e8afff768d760e3a83}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!validate\+Disparity@{validate\+Disparity}}
\index{validate\+Disparity@{validate\+Disparity}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{validate\+Disparity()}{validateDisparity()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+calib3d.\+Calib3d.\+validate\+Disparity (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{disparity,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{cost,  }\item[{int}]{min\+Disparity,  }\item[{int}]{number\+Of\+Disparities }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



\subsection{Member Data Documentation}
\mbox{\Hypertarget{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3f736627ca0cf3d33c043fc10a937081}\label{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a3f736627ca0cf3d33c043fc10a937081}} 
\index{org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}!C\+V\+\_\+\+I\+T\+E\+R\+A\+T\+I\+VE@{C\+V\+\_\+\+I\+T\+E\+R\+A\+T\+I\+VE}}
\index{C\+V\+\_\+\+I\+T\+E\+R\+A\+T\+I\+VE@{C\+V\+\_\+\+I\+T\+E\+R\+A\+T\+I\+VE}!org\+::opencv\+::calib3d\+::\+Calib3d@{org\+::opencv\+::calib3d\+::\+Calib3d}}
\subsubsection{\texorpdfstring{C\+V\+\_\+\+I\+T\+E\+R\+A\+T\+I\+VE}{CV\_ITERATIVE}}
{\footnotesize\ttfamily final int org.\+opencv.\+calib3d.\+Calib3d.\+C\+V\+\_\+\+I\+T\+E\+R\+A\+T\+I\+VE = 0\hspace{0.3cm}{\ttfamily [static]}}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/\+Marcius/\+Documents/\+Git\+Hub/\+Skaitliuko-\/\+Skeneris/open\+C\+V\+Library249/src/main/java/org/opencv/calib3d/\mbox{\hyperlink{_calib3d_8java}{Calib3d.\+java}}\end{DoxyCompactItemize}
