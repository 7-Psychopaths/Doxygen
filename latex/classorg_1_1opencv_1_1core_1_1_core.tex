\hypertarget{classorg_1_1opencv_1_1core_1_1_core}{}\section{org.\+opencv.\+core.\+Core Class Reference}
\label{classorg_1_1opencv_1_1core_1_1_core}\index{org.\+opencv.\+core.\+Core@{org.\+opencv.\+core.\+Core}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bfseries Min\+Max\+Loc\+Result}
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a51b34caa90fa1c30524b3cb852d840d6}{L\+UT}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} lut, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int interpolation)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8536482ca714c4dc25fff4c48ae64bca}{L\+UT}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} lut, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae6da41381cc2fc87daa1a14a2c476781}{Mahalanobis}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} v1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} v2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} icovar)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a3b8b2b268d857381ddc7bba20b464d1f}{P\+C\+A\+Back\+Project}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} data, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{mean}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} eigenvectors, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} result)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aab65f922f93f6aad0b5d10ba2f27f401}{P\+C\+A\+Compute}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} data, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{mean}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} eigenvectors, int max\+Components)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa77b57fe39b738ce2260e77c84405e73}{P\+C\+A\+Compute}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} data, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{mean}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} eigenvectors)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a05764d4479aec67351a6c96915053333}{P\+C\+A\+Compute\+Var}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} data, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{mean}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} eigenvectors, double retained\+Variance)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac1b1800fd7a0b44ef5c5fbfe45d42eda}{P\+C\+A\+Project}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} data, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{mean}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} eigenvectors, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} result)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8f8ec69060789e7183c4a2a49dd729d9}{S\+V\+Back\+Subst}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} w, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} u, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} vt, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rhs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8b6381c8ddf094439720386b1acdb9ce}{S\+V\+Decomp}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} w, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} u, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} vt, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa2a097bef3c1f59efe29e6a723640851}{S\+V\+Decomp}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} w, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} u, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} vt)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a7ca624705224f143de9fea745ae576d0}{absdiff}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a90248e08d320ec9644f7d14036e69f83}{absdiff}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{add}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac5f0867cadd165ad7bd88c053cfe2819}{add}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a28dd353019846175cc1817c13c956ebf}{add}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a121d01c86742713b36432abb0e98f36c}{add}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8ecda2c5c231e42f7ee286b9b355f931}{add}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa16982c864b3f8bd807771aff8baf751}{add}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{add\+Weighted}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, double alpha, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, double beta, double gamma, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab74a2a59f0becfed354284b235437050}{add\+Weighted}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, double alpha, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, double beta, double gamma, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a70d45a1c21c5423a1539f795ea58654d}{batch\+Distance}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist, int dtype, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} nidx, int norm\+Type, int K, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, int update, boolean crosscheck)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1a20f1a6cd9f3fb0278657f1c9fe22bb}{batch\+Distance}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist, int dtype, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} nidx, int norm\+Type, int K)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a316866023305882fb794af7a3db7299c}{batch\+Distance}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist, int dtype, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} nidx)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a848cb46acc8307c57896d9835e90f86c}{bitwise\+\_\+and}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab376a49982b71a45694dde03a5fe9f4b}{bitwise\+\_\+and}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a699dcf3ff136d793510cab1077a0d83c}{bitwise\+\_\+not}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a622d75ef3b79e5a7676f8c4a2eeb6a28}{bitwise\+\_\+not}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a45c046e3bef54eeeacda2b09b4c953b4}{bitwise\+\_\+or}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9410465c8cdc784ae221bfe9e0e74522}{bitwise\+\_\+or}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab45e6bad43761e254c58dcaefa401ff3}{bitwise\+\_\+xor}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac7f4b63e34cd4f8f9e4c570f36acf942}{bitwise\+\_\+xor}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afebca901f30f80a2a6db7a67cc2afb0a}{calc\+Covar\+Matrix}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} samples, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} covar, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{mean}}, int flags, int ctype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac9a38bf2bcad4daa87e017dceb927bc3}{calc\+Covar\+Matrix}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} samples, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} covar, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{mean}}, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{cart\+To\+Polar}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} x, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} y, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{magnitude}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} angle, boolean angle\+In\+Degrees)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a6bb86bd8157b4d8561b29e288445a6c9}{cart\+To\+Polar}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} x, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} y, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{magnitude}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} angle)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a2260f7346beb98771f860e39e4b4a924}{check\+Range}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} a, boolean quiet, double min\+Val, double max\+Val)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5eca29b5a4b3eb63f1a549970847dfcd}{check\+Range}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} a)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa0f688f66d937f5952cb9f1db6f43326}{circle}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} center, int radius, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness, int line\+Type, int shift)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a205ea116055f6a84cc6c9d0409df0adc}{circle}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} center, int radius, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a55df53a3f36b33188cb2e5cfa385ffbc}{circle}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} center, int radius, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a73c128fa46a560c0e998791dd5cf890a}{clip\+Line}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} img\+Rect, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt2)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a6f1dc64655b7da1219d82f809efb7e16}{compare}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int cmpop)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab8d00dae0089e28d72949594e63ccc18}{compare}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int cmpop)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad3a0199c2b0bbc9d254768b566fd257e}{complete\+Symm}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mtx, boolean lower\+To\+Upper)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a57f226ca886a32a25619bd0eb17df076}{complete\+Symm}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mtx)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a42f107c63200e26f87ddb11631980be7}{convert\+Scale\+Abs}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double alpha, double beta)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adc3cd8b03f5b39cb0d795dddd43e2e16}{convert\+Scale\+Abs}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a216308f36e765f82c521087fe283e045}{count\+Non\+Zero}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src)
\item 
static float \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a08e2ce54e07e80ac946866bf205d9333}{cube\+Root}} (float val)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1f0b3c28295d4db1ecd755201833d6cb}{dct}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab3eb0749baa205b6ae4c7af183c57177}{dct}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9108dd80dbec1fd4f196a6e9e2564734}{determinant}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mtx)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{dft}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int flags, int nonzero\+Rows)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a06e879ce4de29934c450c8f1e7631a24}{dft}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad0cc67e80d303076c4a8d486fe6b82c9}{divide}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double scale, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af2bc7a755d5d149644b0eceef2c3decc}{divide}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double scale)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a7fb1d61ed82296b38b4e5a2a15d0bb8e}{divide}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a72e29fcc15a837f2f76e2cc2c8429f06}{divide}} (double scale, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1600c192648e1f09e86b9b7ae8d6ea82}{divide}} (double scale, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae4f6a61347c1af3819e65925d34f0d45}{divide}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double scale, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae25ecaef7b81165a9700c04ca6a14ad8}{divide}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double scale)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aee28f9ac9f6b8cb02b05f34007cf84bc}{divide}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab44f09e696b045957316b9b384ef0c70}{eigen}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, boolean compute\+Eigenvectors, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} eigenvalues, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} eigenvectors)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a3ef54117896a561685fd30cd374c2ce6}{ellipse}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} center, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} axes, double angle, double start\+Angle, double end\+Angle, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness, int line\+Type, int shift)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a55af7b6ca8fdb3e8c2d13cca74081267}{ellipse}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} center, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} axes, double angle, double start\+Angle, double end\+Angle, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a288c270183c0a0930910e55bf421c1a2}{ellipse}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} center, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} axes, double angle, double start\+Angle, double end\+Angle, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a90332fb5cef2fa8e33b3e304f7c868ff}{ellipse}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rotated_rect}{Rotated\+Rect}} box, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness, int line\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab32656b0a495ca643801145d700afcc4}{ellipse}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rotated_rect}{Rotated\+Rect}} box, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a31b26443f36f448e4ed2714ca3558150}{ellipse}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rotated_rect}{Rotated\+Rect}} box, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab4ab635dc04de40b7dd1722a99bfcc34}{ellipse2\+Poly}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} center, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} axes, int angle, int arc\+Start, int arc\+End, int delta, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} pts)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a18688b13789043dfaa98161fe663f075}{exp}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aed121d8dfc230918f9086b7ba06c0b57}{extract\+Channel}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int coi)
\item 
static float \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aeb2a09f9bb80c8c33e4b5074078d892c}{fast\+Atan2}} (float y, float x)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad5886a0bea843f9e8b5d6680309b53a7}{fill\+Convex\+Poly}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int line\+Type, int shift)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af384d6fce35de3e8e9dbed55b13e51a6}{fill\+Convex\+Poly}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad8378847b326f2e9edfba5c6ad68a171}{fill\+Poly}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$ pts, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int line\+Type, int shift, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} offset)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a315055271ede64d63610b0f03b31026b}{fill\+Poly}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$ pts, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a386b6ad3e80eca8a6afa48a2e5423140}{find\+Non\+Zero}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} idx)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8dc68bbfca84b4fdfb9cd7bd79fc893e}{flip}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int flip\+Code)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a68aea4eb6784b0aaa0f5c0770fa7bde0}{gemm}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, double alpha, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src3, double gamma, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae2574392283beecd4f987326489e38c4}{gemm}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, double alpha, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src3, double gamma, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static String \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a359cc7a14c10ba08bd29761bd9ec607c}{get\+Build\+Information}} ()
\item 
static long \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a63858b4080485f600e39a29c722a7a85}{get\+C\+P\+U\+Tick\+Count}} ()
\item 
static int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4f58562c2297384087202e154b2b7555}{get\+Number\+Of\+C\+P\+Us}} ()
\item 
static int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}{get\+Optimal\+D\+F\+T\+Size}} (int vecsize)
\item 
static long \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adffc76724114188de1dcad5582ce7631}{get\+Tick\+Count}} ()
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afc3677eba8a0186c9b92ebfa096301ec}{get\+Tick\+Frequency}} ()
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae809cca27285b20fc31b42ffb7e5b5cb}{hconcat}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a64eb690877f2d4ac16c1b1c3375c0b7b}{idct}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4f55e86b56025dd6bd516a43c2b7ad46}{idct}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4fc0b0f22fef014f5e602e8d5b367a44}{idft}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int flags, int nonzero\+Rows)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a117c710f5f551746f7e4e836a271f853}{idft}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adda843559663a35e9a710c93b1f86096}{in\+Range}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} lowerb, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} upperb, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aafde7d856dba7bb7446caf2caeb2dd20}{insert\+Channel}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int coi)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af7c788172a8e426cf6b6cedc8d828f1b}{invert}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int flags)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a454495bfa5d22875cd357fd28b537619}{invert}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9870d70cc55618004735e38a0931ab3a}{kmeans}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} data, int K, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} best\+Labels, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}} criteria, int attempts, int flags, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} centers)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5e0e7f71bc5434aedfbca27eb1a51450}{kmeans}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} data, int K, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} best\+Labels, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}} criteria, int attempts, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9273ae8a7351870e645bd3a185af79b9}{line}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness, int line\+Type, int shift)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aae5f5687ccac9691ecb1c5ee0d99575a}{line}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae8bbb241c117c20adae94f394110473c}{line}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a34d89a9c8e2562fc85bfecca3dca7d76}{log}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{magnitude}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} x, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} y, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} magnitude)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aae8ad4feaca1ca8234bd88cbf9090cf5}{max}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aba74797cfade029693c6737957fe3b7f}{max}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{mean}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a25ced9c1cf960900fbed712b13235dbd}{mean}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af8d7fbb33c11fbf6115d4c242dbbb5b3}{mean\+Std\+Dev}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{mean}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}} stddev, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a94a681b5485885aa1fbf868fc0718188}{mean\+Std\+Dev}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{mean}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}} stddev)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af245932b4a6d1aee20be9610388bb06a}{merge}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ mv, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a24561bfde2c7fe7d2b7bee9d5ba8c92e}{min}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a89f8b6dddb1448f5e525dbe8a0a4390f}{min}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a812a71941c37c615cb474bff0eacbb2e}{mix\+Channels}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ src, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}} from\+To)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a249146033929c968ef948e290c2a438c}{mul\+Spectrums}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} a, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} b, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} c, int flags, boolean conjB)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a781f8481b692f31be8a086df59de3eab}{mul\+Spectrums}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} a, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} b, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} c, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aecfddbae696272a338eb12056603d4e9}{mul\+Transposed}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, boolean a\+Ta, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} delta, double scale, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac98f79bd02ed3a8202f516f2bf6c0053}{mul\+Transposed}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, boolean a\+Ta, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} delta, double scale)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9b09383bb522f3de2ba10c7e406cedec}{mul\+Transposed}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, boolean a\+Ta)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa49b10c74b442ec7cc890f9ce812918a}{multiply}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double scale, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae8964daf7682cfd4170fae06b195939d}{multiply}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double scale)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad159823509d5f6cfac9839f7589f9a7e}{multiply}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1b59367e832360dfa8cef944ecbc17ec}{multiply}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double scale, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9ba18c691a0cb984dcb9408e3d6721fb}{multiply}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double scale)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a248747a674dce2ed86c45e4d66caaddf}{multiply}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}{norm}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, int norm\+Type, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a622a34c86e60dff3ad3990cae4bc3766}{norm}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, int norm\+Type)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a3ba2adc811656da873ceecb3c4c70335}{norm}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a23c3e3b3fa55f87f23805428dde2a157}{norm}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, int norm\+Type, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9701be26bf1d6b0266034f83a7f85535}{norm}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, int norm\+Type)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a94edbb7146566314b150cb3434db8dfa}{norm}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a10833c4c941f13d93e3c5e702efa482e}{normalize}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double alpha, double beta, int norm\+\_\+type, int dtype, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a339332679c8e7d52cc2e1bba2187b8ff}{normalize}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double alpha, double beta, int norm\+\_\+type, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af2e92f82c3f412aa25d1065065d07afe}{normalize}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double alpha, double beta, int norm\+\_\+type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a659f5c8fc2f3d5ee432879bf968f6743}{normalize}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab0dae7a8f13b75f48d05b12fc327009a}{patch\+Na\+Ns}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} a, double val)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a044bc13c2a268300ece0f51213b37cfe}{patch\+Na\+Ns}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} a)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1ff0eace0f00e79af5228fdae120342a}{perspective\+Transform}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a09f94d89796effb89e2bff15c54b383a}{phase}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} x, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} y, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} angle, boolean angle\+In\+Degrees)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aac26449052db09ffe451743fffc92270}{phase}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} x, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} y, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} angle)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a90c17a6d7e194cd8baf45819267a4539}{polar\+To\+Cart}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{magnitude}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} angle, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} x, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} y, boolean angle\+In\+Degrees)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa5d94ecf80128fd344c06cd4d286cfd6}{polar\+To\+Cart}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{magnitude}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} angle, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} x, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} y)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad24a7743adf154594355229a6c0a19cd}{polylines}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$ pts, boolean is\+Closed, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness, int line\+Type, int shift)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a377faf881106086b38611168440c5321}{polylines}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$ pts, boolean is\+Closed, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1f9634590e755ea36ed3e5bdc7245811}{polylines}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$ pts, boolean is\+Closed, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a29c20af97ae09c75246777774bc6d41b}{pow}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, double power, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a83cb8f8058aead15a4f9995328aef154}{put\+Text}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, String text, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} org, int font\+Face, double font\+Scale, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness, int line\+Type, boolean bottom\+Left\+Origin)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1a575810e5c02ecba186388a77e6af94}{put\+Text}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, String text, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} org, int font\+Face, double font\+Scale, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_acd34e2234dab5c2eb2f8f2c517bf9f2a}{put\+Text}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, String text, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} org, int font\+Face, double font\+Scale, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab80ad04c349aee7d887830ec8de84ae2}{rand\+Shuffle}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double iter\+Factor)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac1698bb3fd0c489839e5dd5eccfe5260}{rand\+Shuffle}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adc06c7d15abcade8d369a20bab2d7355}{randn}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{mean}}, double stddev)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_abfe7d53276a89fcf1a78b744cd75b9fc}{randu}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double low, double high)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a3d2d8fc68149238f6b3d7c0d6e70066a}{rectangle}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness, int line\+Type, int shift)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a713e32fc1ab8efed4d38172dc3731627}{rectangle}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a867d653e8edc48f1c36ef0b44fdfbc2e}{rectangle}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1849fb31954ac7655a174184f2eba671}{reduce}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int dim, int rtype, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a40f3b2f5156462a56912093ce7d9dc47}{reduce}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int dim, int rtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afcf15abfb6c9bf3a4126ae8199fc5ff3}{repeat}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, int ny, int nx, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{scale\+Add}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, double alpha, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a0932c141d51242fd49448aa6d4013101}{set\+Error\+Verbosity}} (boolean verbose)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae3f55d8eaa889edf706fb60874e92bd4}{set\+Identity}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mtx, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} s)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9907da2380a9f7de76f9a82dc168cf56}{set\+Identity}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mtx)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af6e1ab8eaa1618c30a16e38da739bbeb}{solve}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int flags)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a59b5de8a604e0fc96345da475f356bd3}{solve}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad5466c6635353bcb874f9fa8147c4368}{solve\+Cubic}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} roots)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afff6c36fd7aad820639aa8de5b52a5f7}{solve\+Poly}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} roots, int max\+Iters)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aec537b8ec1bca2bbff556a00efc08579}{solve\+Poly}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} roots)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae5b5fdaa4bafa45a5a43443016b037b6}{sort}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a68ae6cb0aec9fde08e91a48427684a7e}{sort\+Idx}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa22f046c4f14cda50c10f5d22ffdbb26}{split}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ mv)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5a2235761d8876294b3277876479107b}{sqrt}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{subtract}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aba1cd3f5a5c28b9c72daf97b95677d7a}{subtract}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae6f3f612d92b7907ac2daa9c2f8a2ee2}{subtract}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_abf10e2e2d74d5e9bc9785dcda5933ea9}{subtract}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, int dtype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5a5060e06b78859e4f22f964ee6dac4d}{subtract}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a51ebf388c0fd37fdaf07cd30cd54c8ea}{subtract}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a3c40c8e48917ad9a27fa45674bff78a3}{sum\+Elems}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9c17a12158c59ea65c662cac491c28c3}{trace}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mtx)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a221e7697d1a57961ee8a843b7aa05b75}{transform}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4536de6a43f5dfb4d4ba1bf24735696a}{transpose}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8dee19abadf7067469cd4532a2fd62fd}{vconcat}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static Min\+Max\+Loc\+Result \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}{min\+Max\+Loc}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static Min\+Max\+Loc\+Result \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af85a1994a360e2c955622a2583de1d81}{min\+Max\+Loc}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab6071e8e7cb8266aad46d7d95cb73fe7}{get\+Text\+Size}} (String text, int font\+Face, double font\+Scale, int thickness, int\mbox{[}$\,$\mbox{]} base\+Line)
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static final String \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8b5aa972c9a65c4dc8da80aa97a9e0d6}{V\+E\+R\+S\+I\+ON}} = get\+Version()
\item 
static final String \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a6f74a56e173ada31969137d7d80d44b5}{N\+A\+T\+I\+V\+E\+\_\+\+L\+I\+B\+R\+A\+R\+Y\+\_\+\+N\+A\+ME}} = get\+Native\+Library\+Name()
\item 
static final int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aed42db3ccc84e356b8d432c0271e9ee7}{V\+E\+R\+S\+I\+O\+N\+\_\+\+E\+P\+O\+CH}} = get\+Version\+Epoch()
\item 
static final int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4c31c533f50245f45626ce220e67638d}{V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+A\+J\+OR}} = get\+Version\+Major()
\item 
static final int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8c815d0d147f2ec108adc1ead0107822}{V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+I\+N\+OR}} = get\+Version\+Minor()
\item 
static final int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae29e5d49ffed39a7b12e44d4101ad944}{V\+E\+R\+S\+I\+O\+N\+\_\+\+R\+E\+V\+I\+S\+I\+ON}} = get\+Version\+Revision()
\item 
static final int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a0d0df5fd9960ef75c8256603419f345d}{S\+V\+D\+\_\+\+M\+O\+D\+I\+F\+Y\+\_\+A}} = 1
\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a7ca624705224f143de9fea745ae576d0}\label{classorg_1_1opencv_1_1core_1_1_core_a7ca624705224f143de9fea745ae576d0}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!absdiff@{absdiff}}
\index{absdiff@{absdiff}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{absdiff()}{absdiff()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+absdiff (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element absolute difference between two arrays or between an array and a scalar.

The function {\ttfamily absdiff} calculates\+:


\begin{DoxyItemize}
\item Absolute difference between two arrays when they have the same size and type\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate($\vert$ src1(\+I) -\/ src2(\+I)$\vert$)}


\begin{DoxyItemize}
\item Absolute difference between an array and a scalar when the second array is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has as many elements as the number of channels in {\ttfamily src1}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate($\vert$ src1(\+I) -\/ src2$\vert$)}


\begin{DoxyItemize}
\item Absolute difference between a scalar and an array when the first array is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has as many elements as the number of channels in {\ttfamily src2}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate($\vert$ src1 -\/ src2(\+I)$\vert$)}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently.

Note\+: Saturation is not applied when the arrays have the depth {\ttfamily C\+V\+\_\+32S}. You may even get a negative value in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and type as input arrays.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#absdiff}{\tt org.\+opencv.\+core.\+Core.\+absdiff} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a90248e08d320ec9644f7d14036e69f83}\label{classorg_1_1opencv_1_1core_1_1_core_a90248e08d320ec9644f7d14036e69f83}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!absdiff@{absdiff}}
\index{absdiff@{absdiff}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{absdiff()}{absdiff()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+absdiff (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element absolute difference between two arrays or between an array and a scalar.

The function {\ttfamily absdiff} calculates\+:


\begin{DoxyItemize}
\item Absolute difference between two arrays when they have the same size and type\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate($\vert$ src1(\+I) -\/ src2(\+I)$\vert$)}


\begin{DoxyItemize}
\item Absolute difference between an array and a scalar when the second array is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has as many elements as the number of channels in {\ttfamily src1}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate($\vert$ src1(\+I) -\/ src2$\vert$)}


\begin{DoxyItemize}
\item Absolute difference between a scalar and an array when the first array is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has as many elements as the number of channels in {\ttfamily src2}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate($\vert$ src1 -\/ src2(\+I)$\vert$)}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently.

Note\+: Saturation is not applied when the arrays have the depth {\ttfamily C\+V\+\_\+32S}. You may even get a negative value in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and type as input arrays.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#absdiff}{\tt org.\+opencv.\+core.\+Core.\+absdiff} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}\label{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!add@{add}}
\index{add@{add}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element sum of two arrays or an array and a scalar.

The function {\ttfamily add} calculates\+:


\begin{DoxyItemize}
\item Sum of two arrays when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of an array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of a scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 + src2(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 + src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst += src1; // equivalent to add(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can add a 16-\/bit unsigned array to a 8-\/bit signed array and store the sum as a 32-\/bit floating-\/point array. Depth of the output array is determined by the {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case, the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and number of channels as the input array(s); the depth is defined by {\ttfamily dtype} or {\ttfamily src1}/{\ttfamily src2}. \\
\hline
{\em mask} & optional operation mask -\/ 8-\/bit single channel array, that specifies elements of the output array to be changed. \\
\hline
{\em dtype} & optional depth of the output array (see the discussion below).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add}{\tt org.\+opencv.\+core.\+Core.\+add} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ac5f0867cadd165ad7bd88c053cfe2819}\label{classorg_1_1opencv_1_1core_1_1_core_ac5f0867cadd165ad7bd88c053cfe2819}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!add@{add}}
\index{add@{add}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element sum of two arrays or an array and a scalar.

The function {\ttfamily add} calculates\+:


\begin{DoxyItemize}
\item Sum of two arrays when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of an array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of a scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 + src2(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 + src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst += src1; // equivalent to add(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can add a 16-\/bit unsigned array to a 8-\/bit signed array and store the sum as a 32-\/bit floating-\/point array. Depth of the output array is determined by the {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case, the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and number of channels as the input array(s); the depth is defined by {\ttfamily dtype} or {\ttfamily src1}/{\ttfamily src2}. \\
\hline
{\em mask} & optional operation mask -\/ 8-\/bit single channel array, that specifies elements of the output array to be changed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add}{\tt org.\+opencv.\+core.\+Core.\+add} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a28dd353019846175cc1817c13c956ebf}\label{classorg_1_1opencv_1_1core_1_1_core_a28dd353019846175cc1817c13c956ebf}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!add@{add}}
\index{add@{add}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element sum of two arrays or an array and a scalar.

The function {\ttfamily add} calculates\+:


\begin{DoxyItemize}
\item Sum of two arrays when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of an array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of a scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 + src2(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 + src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst += src1; // equivalent to add(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can add a 16-\/bit unsigned array to a 8-\/bit signed array and store the sum as a 32-\/bit floating-\/point array. Depth of the output array is determined by the {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case, the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and number of channels as the input array(s); the depth is defined by {\ttfamily dtype} or {\ttfamily src1}/{\ttfamily src2}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add}{\tt org.\+opencv.\+core.\+Core.\+add} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a121d01c86742713b36432abb0e98f36c}\label{classorg_1_1opencv_1_1core_1_1_core_a121d01c86742713b36432abb0e98f36c}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!add@{add}}
\index{add@{add}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element sum of two arrays or an array and a scalar.

The function {\ttfamily add} calculates\+:


\begin{DoxyItemize}
\item Sum of two arrays when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of an array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of a scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 + src2(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 + src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst += src1; // equivalent to add(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can add a 16-\/bit unsigned array to a 8-\/bit signed array and store the sum as a 32-\/bit floating-\/point array. Depth of the output array is determined by the {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case, the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and number of channels as the input array(s); the depth is defined by {\ttfamily dtype} or {\ttfamily src1}/{\ttfamily src2}. \\
\hline
{\em mask} & optional operation mask -\/ 8-\/bit single channel array, that specifies elements of the output array to be changed. \\
\hline
{\em dtype} & optional depth of the output array (see the discussion below).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add}{\tt org.\+opencv.\+core.\+Core.\+add} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a8ecda2c5c231e42f7ee286b9b355f931}\label{classorg_1_1opencv_1_1core_1_1_core_a8ecda2c5c231e42f7ee286b9b355f931}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!add@{add}}
\index{add@{add}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element sum of two arrays or an array and a scalar.

The function {\ttfamily add} calculates\+:


\begin{DoxyItemize}
\item Sum of two arrays when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of an array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of a scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 + src2(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 + src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst += src1; // equivalent to add(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can add a 16-\/bit unsigned array to a 8-\/bit signed array and store the sum as a 32-\/bit floating-\/point array. Depth of the output array is determined by the {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case, the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and number of channels as the input array(s); the depth is defined by {\ttfamily dtype} or {\ttfamily src1}/{\ttfamily src2}. \\
\hline
{\em mask} & optional operation mask -\/ 8-\/bit single channel array, that specifies elements of the output array to be changed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add}{\tt org.\+opencv.\+core.\+Core.\+add} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aa16982c864b3f8bd807771aff8baf751}\label{classorg_1_1opencv_1_1core_1_1_core_aa16982c864b3f8bd807771aff8baf751}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!add@{add}}
\index{add@{add}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{add()}{add()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element sum of two arrays or an array and a scalar.

The function {\ttfamily add} calculates\+:


\begin{DoxyItemize}
\item Sum of two arrays when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of an array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) + src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Sum of a scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 + src2(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 + src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst += src1; // equivalent to add(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can add a 16-\/bit unsigned array to a 8-\/bit signed array and store the sum as a 32-\/bit floating-\/point array. Depth of the output array is determined by the {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case, the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and number of channels as the input array(s); the depth is defined by {\ttfamily dtype} or {\ttfamily src1}/{\ttfamily src2}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#add}{\tt org.\+opencv.\+core.\+Core.\+add} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}\label{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!add\+Weighted@{add\+Weighted}}
\index{add\+Weighted@{add\+Weighted}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{add\+Weighted()}{addWeighted()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+add\+Weighted (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{double}]{alpha,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{double}]{beta,  }\item[{double}]{gamma,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the weighted sum of two arrays.

The function {\ttfamily add\+Weighted} calculates the weighted sum of two arrays as follows\+:

{\itshape dst(\+I)= saturate(src1(\+I)$\ast$ alpha + src2(\+I)$\ast$ beta + gamma)}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The function can be replaced with a matrix expression\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1$\ast$alpha + src2$\ast$beta + gamma;}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow. }


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em alpha} & weight of the first array elements. \\
\hline
{\em src2} & second input array of the same size and channel number as {\ttfamily src1}. \\
\hline
{\em beta} & weight of the second array elements. \\
\hline
{\em gamma} & scalar added to each sum. \\
\hline
{\em dst} & output array that has the same size and number of channels as the input arrays. \\
\hline
{\em dtype} & optional depth of the output array; when both input arrays have the same depth, {\ttfamily dtype} can be set to {\ttfamily -\/1}, which will be equivalent to {\ttfamily src1.\+depth()}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#addweighted}{\tt org.\+opencv.\+core.\+Core.\+add\+Weighted} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ab74a2a59f0becfed354284b235437050}\label{classorg_1_1opencv_1_1core_1_1_core_ab74a2a59f0becfed354284b235437050}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!add\+Weighted@{add\+Weighted}}
\index{add\+Weighted@{add\+Weighted}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{add\+Weighted()}{addWeighted()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+add\+Weighted (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{double}]{alpha,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{double}]{beta,  }\item[{double}]{gamma,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the weighted sum of two arrays.

The function {\ttfamily add\+Weighted} calculates the weighted sum of two arrays as follows\+:

{\itshape dst(\+I)= saturate(src1(\+I)$\ast$ alpha + src2(\+I)$\ast$ beta + gamma)}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The function can be replaced with a matrix expression\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1$\ast$alpha + src2$\ast$beta + gamma;}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow. }


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em alpha} & weight of the first array elements. \\
\hline
{\em src2} & second input array of the same size and channel number as {\ttfamily src1}. \\
\hline
{\em beta} & weight of the second array elements. \\
\hline
{\em gamma} & scalar added to each sum. \\
\hline
{\em dst} & output array that has the same size and number of channels as the input arrays.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#addweighted}{\tt org.\+opencv.\+core.\+Core.\+add\+Weighted} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a70d45a1c21c5423a1539f795ea58654d}\label{classorg_1_1opencv_1_1core_1_1_core_a70d45a1c21c5423a1539f795ea58654d}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!batch\+Distance@{batch\+Distance}}
\index{batch\+Distance@{batch\+Distance}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{batch\+Distance()}{batchDistance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+batch\+Distance (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist,  }\item[{int}]{dtype,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{nidx,  }\item[{int}]{norm\+Type,  }\item[{int}]{K,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{int}]{update,  }\item[{boolean}]{crosscheck }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a1a20f1a6cd9f3fb0278657f1c9fe22bb}\label{classorg_1_1opencv_1_1core_1_1_core_a1a20f1a6cd9f3fb0278657f1c9fe22bb}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!batch\+Distance@{batch\+Distance}}
\index{batch\+Distance@{batch\+Distance}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{batch\+Distance()}{batchDistance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+batch\+Distance (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist,  }\item[{int}]{dtype,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{nidx,  }\item[{int}]{norm\+Type,  }\item[{int}]{K }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a316866023305882fb794af7a3db7299c}\label{classorg_1_1opencv_1_1core_1_1_core_a316866023305882fb794af7a3db7299c}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!batch\+Distance@{batch\+Distance}}
\index{batch\+Distance@{batch\+Distance}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{batch\+Distance()}{batchDistance()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+batch\+Distance (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist,  }\item[{int}]{dtype,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{nidx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a848cb46acc8307c57896d9835e90f86c}\label{classorg_1_1opencv_1_1core_1_1_core_a848cb46acc8307c57896d9835e90f86c}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!bitwise\+\_\+and@{bitwise\+\_\+and}}
\index{bitwise\+\_\+and@{bitwise\+\_\+and}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{bitwise\+\_\+and()}{bitwise\_and()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+bitwise\+\_\+and (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element bit-\/wise conjunction of two arrays or an array and a scalar.

The function calculates the per-\/element bit-\/wise logical conjunction for\+:


\begin{DoxyItemize}
\item Two arrays when {\ttfamily src1} and {\ttfamily src2} have the same size\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) / src2(\+I) if mask(\+I) != 0}


\begin{DoxyItemize}
\item An array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) / src2 if mask(\+I) != 0}


\begin{DoxyItemize}
\item A scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1 / src2(\+I) if mask(\+I) != 0}

In case of floating-\/point arrays, their machine-\/specific bit representations (usually I\+E\+E\+E754-\/compliant) are used for the operation. In case of multi-\/channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and type as the input arrays. \\
\hline
{\em mask} & optional operation mask, 8-\/bit single channel array, that specifies elements of the output array to be changed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-and}{\tt org.\+opencv.\+core.\+Core.\+bitwise\+\_\+and} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ab376a49982b71a45694dde03a5fe9f4b}\label{classorg_1_1opencv_1_1core_1_1_core_ab376a49982b71a45694dde03a5fe9f4b}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!bitwise\+\_\+and@{bitwise\+\_\+and}}
\index{bitwise\+\_\+and@{bitwise\+\_\+and}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{bitwise\+\_\+and()}{bitwise\_and()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+bitwise\+\_\+and (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element bit-\/wise conjunction of two arrays or an array and a scalar.

The function calculates the per-\/element bit-\/wise logical conjunction for\+:


\begin{DoxyItemize}
\item Two arrays when {\ttfamily src1} and {\ttfamily src2} have the same size\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) / src2(\+I) if mask(\+I) != 0}


\begin{DoxyItemize}
\item An array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) / src2 if mask(\+I) != 0}


\begin{DoxyItemize}
\item A scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1 / src2(\+I) if mask(\+I) != 0}

In case of floating-\/point arrays, their machine-\/specific bit representations (usually I\+E\+E\+E754-\/compliant) are used for the operation. In case of multi-\/channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and type as the input arrays.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-and}{\tt org.\+opencv.\+core.\+Core.\+bitwise\+\_\+and} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a699dcf3ff136d793510cab1077a0d83c}\label{classorg_1_1opencv_1_1core_1_1_core_a699dcf3ff136d793510cab1077a0d83c}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!bitwise\+\_\+not@{bitwise\+\_\+not}}
\index{bitwise\+\_\+not@{bitwise\+\_\+not}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{bitwise\+\_\+not()}{bitwise\_not()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+bitwise\+\_\+not (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Inverts every bit of an array.

The function calculates per-\/element bit-\/wise inversion of the input array\+:

{\itshape dst(\+I) = !src(I)}

In case of a floating-\/point input array, its machine-\/specific bit representation (usually I\+E\+E\+E754-\/compliant) is used for the operation. In case of multi-\/channel arrays, each channel is processed independently.


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array that has the same size and type as the input array. \\
\hline
{\em mask} & optional operation mask, 8-\/bit single channel array, that specifies elements of the output array to be changed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-not}{\tt org.\+opencv.\+core.\+Core.\+bitwise\+\_\+not} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a622d75ef3b79e5a7676f8c4a2eeb6a28}\label{classorg_1_1opencv_1_1core_1_1_core_a622d75ef3b79e5a7676f8c4a2eeb6a28}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!bitwise\+\_\+not@{bitwise\+\_\+not}}
\index{bitwise\+\_\+not@{bitwise\+\_\+not}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{bitwise\+\_\+not()}{bitwise\_not()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+bitwise\+\_\+not (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Inverts every bit of an array.

The function calculates per-\/element bit-\/wise inversion of the input array\+:

{\itshape dst(\+I) = !src(I)}

In case of a floating-\/point input array, its machine-\/specific bit representation (usually I\+E\+E\+E754-\/compliant) is used for the operation. In case of multi-\/channel arrays, each channel is processed independently.


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array that has the same size and type as the input array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-not}{\tt org.\+opencv.\+core.\+Core.\+bitwise\+\_\+not} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a45c046e3bef54eeeacda2b09b4c953b4}\label{classorg_1_1opencv_1_1core_1_1_core_a45c046e3bef54eeeacda2b09b4c953b4}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!bitwise\+\_\+or@{bitwise\+\_\+or}}
\index{bitwise\+\_\+or@{bitwise\+\_\+or}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{bitwise\+\_\+or()}{bitwise\_or()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+bitwise\+\_\+or (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element bit-\/wise disjunction of two arrays or an array and a scalar.

The function calculates the per-\/element bit-\/wise logical disjunction for\+:


\begin{DoxyItemize}
\item Two arrays when {\ttfamily src1} and {\ttfamily src2} have the same size\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) V src2(\+I) if mask(\+I) != 0}


\begin{DoxyItemize}
\item An array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) V src2 if mask(\+I) != 0}


\begin{DoxyItemize}
\item A scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1 V src2(\+I) if mask(\+I) != 0}

In case of floating-\/point arrays, their machine-\/specific bit representations (usually I\+E\+E\+E754-\/compliant) are used for the operation. In case of multi-\/channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and type as the input arrays. \\
\hline
{\em mask} & optional operation mask, 8-\/bit single channel array, that specifies elements of the output array to be changed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-or}{\tt org.\+opencv.\+core.\+Core.\+bitwise\+\_\+or} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a9410465c8cdc784ae221bfe9e0e74522}\label{classorg_1_1opencv_1_1core_1_1_core_a9410465c8cdc784ae221bfe9e0e74522}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!bitwise\+\_\+or@{bitwise\+\_\+or}}
\index{bitwise\+\_\+or@{bitwise\+\_\+or}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{bitwise\+\_\+or()}{bitwise\_or()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+bitwise\+\_\+or (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element bit-\/wise disjunction of two arrays or an array and a scalar.

The function calculates the per-\/element bit-\/wise logical disjunction for\+:


\begin{DoxyItemize}
\item Two arrays when {\ttfamily src1} and {\ttfamily src2} have the same size\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) V src2(\+I) if mask(\+I) != 0}


\begin{DoxyItemize}
\item An array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) V src2 if mask(\+I) != 0}


\begin{DoxyItemize}
\item A scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1 V src2(\+I) if mask(\+I) != 0}

In case of floating-\/point arrays, their machine-\/specific bit representations (usually I\+E\+E\+E754-\/compliant) are used for the operation. In case of multi-\/channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and type as the input arrays.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-or}{\tt org.\+opencv.\+core.\+Core.\+bitwise\+\_\+or} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ab45e6bad43761e254c58dcaefa401ff3}\label{classorg_1_1opencv_1_1core_1_1_core_ab45e6bad43761e254c58dcaefa401ff3}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!bitwise\+\_\+xor@{bitwise\+\_\+xor}}
\index{bitwise\+\_\+xor@{bitwise\+\_\+xor}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{bitwise\+\_\+xor()}{bitwise\_xor()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+bitwise\+\_\+xor (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element bit-\/wise \char`\"{}exclusive or\char`\"{} operation on two arrays or an array and a scalar.

The function calculates the per-\/element bit-\/wise logical \char`\"{}exclusive-\/or\char`\"{} operation for\+:


\begin{DoxyItemize}
\item Two arrays when {\ttfamily src1} and {\ttfamily src2} have the same size\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I)(+) src2(\+I) if mask(\+I) != 0}


\begin{DoxyItemize}
\item An array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I)(+) src2 if mask(\+I) != 0}


\begin{DoxyItemize}
\item A scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(+) src2(\+I) if mask(\+I) != 0}

In case of floating-\/point arrays, their machine-\/specific bit representations (usually I\+E\+E\+E754-\/compliant) are used for the operation. In case of multi-\/channel arrays, each channel is processed independently. In the 2nd and 3rd cases above, the scalar is first converted to the array type.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and type as the input arrays. \\
\hline
{\em mask} & optional operation mask, 8-\/bit single channel array, that specifies elements of the output array to be changed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-xor}{\tt org.\+opencv.\+core.\+Core.\+bitwise\+\_\+xor} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ac7f4b63e34cd4f8f9e4c570f36acf942}\label{classorg_1_1opencv_1_1core_1_1_core_ac7f4b63e34cd4f8f9e4c570f36acf942}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!bitwise\+\_\+xor@{bitwise\+\_\+xor}}
\index{bitwise\+\_\+xor@{bitwise\+\_\+xor}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{bitwise\+\_\+xor()}{bitwise\_xor()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+bitwise\+\_\+xor (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element bit-\/wise \char`\"{}exclusive or\char`\"{} operation on two arrays or an array and a scalar.

The function calculates the per-\/element bit-\/wise logical \char`\"{}exclusive-\/or\char`\"{} operation for\+:


\begin{DoxyItemize}
\item Two arrays when {\ttfamily src1} and {\ttfamily src2} have the same size\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I)(+) src2(\+I) if mask(\+I) != 0}


\begin{DoxyItemize}
\item An array and a scalar when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I)(+) src2 if mask(\+I) != 0}


\begin{DoxyItemize}
\item A scalar and an array when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(+) src2(\+I) if mask(\+I) != 0}

In case of floating-\/point arrays, their machine-\/specific bit representations (usually I\+E\+E\+E754-\/compliant) are used for the operation. In case of multi-\/channel arrays, each channel is processed independently. In the 2nd and 3rd cases above, the scalar is first converted to the array type.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array that has the same size and type as the input arrays.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#bitwise-xor}{\tt org.\+opencv.\+core.\+Core.\+bitwise\+\_\+xor} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_afebca901f30f80a2a6db7a67cc2afb0a}\label{classorg_1_1opencv_1_1core_1_1_core_afebca901f30f80a2a6db7a67cc2afb0a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!calc\+Covar\+Matrix@{calc\+Covar\+Matrix}}
\index{calc\+Covar\+Matrix@{calc\+Covar\+Matrix}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{calc\+Covar\+Matrix()}{calcCovarMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+calc\+Covar\+Matrix (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{samples,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{covar,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mean,  }\item[{int}]{flags,  }\item[{int}]{ctype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the covariance matrix of a set of vectors.

The functions {\ttfamily calc\+Covar\+Matrix} calculate the covariance matrix and, optionally, the mean vector of the set of input vectors.


\begin{DoxyParams}{Parameters}
{\em samples} & samples stored either as separate matrices or as rows/columns of a single matrix. \\
\hline
{\em covar} & output covariance matrix of the type {\ttfamily ctype} and square size. \\
\hline
{\em mean} & input or output (depending on the flags) array as the average value of the input vectors. \\
\hline
{\em flags} & operation flags as a combination of the following values\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+S\+C\+R\+A\+M\+B\+L\+ED The output covariance matrix is calculated as\+: 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


{\itshape scale $\ast$ \mbox{[} vects \mbox{[}0\mbox{]}-\/ mean, vects \mbox{[}1\mbox{]}-\/ mean,...\mbox{]}$^\wedge$T $\ast$ \mbox{[} vects \mbox{[}0\mbox{]}-\/ mean, vects \mbox{[}1\mbox{]}-\/ mean,...\mbox{]},}

The covariance matrix will be {\ttfamily nsamples x nsamples}. Such an unusual covariance matrix is used for fast P\+CA of a set of very large vectors (see, for example, the Eigen\+Faces technique for face recognition). Eigenvalues of this \char`\"{}scrambled\char`\"{} matrix match the eigenvalues of the true covariance matrix. The \char`\"{}true\char`\"{} eigenvectors can be easily calculated from the eigenvectors of the \char`\"{}scrambled\char`\"{} covariance matrix.


\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+N\+O\+R\+M\+AL The output covariance matrix is calculated as\+: 
\end{DoxyItemize}

{\itshape scale $\ast$ \mbox{[} vects \mbox{[}0\mbox{]}-\/ mean, vects \mbox{[}1\mbox{]}-\/ mean,...\mbox{]} $\ast$ \mbox{[} vects \mbox{[}0\mbox{]}-\/ mean, vects \mbox{[}1\mbox{]}-\/ mean,...\mbox{]}$^\wedge$T,}

{\ttfamily covar} will be a square matrix of the same size as the total number of elements in each input vector. One and only one of {\ttfamily C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+S\+C\+R\+A\+M\+B\+L\+ED} and {\ttfamily C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+N\+O\+R\+M\+AL} must be specified.


\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+U\+S\+E\+\_\+\+A\+VG If the flag is specified, the function does not calculate {\ttfamily mean} from the input vectors but, instead, uses the passed {\ttfamily mean} vector. This is useful if {\ttfamily mean} has been pre-\/calculated or known in advance, or if the covariance matrix is calculated by parts. In this case, {\ttfamily mean} is not a mean vector of the input sub-\/set of vectors but rather the mean vector of the whole set. 
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+S\+C\+A\+LE If the flag is specified, the covariance matrix is scaled. In the \char`\"{}normal\char`\"{} mode, {\ttfamily scale} is {\ttfamily 1./nsamples}. In the \char`\"{}scrambled\char`\"{} mode, {\ttfamily scale} is the reciprocal of the total number of elements in each input vector. By default (if the flag is not specified), the covariance matrix is not scaled ({\ttfamily scale=1}). 
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+R\+O\+WS \mbox{[}Only useful in the second variant of the function\mbox{]} If the flag is specified, all the input vectors are stored as rows of the {\ttfamily samples} matrix. {\ttfamily mean} should be a single-\/row vector in this case. 
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+C\+O\+LS \mbox{[}Only useful in the second variant of the function\mbox{]} If the flag is specified, all the input vectors are stored as columns of the {\ttfamily samples} matrix. {\ttfamily mean} should be a single-\/column vector in this case. 
\end{DoxyItemize}
\begin{DoxyParams}{Parameters}
{\em ctype} & type of the matrixl; it equals \textquotesingle{}C\+V\+\_\+64F\textquotesingle{} by default.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#calccovarmatrix}{\tt org.\+opencv.\+core.\+Core.\+calc\+Covar\+Matrix} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae6da41381cc2fc87daa1a14a2c476781}{org.\+opencv.\+core.\+Core\+::\+Mahalanobis}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aecfddbae696272a338eb12056603d4e9}{org.\+opencv.\+core.\+Core\+::mul\+Transposed}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ac9a38bf2bcad4daa87e017dceb927bc3}\label{classorg_1_1opencv_1_1core_1_1_core_ac9a38bf2bcad4daa87e017dceb927bc3}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!calc\+Covar\+Matrix@{calc\+Covar\+Matrix}}
\index{calc\+Covar\+Matrix@{calc\+Covar\+Matrix}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{calc\+Covar\+Matrix()}{calcCovarMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+calc\+Covar\+Matrix (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{samples,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{covar,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mean,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the covariance matrix of a set of vectors.

The functions {\ttfamily calc\+Covar\+Matrix} calculate the covariance matrix and, optionally, the mean vector of the set of input vectors.


\begin{DoxyParams}{Parameters}
{\em samples} & samples stored either as separate matrices or as rows/columns of a single matrix. \\
\hline
{\em covar} & output covariance matrix of the type {\ttfamily ctype} and square size. \\
\hline
{\em mean} & input or output (depending on the flags) array as the average value of the input vectors. \\
\hline
{\em flags} & operation flags as a combination of the following values\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+S\+C\+R\+A\+M\+B\+L\+ED The output covariance matrix is calculated as\+: 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


{\itshape scale $\ast$ \mbox{[} vects \mbox{[}0\mbox{]}-\/ mean, vects \mbox{[}1\mbox{]}-\/ mean,...\mbox{]}$^\wedge$T $\ast$ \mbox{[} vects \mbox{[}0\mbox{]}-\/ mean, vects \mbox{[}1\mbox{]}-\/ mean,...\mbox{]},}

The covariance matrix will be {\ttfamily nsamples x nsamples}. Such an unusual covariance matrix is used for fast P\+CA of a set of very large vectors (see, for example, the Eigen\+Faces technique for face recognition). Eigenvalues of this \char`\"{}scrambled\char`\"{} matrix match the eigenvalues of the true covariance matrix. The \char`\"{}true\char`\"{} eigenvectors can be easily calculated from the eigenvectors of the \char`\"{}scrambled\char`\"{} covariance matrix.


\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+N\+O\+R\+M\+AL The output covariance matrix is calculated as\+: 
\end{DoxyItemize}

{\itshape scale $\ast$ \mbox{[} vects \mbox{[}0\mbox{]}-\/ mean, vects \mbox{[}1\mbox{]}-\/ mean,...\mbox{]} $\ast$ \mbox{[} vects \mbox{[}0\mbox{]}-\/ mean, vects \mbox{[}1\mbox{]}-\/ mean,...\mbox{]}$^\wedge$T,}

{\ttfamily covar} will be a square matrix of the same size as the total number of elements in each input vector. One and only one of {\ttfamily C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+S\+C\+R\+A\+M\+B\+L\+ED} and {\ttfamily C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+N\+O\+R\+M\+AL} must be specified.


\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+U\+S\+E\+\_\+\+A\+VG If the flag is specified, the function does not calculate {\ttfamily mean} from the input vectors but, instead, uses the passed {\ttfamily mean} vector. This is useful if {\ttfamily mean} has been pre-\/calculated or known in advance, or if the covariance matrix is calculated by parts. In this case, {\ttfamily mean} is not a mean vector of the input sub-\/set of vectors but rather the mean vector of the whole set. 
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+S\+C\+A\+LE If the flag is specified, the covariance matrix is scaled. In the \char`\"{}normal\char`\"{} mode, {\ttfamily scale} is {\ttfamily 1./nsamples}. In the \char`\"{}scrambled\char`\"{} mode, {\ttfamily scale} is the reciprocal of the total number of elements in each input vector. By default (if the flag is not specified), the covariance matrix is not scaled ({\ttfamily scale=1}). 
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+R\+O\+WS \mbox{[}Only useful in the second variant of the function\mbox{]} If the flag is specified, all the input vectors are stored as rows of the {\ttfamily samples} matrix. {\ttfamily mean} should be a single-\/row vector in this case. 
\item C\+V\+\_\+\+C\+O\+V\+A\+R\+\_\+\+C\+O\+LS \mbox{[}Only useful in the second variant of the function\mbox{]} If the flag is specified, all the input vectors are stored as columns of the {\ttfamily samples} matrix. {\ttfamily mean} should be a single-\/column vector in this case. 
\end{DoxyItemize}

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#calccovarmatrix}{\tt org.\+opencv.\+core.\+Core.\+calc\+Covar\+Matrix} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae6da41381cc2fc87daa1a14a2c476781}{org.\+opencv.\+core.\+Core\+::\+Mahalanobis}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aecfddbae696272a338eb12056603d4e9}{org.\+opencv.\+core.\+Core\+::mul\+Transposed}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}\label{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!cart\+To\+Polar@{cart\+To\+Polar}}
\index{cart\+To\+Polar@{cart\+To\+Polar}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{cart\+To\+Polar()}{cartToPolar()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+cart\+To\+Polar (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{x,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{y,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{magnitude,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{angle,  }\item[{boolean}]{angle\+In\+Degrees }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the magnitude and angle of 2D vectors.

The function {\ttfamily cart\+To\+Polar} calculates either the magnitude, angle, or both for every 2D vector (x(\+I),y(\+I))\+:

{\itshape magnitude(\+I)= sqrt(x(\+I)$^\wedge$2+y(I)$^\wedge$2), angle(\+I)= atan2(y(\+I), x(\+I))\mbox{[} $\ast$180 / pi \mbox{]} }

The angles are calculated with accuracy about 0.\+3 degrees. For the point (0,0), the angle is set to 0.


\begin{DoxyParams}{Parameters}
{\em x} & array of x-\/coordinates; this must be a single-\/precision or double-\/precision floating-\/point array. \\
\hline
{\em y} & array of y-\/coordinates, that must have the same size and same type as {\ttfamily x}. \\
\hline
{\em magnitude} & output array of magnitudes of the same size and type as {\ttfamily x}. \\
\hline
{\em angle} & output array of angles that has the same size and type as {\ttfamily x}; the angles are measured in radians (from 0 to 2$\ast$\+Pi) or in degrees (0 to 360 degrees). \\
\hline
{\em angle\+In\+Degrees} & a flag, indicating whether the angles are measured in radians (which is by default), or in degrees.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#carttopolar}{\tt org.\+opencv.\+core.\+Core.\+cart\+To\+Polar} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c9e2fdd65ecd76ae9135e33cfb9a99}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Scharr}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a85a8cac062c05efeecf99de50f3ab8d7}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Sobel}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a6bb86bd8157b4d8561b29e288445a6c9}\label{classorg_1_1opencv_1_1core_1_1_core_a6bb86bd8157b4d8561b29e288445a6c9}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!cart\+To\+Polar@{cart\+To\+Polar}}
\index{cart\+To\+Polar@{cart\+To\+Polar}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{cart\+To\+Polar()}{cartToPolar()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+cart\+To\+Polar (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{x,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{y,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{magnitude,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{angle }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the magnitude and angle of 2D vectors.

The function {\ttfamily cart\+To\+Polar} calculates either the magnitude, angle, or both for every 2D vector (x(\+I),y(\+I))\+:

{\itshape magnitude(\+I)= sqrt(x(\+I)$^\wedge$2+y(I)$^\wedge$2), angle(\+I)= atan2(y(\+I), x(\+I))\mbox{[} $\ast$180 / pi \mbox{]} }

The angles are calculated with accuracy about 0.\+3 degrees. For the point (0,0), the angle is set to 0.


\begin{DoxyParams}{Parameters}
{\em x} & array of x-\/coordinates; this must be a single-\/precision or double-\/precision floating-\/point array. \\
\hline
{\em y} & array of y-\/coordinates, that must have the same size and same type as {\ttfamily x}. \\
\hline
{\em magnitude} & output array of magnitudes of the same size and type as {\ttfamily x}. \\
\hline
{\em angle} & output array of angles that has the same size and type as {\ttfamily x}; the angles are measured in radians (from 0 to 2$\ast$\+Pi) or in degrees (0 to 360 degrees).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#carttopolar}{\tt org.\+opencv.\+core.\+Core.\+cart\+To\+Polar} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c9e2fdd65ecd76ae9135e33cfb9a99}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Scharr}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a85a8cac062c05efeecf99de50f3ab8d7}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Sobel}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a2260f7346beb98771f860e39e4b4a924}\label{classorg_1_1opencv_1_1core_1_1_core_a2260f7346beb98771f860e39e4b4a924}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!check\+Range@{check\+Range}}
\index{check\+Range@{check\+Range}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{check\+Range()}{checkRange()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+core.\+Core.\+check\+Range (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{a,  }\item[{boolean}]{quiet,  }\item[{double}]{min\+Val,  }\item[{double}]{max\+Val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Checks every element of an input array for invalid values.

The functions {\ttfamily check\+Range} check that every array element is neither NaN nor infinite. When {\ttfamily min\+Val $<$ -\/\+D\+B\+L\+\_\+\+M\+AX} and {\ttfamily max\+Val $<$ D\+B\+L\+\_\+\+M\+AX}, the functions also check that each value is between {\ttfamily min\+Val} and {\ttfamily max\+Val}. In case of multi-\/channel arrays, each channel is processed independently. If some values are out of range, position of the first outlier is stored in {\ttfamily pos} (when {\ttfamily pos != N\+U\+LL}). Then, the functions either return false (when {\ttfamily quiet=true}) or throw an exception.


\begin{DoxyParams}{Parameters}
{\em a} & input array. \\
\hline
{\em quiet} & a flag, indicating whether the functions quietly return false when the array elements are out of range or they throw an exception. \\
\hline
{\em min\+Val} & inclusive lower boundary of valid values range. \\
\hline
{\em max\+Val} & exclusive upper boundary of valid values range.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#checkrange}{\tt org.\+opencv.\+core.\+Core.\+check\+Range} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a5eca29b5a4b3eb63f1a549970847dfcd}\label{classorg_1_1opencv_1_1core_1_1_core_a5eca29b5a4b3eb63f1a549970847dfcd}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!check\+Range@{check\+Range}}
\index{check\+Range@{check\+Range}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{check\+Range()}{checkRange()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+core.\+Core.\+check\+Range (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{a }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Checks every element of an input array for invalid values.

The functions {\ttfamily check\+Range} check that every array element is neither NaN nor infinite. When {\ttfamily min\+Val $<$ -\/\+D\+B\+L\+\_\+\+M\+AX} and {\ttfamily max\+Val $<$ D\+B\+L\+\_\+\+M\+AX}, the functions also check that each value is between {\ttfamily min\+Val} and {\ttfamily max\+Val}. In case of multi-\/channel arrays, each channel is processed independently. If some values are out of range, position of the first outlier is stored in {\ttfamily pos} (when {\ttfamily pos != N\+U\+LL}). Then, the functions either return false (when {\ttfamily quiet=true}) or throw an exception.


\begin{DoxyParams}{Parameters}
{\em a} & input array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#checkrange}{\tt org.\+opencv.\+core.\+Core.\+check\+Range} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aa0f688f66d937f5952cb9f1db6f43326}\label{classorg_1_1opencv_1_1core_1_1_core_aa0f688f66d937f5952cb9f1db6f43326}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!circle@{circle}}
\index{circle@{circle}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{circle()}{circle()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+circle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{center,  }\item[{int}]{radius,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness,  }\item[{int}]{line\+Type,  }\item[{int}]{shift }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a circle.

The function {\ttfamily circle} draws a simple or filled circle with a given center and radius.


\begin{DoxyParams}{Parameters}
{\em img} & Image where the circle is drawn. \\
\hline
{\em center} & Center of the circle. \\
\hline
{\em radius} & Radius of the circle. \\
\hline
{\em color} & Circle color. \\
\hline
{\em thickness} & Thickness of the circle outline, if positive. Negative thickness means that a filled circle is to be drawn. \\
\hline
{\em line\+Type} & Type of the circle boundary. See the \char`\"{}line\char`\"{} description. \\
\hline
{\em shift} & Number of fractional bits in the coordinates of the center and in the radius value.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#circle}{\tt org.\+opencv.\+core.\+Core.\+circle} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a205ea116055f6a84cc6c9d0409df0adc}\label{classorg_1_1opencv_1_1core_1_1_core_a205ea116055f6a84cc6c9d0409df0adc}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!circle@{circle}}
\index{circle@{circle}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{circle()}{circle()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+circle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{center,  }\item[{int}]{radius,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a circle.

The function {\ttfamily circle} draws a simple or filled circle with a given center and radius.


\begin{DoxyParams}{Parameters}
{\em img} & Image where the circle is drawn. \\
\hline
{\em center} & Center of the circle. \\
\hline
{\em radius} & Radius of the circle. \\
\hline
{\em color} & Circle color. \\
\hline
{\em thickness} & Thickness of the circle outline, if positive. Negative thickness means that a filled circle is to be drawn.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#circle}{\tt org.\+opencv.\+core.\+Core.\+circle} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a55df53a3f36b33188cb2e5cfa385ffbc}\label{classorg_1_1opencv_1_1core_1_1_core_a55df53a3f36b33188cb2e5cfa385ffbc}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!circle@{circle}}
\index{circle@{circle}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{circle()}{circle()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+circle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{center,  }\item[{int}]{radius,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a circle.

The function {\ttfamily circle} draws a simple or filled circle with a given center and radius.


\begin{DoxyParams}{Parameters}
{\em img} & Image where the circle is drawn. \\
\hline
{\em center} & Center of the circle. \\
\hline
{\em radius} & Radius of the circle. \\
\hline
{\em color} & Circle color.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#circle}{\tt org.\+opencv.\+core.\+Core.\+circle} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a73c128fa46a560c0e998791dd5cf890a}\label{classorg_1_1opencv_1_1core_1_1_core_a73c128fa46a560c0e998791dd5cf890a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!clip\+Line@{clip\+Line}}
\index{clip\+Line@{clip\+Line}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{clip\+Line()}{clipLine()}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+core.\+Core.\+clip\+Line (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{img\+Rect,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Clips the line against the image rectangle.

The functions {\ttfamily clip\+Line} calculate a part of the line segment that is entirely within the specified rectangle. They return {\ttfamily false} if the line segment is completely outside the rectangle. Otherwise, they return {\ttfamily true}.


\begin{DoxyParams}{Parameters}
{\em img\+Rect} & Image rectangle. \\
\hline
{\em pt1} & First line point. \\
\hline
{\em pt2} & Second line point.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#clipline}{\tt org.\+opencv.\+core.\+Core.\+clip\+Line} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a6f1dc64655b7da1219d82f809efb7e16}\label{classorg_1_1opencv_1_1core_1_1_core_a6f1dc64655b7da1219d82f809efb7e16}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!compare@{compare}}
\index{compare@{compare}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{compare()}{compare()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+compare (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{cmpop }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs the per-\/element comparison of two arrays or an array and scalar value.

The function compares\+:


\begin{DoxyItemize}
\item Elements of two arrays when {\ttfamily src1} and {\ttfamily src2} have the same size\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) cmpop src2(\+I)}


\begin{DoxyItemize}
\item Elements of {\ttfamily src1} with a scalar {\ttfamily src2} when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has a single element\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) cmpop src2}


\begin{DoxyItemize}
\item {\ttfamily src1} with elements of {\ttfamily src2} when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has a single element\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1 cmpop src2(\+I)}

When the comparison result is true, the corresponding element of output array is set to 255.\+The comparison operations can be replaced with the equivalent matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst1 = src1 $>$= src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst2 = src1 $<$ 8;...}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar (in the case of {\ttfamily cv\+Cmp}, {\ttfamily cv.\+Cmp}, {\ttfamily cv\+CmpS}, {\ttfamily cv.\+CmpS} it is always an array); when it is an array, it must have a single channel. \\
\hline
{\em src2} & second input array or a scalar (in the case of {\ttfamily cv\+Cmp} and {\ttfamily cv.\+Cmp} it is always an array; in the case of {\ttfamily cv\+CmpS}, {\ttfamily cv.\+CmpS} it is always a scalar); when it is an array, it must have a single channel. \\
\hline
{\em dst} & output array that has the same size and type as the input arrays. \\
\hline
{\em cmpop} & a flag, that specifies correspondence between the arrays\+: 
\begin{DoxyItemize}
\item C\+M\+P\+\_\+\+EQ {\ttfamily src1} is equal to {\ttfamily src2}. 
\item C\+M\+P\+\_\+\+GT {\ttfamily src1} is greater than {\ttfamily src2}. 
\item C\+M\+P\+\_\+\+GE {\ttfamily src1} is greater than or equal to {\ttfamily src2}. 
\item C\+M\+P\+\_\+\+LT {\ttfamily src1} is less than {\ttfamily src2}. 
\item C\+M\+P\+\_\+\+LE {\ttfamily src1} is less than or equal to {\ttfamily src2}. 
\item C\+M\+P\+\_\+\+NE {\ttfamily src1} is unequal to {\ttfamily src2}. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#compare}{\tt org.\+opencv.\+core.\+Core.\+compare} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a428d1896f05ae5e0eadbe9a1489e6368}{org.\+opencv.\+imgproc.\+Imgproc\+::threshold}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aae8ad4feaca1ca8234bd88cbf9090cf5}{org.\+opencv.\+core.\+Core\+::max}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a2260f7346beb98771f860e39e4b4a924}{org.\+opencv.\+core.\+Core\+::check\+Range}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a24561bfde2c7fe7d2b7bee9d5ba8c92e}{org.\+opencv.\+core.\+Core\+::min}} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ab8d00dae0089e28d72949594e63ccc18}\label{classorg_1_1opencv_1_1core_1_1_core_ab8d00dae0089e28d72949594e63ccc18}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!compare@{compare}}
\index{compare@{compare}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{compare()}{compare()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+compare (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{cmpop }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs the per-\/element comparison of two arrays or an array and scalar value.

The function compares\+:


\begin{DoxyItemize}
\item Elements of two arrays when {\ttfamily src1} and {\ttfamily src2} have the same size\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) cmpop src2(\+I)}


\begin{DoxyItemize}
\item Elements of {\ttfamily src1} with a scalar {\ttfamily src2} when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has a single element\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1(\+I) cmpop src2}


\begin{DoxyItemize}
\item {\ttfamily src1} with elements of {\ttfamily src2} when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has a single element\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = src1 cmpop src2(\+I)}

When the comparison result is true, the corresponding element of output array is set to 255.\+The comparison operations can be replaced with the equivalent matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst1 = src1 $>$= src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst2 = src1 $<$ 8;...}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar (in the case of {\ttfamily cv\+Cmp}, {\ttfamily cv.\+Cmp}, {\ttfamily cv\+CmpS}, {\ttfamily cv.\+CmpS} it is always an array); when it is an array, it must have a single channel. \\
\hline
{\em src2} & second input array or a scalar (in the case of {\ttfamily cv\+Cmp} and {\ttfamily cv.\+Cmp} it is always an array; in the case of {\ttfamily cv\+CmpS}, {\ttfamily cv.\+CmpS} it is always a scalar); when it is an array, it must have a single channel. \\
\hline
{\em dst} & output array that has the same size and type as the input arrays. \\
\hline
{\em cmpop} & a flag, that specifies correspondence between the arrays\+: 
\begin{DoxyItemize}
\item C\+M\+P\+\_\+\+EQ {\ttfamily src1} is equal to {\ttfamily src2}. 
\item C\+M\+P\+\_\+\+GT {\ttfamily src1} is greater than {\ttfamily src2}. 
\item C\+M\+P\+\_\+\+GE {\ttfamily src1} is greater than or equal to {\ttfamily src2}. 
\item C\+M\+P\+\_\+\+LT {\ttfamily src1} is less than {\ttfamily src2}. 
\item C\+M\+P\+\_\+\+LE {\ttfamily src1} is less than or equal to {\ttfamily src2}. 
\item C\+M\+P\+\_\+\+NE {\ttfamily src1} is unequal to {\ttfamily src2}. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#compare}{\tt org.\+opencv.\+core.\+Core.\+compare} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a428d1896f05ae5e0eadbe9a1489e6368}{org.\+opencv.\+imgproc.\+Imgproc\+::threshold}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aae8ad4feaca1ca8234bd88cbf9090cf5}{org.\+opencv.\+core.\+Core\+::max}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a2260f7346beb98771f860e39e4b4a924}{org.\+opencv.\+core.\+Core\+::check\+Range}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a24561bfde2c7fe7d2b7bee9d5ba8c92e}{org.\+opencv.\+core.\+Core\+::min}} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ad3a0199c2b0bbc9d254768b566fd257e}\label{classorg_1_1opencv_1_1core_1_1_core_ad3a0199c2b0bbc9d254768b566fd257e}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!complete\+Symm@{complete\+Symm}}
\index{complete\+Symm@{complete\+Symm}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{complete\+Symm()}{completeSymm()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+complete\+Symm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mtx,  }\item[{boolean}]{lower\+To\+Upper }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Copies the lower or the upper half of a square matrix to another half.

The function {\ttfamily complete\+Symm} copies the lower half of a square matrix to its another half. The matrix diagonal remains unchanged\+:


\begin{DoxyItemize}
\item {\itshape mtx\+\_\+(ij)=mtx\+\_\+(ji)} for {\itshape i \&gt j} if {\ttfamily lower\+To\+Upper=false} 
\item {\itshape mtx\+\_\+(ij)=mtx\+\_\+(ji)} for {\itshape i \&lt j} if {\ttfamily lower\+To\+Upper=true} 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em mtx} & input-\/output floating-\/point square matrix. \\
\hline
{\em lower\+To\+Upper} & operation flag; if true, the lower half is copied to the upper half. Otherwise, the upper half is copied to the lower half.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#completesymm}{\tt org.\+opencv.\+core.\+Core.\+complete\+Symm} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4536de6a43f5dfb4d4ba1bf24735696a}{org.\+opencv.\+core.\+Core\+::transpose}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8dc68bbfca84b4fdfb9cd7bd79fc893e}{org.\+opencv.\+core.\+Core\+::flip}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a57f226ca886a32a25619bd0eb17df076}\label{classorg_1_1opencv_1_1core_1_1_core_a57f226ca886a32a25619bd0eb17df076}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!complete\+Symm@{complete\+Symm}}
\index{complete\+Symm@{complete\+Symm}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{complete\+Symm()}{completeSymm()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+complete\+Symm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mtx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Copies the lower or the upper half of a square matrix to another half.

The function {\ttfamily complete\+Symm} copies the lower half of a square matrix to its another half. The matrix diagonal remains unchanged\+:


\begin{DoxyItemize}
\item {\itshape mtx\+\_\+(ij)=mtx\+\_\+(ji)} for {\itshape i \&gt j} if {\ttfamily lower\+To\+Upper=false} 
\item {\itshape mtx\+\_\+(ij)=mtx\+\_\+(ji)} for {\itshape i \&lt j} if {\ttfamily lower\+To\+Upper=true} 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em mtx} & input-\/output floating-\/point square matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#completesymm}{\tt org.\+opencv.\+core.\+Core.\+complete\+Symm} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4536de6a43f5dfb4d4ba1bf24735696a}{org.\+opencv.\+core.\+Core\+::transpose}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8dc68bbfca84b4fdfb9cd7bd79fc893e}{org.\+opencv.\+core.\+Core\+::flip}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a42f107c63200e26f87ddb11631980be7}\label{classorg_1_1opencv_1_1core_1_1_core_a42f107c63200e26f87ddb11631980be7}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!convert\+Scale\+Abs@{convert\+Scale\+Abs}}
\index{convert\+Scale\+Abs@{convert\+Scale\+Abs}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{convert\+Scale\+Abs()}{convertScaleAbs()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+convert\+Scale\+Abs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{alpha,  }\item[{double}]{beta }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Scales, calculates absolute values, and converts the result to 8-\/bit.

On each element of the input array, the function {\ttfamily convert\+Scale\+Abs} performs three operations sequentially\+: scaling, taking an absolute value, conversion to an unsigned 8-\/bit type\+:

{\itshape dst(\+I)= saturate\+\_\+cast\&ltuchar\&gt($\vert$ src(\+I)$\ast$ alpha + beta$\vert$)\&lt\+BR\&gt\+In case of multi-\/channel arrays, the function processes each channel independently. When the output is not 8-\/bit, the operation can be emulated by calling the {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{Mat.\+convert\+To}}} method(or by using matrix expressions) and then by calculating an absolute value of the result. For example\+: \&lt\+BR\&gt\&ltcode\&gt}

// C++ code\+:

Mat\+\_\+$<$float$>$ A(30,30);

randu(A, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}(-\/100), Scalar(100));

Mat\+\_\+$<$float$>$ B = A$\ast$5 + 3;

B = abs(\+B);

// Mat\+\_\+$<$float$>$ B = abs(A$\ast$5+3) will also do the job,

// but it will allocate a temporary matrix


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array. \\
\hline
{\em alpha} & optional scale factor. \\
\hline
{\em beta} & optional delta added to the scaled values.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#convertscaleabs}{\tt org.\+opencv.\+core.\+Core.\+convert\+Scale\+Abs} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_adc3cd8b03f5b39cb0d795dddd43e2e16}\label{classorg_1_1opencv_1_1core_1_1_core_adc3cd8b03f5b39cb0d795dddd43e2e16}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!convert\+Scale\+Abs@{convert\+Scale\+Abs}}
\index{convert\+Scale\+Abs@{convert\+Scale\+Abs}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{convert\+Scale\+Abs()}{convertScaleAbs()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+convert\+Scale\+Abs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Scales, calculates absolute values, and converts the result to 8-\/bit.

On each element of the input array, the function {\ttfamily convert\+Scale\+Abs} performs three operations sequentially\+: scaling, taking an absolute value, conversion to an unsigned 8-\/bit type\+:

{\itshape dst(\+I)= saturate\+\_\+cast\&ltuchar\&gt($\vert$ src(\+I)$\ast$ alpha + beta$\vert$)\&lt\+BR\&gt\+In case of multi-\/channel arrays, the function processes each channel independently. When the output is not 8-\/bit, the operation can be emulated by calling the {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{Mat.\+convert\+To}}} method(or by using matrix expressions) and then by calculating an absolute value of the result. For example\+: \&lt\+BR\&gt\&ltcode\&gt}

// C++ code\+:

Mat\+\_\+$<$float$>$ A(30,30);

randu(A, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}(-\/100), Scalar(100));

Mat\+\_\+$<$float$>$ B = A$\ast$5 + 3;

B = abs(\+B);

// Mat\+\_\+$<$float$>$ B = abs(A$\ast$5+3) will also do the job,

// but it will allocate a temporary matrix


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#convertscaleabs}{\tt org.\+opencv.\+core.\+Core.\+convert\+Scale\+Abs} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a216308f36e765f82c521087fe283e045}\label{classorg_1_1opencv_1_1core_1_1_core_a216308f36e765f82c521087fe283e045}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!count\+Non\+Zero@{count\+Non\+Zero}}
\index{count\+Non\+Zero@{count\+Non\+Zero}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{count\+Non\+Zero()}{countNonZero()}}
{\footnotesize\ttfamily static int org.\+opencv.\+core.\+Core.\+count\+Non\+Zero (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Counts non-\/zero array elements.

The function returns the number of non-\/zero elements in {\ttfamily src} \+:

{\itshape sum(by\+: I\+: src(\+I) != 0) 1}


\begin{DoxyParams}{Parameters}
{\em src} & single-\/channel array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#countnonzero}{\tt org.\+opencv.\+core.\+Core.\+count\+Non\+Zero} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}{org.\+opencv.\+core.\+Core\+::min\+Max\+Loc}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afebca901f30f80a2a6db7a67cc2afb0a}{org.\+opencv.\+core.\+Core\+::calc\+Covar\+Matrix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af8d7fbb33c11fbf6115d4c242dbbb5b3}{org.\+opencv.\+core.\+Core\+::mean\+Std\+Dev}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}{org.\+opencv.\+core.\+Core\+::norm}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{org.\+opencv.\+core.\+Core\+::mean}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a08e2ce54e07e80ac946866bf205d9333}\label{classorg_1_1opencv_1_1core_1_1_core_a08e2ce54e07e80ac946866bf205d9333}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!cube\+Root@{cube\+Root}}
\index{cube\+Root@{cube\+Root}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{cube\+Root()}{cubeRoot()}}
{\footnotesize\ttfamily static float org.\+opencv.\+core.\+Core.\+cube\+Root (\begin{DoxyParamCaption}\item[{float}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes the cube root of an argument.

The function {\ttfamily cube\+Root} computes {\itshape sqrt3(val)}. Negative arguments are handled correctly. NaN and Inf are not handled. The accuracy approaches the maximum possible accuracy for single-\/precision data.


\begin{DoxyParams}{Parameters}
{\em val} & A function argument.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#cuberoot}{\tt org.\+opencv.\+core.\+Core.\+cube\+Root} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a1f0b3c28295d4db1ecd755201833d6cb}\label{classorg_1_1opencv_1_1core_1_1_core_a1f0b3c28295d4db1ecd755201833d6cb}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!dct@{dct}}
\index{dct@{dct}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{dct()}{dct()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+dct (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs a forward or inverse discrete Cosine transform of 1D or 2D array.

The function {\ttfamily dct} performs a forward or inverse discrete Cosine transform (D\+CT) of a 1D or 2D floating-\/point array\+:


\begin{DoxyItemize}
\item Forward Cosine transform of a 1D vector of {\ttfamily N} elements\+: 
\end{DoxyItemize}

{\itshape Y = C$^\wedge$N $\ast$ X}

where

{\itshape C$^\wedge$\+N\+\_\+(jk)= sqrt(alpha\+\_\+j/N) cos((pi(2k+1)j)/(2N))}

and

{\itshape alpha\+\_\+0=1}, {\itshape alpha\+\_\+j=2} for {\itshape j $>$ 0}.


\begin{DoxyItemize}
\item Inverse Cosine transform of a 1D vector of {\ttfamily N} elements\+: 
\end{DoxyItemize}

{\itshape X = (C$^\wedge$N)$^\wedge$(-\/1) $\ast$ Y = (C$^\wedge$N)$^\wedge$T $\ast$ Y}

(since {\itshape C$^\wedge$N} is an orthogonal matrix, {\itshape C$^\wedge$N $\ast$ (C$^\wedge$N)$^\wedge$T = I})


\begin{DoxyItemize}
\item Forward 2D Cosine transform of {\ttfamily M x N} matrix\+: 
\end{DoxyItemize}

{\itshape Y = C$^\wedge$N $\ast$ X $\ast$ (C$^\wedge$N)$^\wedge$T}


\begin{DoxyItemize}
\item Inverse 2D Cosine transform of {\ttfamily M x N} matrix\+: 
\end{DoxyItemize}

{\itshape X = (C$^\wedge$N)$^\wedge$T $\ast$ X $\ast$ C$^\wedge$N}

The function chooses the mode of operation by looking at the flags and size of the input array\+:


\begin{DoxyItemize}
\item If {\ttfamily (flags \& D\+C\+T\+\_\+\+I\+N\+V\+E\+R\+SE) == 0}, the function does a forward 1D or 2D transform. Otherwise, it is an inverse 1D or 2D transform. 
\item If {\ttfamily (flags \& D\+C\+T\+\_\+\+R\+O\+WS) != 0}, the function performs a 1D transform of each row. 
\item If the array is a single column or a single row, the function performs a 1D transform. 
\item If none of the above is true, the function performs a 2D transform. 
\end{DoxyItemize}

Note\+:

Currently {\ttfamily dct} supports even-\/size arrays (2, 4, 6...). For data analysis and approximation, you can pad the array when necessary.

Also, the function performance depends very much, and not monotonically, on the array size (see\char`\"{}get\+Optimal\+D\+F\+T\+Size\char`\"{}). In the current implementation D\+CT of a vector of size {\ttfamily N} is calculated via D\+FT of a vector of size {\ttfamily N/2}. Thus, the optimal D\+CT size {\ttfamily N1 $>$= N} can be calculated as\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily size\+\_\+t get\+Optimal\+D\+C\+T\+Size(size\+\_\+t N) \{ return 2$\ast$get\+Optimal\+D\+F\+T\+Size((N+1)/2); \}}

{\ttfamily }

{\ttfamily }

{\ttfamily N1 = get\+Optimal\+D\+C\+T\+Size(\+N);}

{\ttfamily }

{\ttfamily }

{\ttfamily }


\begin{DoxyParams}{Parameters}
{\em src} & input floating-\/point array. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}. \\
\hline
{\em flags} & transformation flags as a combination of the following values\+: 
\begin{DoxyItemize}
\item D\+C\+T\+\_\+\+I\+N\+V\+E\+R\+SE performs an inverse 1D or 2D transform instead of the default forward transform. 
\item D\+C\+T\+\_\+\+R\+O\+WS performs a forward or inverse transform of every individual row of the input matrix. This flag enables you to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself) to perform 3D and higher-\/dimensional transforms and so forth. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#dct}{\tt org.\+opencv.\+core.\+Core.\+dct} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a64eb690877f2d4ac16c1b1c3375c0b7b}{org.\+opencv.\+core.\+Core\+::idct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}{org.\+opencv.\+core.\+Core\+::get\+Optimal\+D\+F\+T\+Size}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ab3eb0749baa205b6ae4c7af183c57177}\label{classorg_1_1opencv_1_1core_1_1_core_ab3eb0749baa205b6ae4c7af183c57177}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!dct@{dct}}
\index{dct@{dct}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{dct()}{dct()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+dct (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs a forward or inverse discrete Cosine transform of 1D or 2D array.

The function {\ttfamily dct} performs a forward or inverse discrete Cosine transform (D\+CT) of a 1D or 2D floating-\/point array\+:


\begin{DoxyItemize}
\item Forward Cosine transform of a 1D vector of {\ttfamily N} elements\+: 
\end{DoxyItemize}

{\itshape Y = C$^\wedge$N $\ast$ X}

where

{\itshape C$^\wedge$\+N\+\_\+(jk)= sqrt(alpha\+\_\+j/N) cos((pi(2k+1)j)/(2N))}

and

{\itshape alpha\+\_\+0=1}, {\itshape alpha\+\_\+j=2} for {\itshape j $>$ 0}.


\begin{DoxyItemize}
\item Inverse Cosine transform of a 1D vector of {\ttfamily N} elements\+: 
\end{DoxyItemize}

{\itshape X = (C$^\wedge$N)$^\wedge$(-\/1) $\ast$ Y = (C$^\wedge$N)$^\wedge$T $\ast$ Y}

(since {\itshape C$^\wedge$N} is an orthogonal matrix, {\itshape C$^\wedge$N $\ast$ (C$^\wedge$N)$^\wedge$T = I})


\begin{DoxyItemize}
\item Forward 2D Cosine transform of {\ttfamily M x N} matrix\+: 
\end{DoxyItemize}

{\itshape Y = C$^\wedge$N $\ast$ X $\ast$ (C$^\wedge$N)$^\wedge$T}


\begin{DoxyItemize}
\item Inverse 2D Cosine transform of {\ttfamily M x N} matrix\+: 
\end{DoxyItemize}

{\itshape X = (C$^\wedge$N)$^\wedge$T $\ast$ X $\ast$ C$^\wedge$N}

The function chooses the mode of operation by looking at the flags and size of the input array\+:


\begin{DoxyItemize}
\item If {\ttfamily (flags \& D\+C\+T\+\_\+\+I\+N\+V\+E\+R\+SE) == 0}, the function does a forward 1D or 2D transform. Otherwise, it is an inverse 1D or 2D transform. 
\item If {\ttfamily (flags \& D\+C\+T\+\_\+\+R\+O\+WS) != 0}, the function performs a 1D transform of each row. 
\item If the array is a single column or a single row, the function performs a 1D transform. 
\item If none of the above is true, the function performs a 2D transform. 
\end{DoxyItemize}

Note\+:

Currently {\ttfamily dct} supports even-\/size arrays (2, 4, 6...). For data analysis and approximation, you can pad the array when necessary.

Also, the function performance depends very much, and not monotonically, on the array size (see\char`\"{}get\+Optimal\+D\+F\+T\+Size\char`\"{}). In the current implementation D\+CT of a vector of size {\ttfamily N} is calculated via D\+FT of a vector of size {\ttfamily N/2}. Thus, the optimal D\+CT size {\ttfamily N1 $>$= N} can be calculated as\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily size\+\_\+t get\+Optimal\+D\+C\+T\+Size(size\+\_\+t N) \{ return 2$\ast$get\+Optimal\+D\+F\+T\+Size((N+1)/2); \}}

{\ttfamily }

{\ttfamily }

{\ttfamily N1 = get\+Optimal\+D\+C\+T\+Size(\+N);}

{\ttfamily }

{\ttfamily }

{\ttfamily }


\begin{DoxyParams}{Parameters}
{\em src} & input floating-\/point array. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#dct}{\tt org.\+opencv.\+core.\+Core.\+dct} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a64eb690877f2d4ac16c1b1c3375c0b7b}{org.\+opencv.\+core.\+Core\+::idct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}{org.\+opencv.\+core.\+Core\+::get\+Optimal\+D\+F\+T\+Size}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a9108dd80dbec1fd4f196a6e9e2564734}\label{classorg_1_1opencv_1_1core_1_1_core_a9108dd80dbec1fd4f196a6e9e2564734}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!determinant@{determinant}}
\index{determinant@{determinant}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{determinant()}{determinant()}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+determinant (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mtx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the determinant of a square floating-\/point matrix.

The function {\ttfamily determinant} calculates and returns the determinant of the specified matrix. For small matrices ({\ttfamily mtx.\+cols=mtx.\+rows$<$=3}), the direct method is used. For larger matrices, the function uses LU factorization with partial pivoting.

For symmetric positively-\/determined matrices, it is also possible to use \char`\"{}eigen\char`\"{} decomposition to calculate the determinant.


\begin{DoxyParams}{Parameters}
{\em mtx} & input matrix that must have {\ttfamily C\+V\+\_\+32\+F\+C1} or {\ttfamily C\+V\+\_\+64\+F\+C1} type and square size.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#determinant}{\tt org.\+opencv.\+core.\+Core.\+determinant} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af7c788172a8e426cf6b6cedc8d828f1b}{org.\+opencv.\+core.\+Core\+::invert}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af6e1ab8eaa1618c30a16e38da739bbeb}{org.\+opencv.\+core.\+Core\+::solve}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab44f09e696b045957316b9b384ef0c70}{org.\+opencv.\+core.\+Core\+::eigen}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9c17a12158c59ea65c662cac491c28c3}{org.\+opencv.\+core.\+Core\+::trace}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}\label{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!dft@{dft}}
\index{dft@{dft}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{dft()}{dft()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+dft (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{flags,  }\item[{int}]{nonzero\+Rows }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-\/point array.

The function performs one of the following\+:


\begin{DoxyItemize}
\item Forward the Fourier transform of a 1D vector of {\ttfamily N} elements\+: 
\end{DoxyItemize}

{\itshape Y = F$^\wedge$N $\ast$ X,}

where {\itshape F$^\wedge$\+N\+\_\+(jk)=exp(-\/2pi i j k/N)} and {\itshape i=sqrt(-\/1)}


\begin{DoxyItemize}
\item Inverse the Fourier transform of a 1D vector of {\ttfamily N} elements\+: 
\end{DoxyItemize}

{\itshape X\textquotesingle{}= (F$^\wedge$N)$^\wedge$(-\/1) $\ast$ Y = (F$^\wedge$N)$^\wedge$$\ast$ $\ast$ y X = (1/N) $\ast$ X, }

where {\itshape F$^\wedge$$\ast$=(Re(\+F$^\wedge$\+N)-\/\+Im(F$^\wedge$N))$^\wedge$T}


\begin{DoxyItemize}
\item Forward the 2D Fourier transform of a {\ttfamily M x N} matrix\+: 
\end{DoxyItemize}

{\itshape Y = F$^\wedge$M $\ast$ X $\ast$ F$^\wedge$N}


\begin{DoxyItemize}
\item Inverse the 2D Fourier transform of a {\ttfamily M x N} matrix\+: 
\end{DoxyItemize}

{\itshape X\textquotesingle{}= (F$^\wedge$M)$^\wedge$$\ast$ $\ast$ Y $\ast$ (F$^\wedge$N)$^\wedge$$\ast$ X = 1/(M $\ast$ N) $\ast$ X\textquotesingle{} }

In case of real (single-\/channel) data, the output spectrum of the forward Fourier transform or input spectrum of the inverse Fourier transform can be represented in a packed format called {\itshape C\+CS} (complex-\/conjugate-\/symmetrical). It was borrowed from I\+PL (Intel$\ast$ Image Processing Library). Here is how 2D {\itshape C\+CS} spectrum looks\+:

{\itshape Re Y\+\_\+(0,0) Re Y\+\_\+(0,1) Im Y\+\_\+(0,1) Re Y\+\_\+(0,2) Im Y\+\_\+(0,2) $\ast$s Re Y\+\_\+(0,N/2-\/1) Im Y\+\_\+(0,N/2-\/1) Re Y\+\_\+(0,N/2) Re Y\+\_\+(1,0) Re Y\+\_\+(1,1) Im Y\+\_\+(1,1) Re Y\+\_\+(1,2) Im Y\+\_\+(1,2) $\ast$s Re Y\+\_\+(1,N/2-\/1) Im Y\+\_\+(1,N/2-\/1) Re Y\+\_\+(1,N/2) Im Y\+\_\+(1,0) Re Y\+\_\+(2,1) Im Y\+\_\+(2,1) Re Y\+\_\+(2,2) Im Y\+\_\+(2,2) $\ast$s Re Y\+\_\+(2,N/2-\/1) Im Y\+\_\+(2,N/2-\/1) Im Y\+\_\+(1,N/2)........................... Re Y\+\_\+(M/2-\/1,0) Re Y\+\_\+(M-\/3,1) Im Y\+\_\+(M-\/3,1)......... Re Y\+\_\+(M-\/3,N/2-\/1) Im Y\+\_\+(M-\/3,N/2-\/1) Re Y\+\_\+(M/2-\/1,N/2) Im Y\+\_\+(M/2-\/1,0) Re Y\+\_\+(M-\/2,1) Im Y\+\_\+(M-\/2,1)......... Re Y\+\_\+(M-\/2,N/2-\/1) Im Y\+\_\+(M-\/2,N/2-\/1) Im Y\+\_\+(M/2-\/1,N/2) Re Y\+\_\+(M/2,0) Re Y\+\_\+(M-\/1,1) Im Y\+\_\+(M-\/1,1)......... Re Y\+\_\+(M-\/1,N/2-\/1) Im Y\+\_\+(M-\/1,N/2-\/1) Re Y\+\_\+(M/2,N/2) }

In case of 1D transform of a real vector, the output looks like the first row of the matrix above.

So, the function chooses an operation mode depending on the flags and size of the input array\+:


\begin{DoxyItemize}
\item If {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS} is set or the input array has a single row or single column, the function performs a 1D forward or inverse transform of each row of a matrix when {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS} is set. Otherwise, it performs a 2D transform. 
\item If the input array is real and {\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} is not set, the function performs a forward 1D or 2D transform\+: 
\item When {\ttfamily D\+F\+T\+\_\+\+C\+O\+M\+P\+L\+E\+X\+\_\+\+O\+U\+T\+P\+UT} is set, the output is a complex matrix of the same size as input. 
\item When {\ttfamily D\+F\+T\+\_\+\+C\+O\+M\+P\+L\+E\+X\+\_\+\+O\+U\+T\+P\+UT} is not set, the output is a real matrix of the same size as input. In case of 2D transform, it uses the packed format as shown above. In case of a single 1D transform, it looks like the first row of the matrix above. In case of multiple 1D transforms (when using the {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS} flag), each row of the output matrix looks like the first row of the matrix above. 
\item If the input array is complex and either {\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} or {\ttfamily D\+F\+T\+\_\+\+R\+E\+A\+L\+\_\+\+O\+U\+T\+P\+UT} are not set, the output is a complex array of the same size as input. The function performs a forward or inverse 1D or 2D transform of the whole input array or each row of the input array independently, depending on the flags {\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} and {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS}. 
\item When {\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} is set and the input array is real, or it is complex but {\ttfamily D\+F\+T\+\_\+\+R\+E\+A\+L\+\_\+\+O\+U\+T\+P\+UT} is set, the output is a real array of the same size as input. The function performs a 1D or 2D inverse transformation of the whole input array or each individual row, depending on the flags {\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} and {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS}. 
\end{DoxyItemize}

If {\ttfamily D\+F\+T\+\_\+\+S\+C\+A\+LE} is set, the scaling is done after the transformation.

Unlike \char`\"{}dct\char`\"{}, the function supports arrays of arbitrary size. But only those arrays are processed efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the current implementation). Such an efficient D\+FT size can be calculated using the \char`\"{}get\+Optimal\+D\+F\+T\+Size\char`\"{} method. The sample below illustrates how to calculate a D\+F\+T-\/based convolution of two 2D real arrays\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily void convolve\+D\+F\+T(\+Input\+Array A, Input\+Array B, Output\+Array C)}

{\ttfamily }

{\ttfamily }

{\ttfamily // reallocate the output array if needed}

{\ttfamily }

{\ttfamily }

{\ttfamily C.\+create(abs(A.\+rows -\/ B.\+rows)+1, abs(A.\+cols -\/ B.\+cols)+1, A.\+type());}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dft\+Size;}

{\ttfamily }

{\ttfamily }

{\ttfamily // calculate the size of D\+FT transform}

{\ttfamily }

{\ttfamily }

{\ttfamily dft\+Size.\+width = get\+Optimal\+D\+F\+T\+Size(A.\+cols + B.\+cols -\/ 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily dft\+Size.\+height = get\+Optimal\+D\+F\+T\+Size(A.\+rows + B.\+rows -\/ 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily // allocate temporary buffers and initialize them with 0\textquotesingle{}s}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tempA(dft\+Size, A.\+type(), Scalar.\+all(0));}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tempB(dft\+Size, B.\+type(), Scalar.\+all(0));}

{\ttfamily }

{\ttfamily }

{\ttfamily // copy A and B to the top-\/left corners of tempA and tempB, respectively}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} roiA(tempA, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}(0,0,A.\+cols,A.\+rows));}

{\ttfamily }

{\ttfamily }

{\ttfamily A.\+copy\+To(roi\+A);}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} roiB(tempB, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}(0,0,B.\+cols,B.\+rows));}

{\ttfamily }

{\ttfamily }

{\ttfamily B.\+copy\+To(roi\+B);}

{\ttfamily }

{\ttfamily }

{\ttfamily // now transform the padded A \& B in-\/place;}

{\ttfamily }

{\ttfamily }

{\ttfamily // use \char`\"{}nonzero\+Rows\char`\"{} hint for faster processing}

{\ttfamily }

{\ttfamily }

{\ttfamily dft(tempA, tempA, 0, A.\+rows);}

{\ttfamily }

{\ttfamily }

{\ttfamily dft(tempB, tempB, 0, B.\+rows);}

{\ttfamily }

{\ttfamily }

{\ttfamily // multiply the spectrums;}

{\ttfamily }

{\ttfamily }

{\ttfamily // the function handles packed spectrum representations well}

{\ttfamily }

{\ttfamily }

{\ttfamily mul\+Spectrums(temp\+A, temp\+B, temp\+A);}

{\ttfamily }

{\ttfamily }

{\ttfamily // transform the product back from the frequency domain.}

{\ttfamily }

{\ttfamily }

{\ttfamily // Even though all the result rows will be non-\/zero,}

{\ttfamily }

{\ttfamily }

{\ttfamily // you need only the first C.\+rows of them, and thus you}

{\ttfamily }

{\ttfamily }

{\ttfamily // pass nonzero\+Rows == C.\+rows}

{\ttfamily }

{\ttfamily }

{\ttfamily dft(tempA, tempA, D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE + D\+F\+T\+\_\+\+S\+C\+A\+LE, C.\+rows);}

{\ttfamily }

{\ttfamily }

{\ttfamily // now copy the result back to C.}

{\ttfamily }

{\ttfamily }

{\ttfamily tempA(\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}(0, 0, C.\+cols, C.\+rows)).copy\+To(\+C);}

{\ttfamily }

{\ttfamily }

{\ttfamily // all the temporary buffers will be deallocated automatically}

{\ttfamily }

{\ttfamily }

{\ttfamily To optimize this sample, consider the following approaches\+: }


\begin{DoxyItemize}
\item Since {\ttfamily nonzero\+Rows != 0} is passed to the forward transform calls and since {\ttfamily A} and {\ttfamily B} are copied to the top-\/left corners of {\ttfamily tempA} and {\ttfamily tempB}, respectively, it is not necessary to clear the whole {\ttfamily tempA} and {\ttfamily tempB}. It is only necessary to clear the {\ttfamily temp\+A.\+cols -\/ A.\+cols} ({\ttfamily temp\+B.\+cols -\/ B.\+cols}) rightmost columns of the matrices. 
\item This D\+F\+T-\/based convolution does not have to be applied to the whole big arrays, especially if {\ttfamily B} is significantly smaller than {\ttfamily A} or vice versa. Instead, you can calculate convolution by parts. To do this, you need to split the output array {\ttfamily C} into multiple tiles. For each tile, estimate which parts of {\ttfamily A} and {\ttfamily B} are required to calculate convolution in this tile. If the tiles in {\ttfamily C} are too small, the speed will decrease a lot because of repeated work. In the ultimate case, when each tile in {\ttfamily C} is a single pixel, the algorithm becomes equivalent to the naive convolution algorithm. If the tiles are too big, the temporary arrays {\ttfamily tempA} and {\ttfamily tempB} become too big and there is also a slowdown because of bad cache locality. So, there is an optimal tile size somewhere in the middle. 
\item If different tiles in {\ttfamily C} can be calculated in parallel and, thus, the convolution is done by parts, the loop can be threaded. 
\end{DoxyItemize}

All of the above improvements have been implemented in \char`\"{}match\+Template\char`\"{} and \char`\"{}filter2\+D\char`\"{}. Therefore, by using them, you can get the performance even better than with the above theoretically optimal implementation. Though, those two functions actually calculate cross-\/correlation, not convolution, so you need to \char`\"{}flip\char`\"{} the second convolution operand {\ttfamily B} vertically and horizontally using \char`\"{}flip\char`\"{}.

Note\+:


\begin{DoxyItemize}
\item An example using the discrete fourier transform can be found at opencv\+\_\+source\+\_\+code/samples/cpp/dft.\+cpp 
\item (Python) An example using the dft functionality to perform Wiener deconvolution can be found at opencv\+\_\+source/samples/python2/deconvolution.\+py 
\item (Python) An example rearranging the quadrants of a Fourier image can be found at opencv\+\_\+source/samples/python2/dft.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input array that could be real or complex. \\
\hline
{\em dst} & output array whose size and type depends on the {\ttfamily flags}. \\
\hline
{\em flags} & transformation flags, representing a combination of the following values\+: 
\begin{DoxyItemize}
\item D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE performs an inverse 1D or 2D transform instead of the default forward transform. 
\item D\+F\+T\+\_\+\+S\+C\+A\+LE scales the result\+: divide it by the number of array elements. Normally, it is combined with {\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE}. 
\item D\+F\+T\+\_\+\+R\+O\+WS performs a forward or inverse transform of every individual row of the input matrix; this flag enables you to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself) to perform 3D and higher-\/dimensional transformations and so forth. 
\item D\+F\+T\+\_\+\+C\+O\+M\+P\+L\+E\+X\+\_\+\+O\+U\+T\+P\+UT performs a forward transformation of 1D or 2D real array; the result, though being a complex array, has complex-\/conjugate symmetry ({\itshape C\+CS}, see the function description below for details), and such an array can be packed into a real array of the same size as input, which is the fastest option and which is what the function does by default; however, you may wish to get a full complex array (for simpler spectrum analysis, and so on) -\/ pass the flag to enable the function to produce a full-\/size complex output array. 
\item D\+F\+T\+\_\+\+R\+E\+A\+L\+\_\+\+O\+U\+T\+P\+UT performs an inverse transformation of a 1D or 2D complex array; the result is normally a complex array of the same size, however, if the input array has conjugate-\/complex symmetry (for example, it is a result of forward transformation with {\ttfamily D\+F\+T\+\_\+\+C\+O\+M\+P\+L\+E\+X\+\_\+\+O\+U\+T\+P\+UT} flag), the output is a real array; while the function itself does not check whether the input is symmetrical or not, you can pass the flag and then the function will assume the symmetry and produce the real output array (note that when the input is packed into a real array and inverse transformation is executed, the function treats the input as a packed complex-\/conjugate symmetrical array, and the output will also be a real array). 
\end{DoxyItemize}\\
\hline
{\em nonzero\+Rows} & when the parameter is not zero, the function assumes that only the first {\ttfamily nonzero\+Rows} rows of the input array ({\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} is not set) or only the first {\ttfamily nonzero\+Rows} of the output array ({\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} is set) contain non-\/zeros, thus, the function can handle the rest of the rows more efficiently and save some time; this technique is very useful for calculating array cross-\/correlation or convolution using D\+FT.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#dft}{\tt org.\+opencv.\+core.\+Core.\+dft} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab7f64647bb4d0400664056af42b90063}{org.\+opencv.\+imgproc.\+Imgproc\+::match\+Template}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a249146033929c968ef948e290c2a438c}{org.\+opencv.\+core.\+Core\+::mul\+Spectrums}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8dc68bbfca84b4fdfb9cd7bd79fc893e}{org.\+opencv.\+core.\+Core\+::flip}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{org.\+opencv.\+core.\+Core\+::magnitude}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a09f94d89796effb89e2bff15c54b383a}{org.\+opencv.\+core.\+Core\+::phase}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1f0b3c28295d4db1ecd755201833d6cb}{org.\+opencv.\+core.\+Core\+::dct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{org.\+opencv.\+imgproc.\+Imgproc\+::filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}{org.\+opencv.\+core.\+Core\+::get\+Optimal\+D\+F\+T\+Size}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a06e879ce4de29934c450c8f1e7631a24}\label{classorg_1_1opencv_1_1core_1_1_core_a06e879ce4de29934c450c8f1e7631a24}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!dft@{dft}}
\index{dft@{dft}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{dft()}{dft()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+dft (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-\/point array.

The function performs one of the following\+:


\begin{DoxyItemize}
\item Forward the Fourier transform of a 1D vector of {\ttfamily N} elements\+: 
\end{DoxyItemize}

{\itshape Y = F$^\wedge$N $\ast$ X,}

where {\itshape F$^\wedge$\+N\+\_\+(jk)=exp(-\/2pi i j k/N)} and {\itshape i=sqrt(-\/1)}


\begin{DoxyItemize}
\item Inverse the Fourier transform of a 1D vector of {\ttfamily N} elements\+: 
\end{DoxyItemize}

{\itshape X\textquotesingle{}= (F$^\wedge$N)$^\wedge$(-\/1) $\ast$ Y = (F$^\wedge$N)$^\wedge$$\ast$ $\ast$ y X = (1/N) $\ast$ X, }

where {\itshape F$^\wedge$$\ast$=(Re(\+F$^\wedge$\+N)-\/\+Im(F$^\wedge$N))$^\wedge$T}


\begin{DoxyItemize}
\item Forward the 2D Fourier transform of a {\ttfamily M x N} matrix\+: 
\end{DoxyItemize}

{\itshape Y = F$^\wedge$M $\ast$ X $\ast$ F$^\wedge$N}


\begin{DoxyItemize}
\item Inverse the 2D Fourier transform of a {\ttfamily M x N} matrix\+: 
\end{DoxyItemize}

{\itshape X\textquotesingle{}= (F$^\wedge$M)$^\wedge$$\ast$ $\ast$ Y $\ast$ (F$^\wedge$N)$^\wedge$$\ast$ X = 1/(M $\ast$ N) $\ast$ X\textquotesingle{} }

In case of real (single-\/channel) data, the output spectrum of the forward Fourier transform or input spectrum of the inverse Fourier transform can be represented in a packed format called {\itshape C\+CS} (complex-\/conjugate-\/symmetrical). It was borrowed from I\+PL (Intel$\ast$ Image Processing Library). Here is how 2D {\itshape C\+CS} spectrum looks\+:

{\itshape Re Y\+\_\+(0,0) Re Y\+\_\+(0,1) Im Y\+\_\+(0,1) Re Y\+\_\+(0,2) Im Y\+\_\+(0,2) $\ast$s Re Y\+\_\+(0,N/2-\/1) Im Y\+\_\+(0,N/2-\/1) Re Y\+\_\+(0,N/2) Re Y\+\_\+(1,0) Re Y\+\_\+(1,1) Im Y\+\_\+(1,1) Re Y\+\_\+(1,2) Im Y\+\_\+(1,2) $\ast$s Re Y\+\_\+(1,N/2-\/1) Im Y\+\_\+(1,N/2-\/1) Re Y\+\_\+(1,N/2) Im Y\+\_\+(1,0) Re Y\+\_\+(2,1) Im Y\+\_\+(2,1) Re Y\+\_\+(2,2) Im Y\+\_\+(2,2) $\ast$s Re Y\+\_\+(2,N/2-\/1) Im Y\+\_\+(2,N/2-\/1) Im Y\+\_\+(1,N/2)........................... Re Y\+\_\+(M/2-\/1,0) Re Y\+\_\+(M-\/3,1) Im Y\+\_\+(M-\/3,1)......... Re Y\+\_\+(M-\/3,N/2-\/1) Im Y\+\_\+(M-\/3,N/2-\/1) Re Y\+\_\+(M/2-\/1,N/2) Im Y\+\_\+(M/2-\/1,0) Re Y\+\_\+(M-\/2,1) Im Y\+\_\+(M-\/2,1)......... Re Y\+\_\+(M-\/2,N/2-\/1) Im Y\+\_\+(M-\/2,N/2-\/1) Im Y\+\_\+(M/2-\/1,N/2) Re Y\+\_\+(M/2,0) Re Y\+\_\+(M-\/1,1) Im Y\+\_\+(M-\/1,1)......... Re Y\+\_\+(M-\/1,N/2-\/1) Im Y\+\_\+(M-\/1,N/2-\/1) Re Y\+\_\+(M/2,N/2) }

In case of 1D transform of a real vector, the output looks like the first row of the matrix above.

So, the function chooses an operation mode depending on the flags and size of the input array\+:


\begin{DoxyItemize}
\item If {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS} is set or the input array has a single row or single column, the function performs a 1D forward or inverse transform of each row of a matrix when {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS} is set. Otherwise, it performs a 2D transform. 
\item If the input array is real and {\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} is not set, the function performs a forward 1D or 2D transform\+: 
\item When {\ttfamily D\+F\+T\+\_\+\+C\+O\+M\+P\+L\+E\+X\+\_\+\+O\+U\+T\+P\+UT} is set, the output is a complex matrix of the same size as input. 
\item When {\ttfamily D\+F\+T\+\_\+\+C\+O\+M\+P\+L\+E\+X\+\_\+\+O\+U\+T\+P\+UT} is not set, the output is a real matrix of the same size as input. In case of 2D transform, it uses the packed format as shown above. In case of a single 1D transform, it looks like the first row of the matrix above. In case of multiple 1D transforms (when using the {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS} flag), each row of the output matrix looks like the first row of the matrix above. 
\item If the input array is complex and either {\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} or {\ttfamily D\+F\+T\+\_\+\+R\+E\+A\+L\+\_\+\+O\+U\+T\+P\+UT} are not set, the output is a complex array of the same size as input. The function performs a forward or inverse 1D or 2D transform of the whole input array or each row of the input array independently, depending on the flags {\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} and {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS}. 
\item When {\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} is set and the input array is real, or it is complex but {\ttfamily D\+F\+T\+\_\+\+R\+E\+A\+L\+\_\+\+O\+U\+T\+P\+UT} is set, the output is a real array of the same size as input. The function performs a 1D or 2D inverse transformation of the whole input array or each individual row, depending on the flags {\ttfamily D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE} and {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS}. 
\end{DoxyItemize}

If {\ttfamily D\+F\+T\+\_\+\+S\+C\+A\+LE} is set, the scaling is done after the transformation.

Unlike \char`\"{}dct\char`\"{}, the function supports arrays of arbitrary size. But only those arrays are processed efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the current implementation). Such an efficient D\+FT size can be calculated using the \char`\"{}get\+Optimal\+D\+F\+T\+Size\char`\"{} method. The sample below illustrates how to calculate a D\+F\+T-\/based convolution of two 2D real arrays\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily void convolve\+D\+F\+T(\+Input\+Array A, Input\+Array B, Output\+Array C)}

{\ttfamily }

{\ttfamily }

{\ttfamily // reallocate the output array if needed}

{\ttfamily }

{\ttfamily }

{\ttfamily C.\+create(abs(A.\+rows -\/ B.\+rows)+1, abs(A.\+cols -\/ B.\+cols)+1, A.\+type());}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dft\+Size;}

{\ttfamily }

{\ttfamily }

{\ttfamily // calculate the size of D\+FT transform}

{\ttfamily }

{\ttfamily }

{\ttfamily dft\+Size.\+width = get\+Optimal\+D\+F\+T\+Size(A.\+cols + B.\+cols -\/ 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily dft\+Size.\+height = get\+Optimal\+D\+F\+T\+Size(A.\+rows + B.\+rows -\/ 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily // allocate temporary buffers and initialize them with 0\textquotesingle{}s}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tempA(dft\+Size, A.\+type(), Scalar.\+all(0));}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tempB(dft\+Size, B.\+type(), Scalar.\+all(0));}

{\ttfamily }

{\ttfamily }

{\ttfamily // copy A and B to the top-\/left corners of tempA and tempB, respectively}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} roiA(tempA, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}(0,0,A.\+cols,A.\+rows));}

{\ttfamily }

{\ttfamily }

{\ttfamily A.\+copy\+To(roi\+A);}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} roiB(tempB, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}(0,0,B.\+cols,B.\+rows));}

{\ttfamily }

{\ttfamily }

{\ttfamily B.\+copy\+To(roi\+B);}

{\ttfamily }

{\ttfamily }

{\ttfamily // now transform the padded A \& B in-\/place;}

{\ttfamily }

{\ttfamily }

{\ttfamily // use \char`\"{}nonzero\+Rows\char`\"{} hint for faster processing}

{\ttfamily }

{\ttfamily }

{\ttfamily dft(tempA, tempA, 0, A.\+rows);}

{\ttfamily }

{\ttfamily }

{\ttfamily dft(tempB, tempB, 0, B.\+rows);}

{\ttfamily }

{\ttfamily }

{\ttfamily // multiply the spectrums;}

{\ttfamily }

{\ttfamily }

{\ttfamily // the function handles packed spectrum representations well}

{\ttfamily }

{\ttfamily }

{\ttfamily mul\+Spectrums(temp\+A, temp\+B, temp\+A);}

{\ttfamily }

{\ttfamily }

{\ttfamily // transform the product back from the frequency domain.}

{\ttfamily }

{\ttfamily }

{\ttfamily // Even though all the result rows will be non-\/zero,}

{\ttfamily }

{\ttfamily }

{\ttfamily // you need only the first C.\+rows of them, and thus you}

{\ttfamily }

{\ttfamily }

{\ttfamily // pass nonzero\+Rows == C.\+rows}

{\ttfamily }

{\ttfamily }

{\ttfamily dft(tempA, tempA, D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE + D\+F\+T\+\_\+\+S\+C\+A\+LE, C.\+rows);}

{\ttfamily }

{\ttfamily }

{\ttfamily // now copy the result back to C.}

{\ttfamily }

{\ttfamily }

{\ttfamily tempA(\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}(0, 0, C.\+cols, C.\+rows)).copy\+To(\+C);}

{\ttfamily }

{\ttfamily }

{\ttfamily // all the temporary buffers will be deallocated automatically}

{\ttfamily }

{\ttfamily }

{\ttfamily To optimize this sample, consider the following approaches\+: }


\begin{DoxyItemize}
\item Since {\ttfamily nonzero\+Rows != 0} is passed to the forward transform calls and since {\ttfamily A} and {\ttfamily B} are copied to the top-\/left corners of {\ttfamily tempA} and {\ttfamily tempB}, respectively, it is not necessary to clear the whole {\ttfamily tempA} and {\ttfamily tempB}. It is only necessary to clear the {\ttfamily temp\+A.\+cols -\/ A.\+cols} ({\ttfamily temp\+B.\+cols -\/ B.\+cols}) rightmost columns of the matrices. 
\item This D\+F\+T-\/based convolution does not have to be applied to the whole big arrays, especially if {\ttfamily B} is significantly smaller than {\ttfamily A} or vice versa. Instead, you can calculate convolution by parts. To do this, you need to split the output array {\ttfamily C} into multiple tiles. For each tile, estimate which parts of {\ttfamily A} and {\ttfamily B} are required to calculate convolution in this tile. If the tiles in {\ttfamily C} are too small, the speed will decrease a lot because of repeated work. In the ultimate case, when each tile in {\ttfamily C} is a single pixel, the algorithm becomes equivalent to the naive convolution algorithm. If the tiles are too big, the temporary arrays {\ttfamily tempA} and {\ttfamily tempB} become too big and there is also a slowdown because of bad cache locality. So, there is an optimal tile size somewhere in the middle. 
\item If different tiles in {\ttfamily C} can be calculated in parallel and, thus, the convolution is done by parts, the loop can be threaded. 
\end{DoxyItemize}

All of the above improvements have been implemented in \char`\"{}match\+Template\char`\"{} and \char`\"{}filter2\+D\char`\"{}. Therefore, by using them, you can get the performance even better than with the above theoretically optimal implementation. Though, those two functions actually calculate cross-\/correlation, not convolution, so you need to \char`\"{}flip\char`\"{} the second convolution operand {\ttfamily B} vertically and horizontally using \char`\"{}flip\char`\"{}.

Note\+:


\begin{DoxyItemize}
\item An example using the discrete fourier transform can be found at opencv\+\_\+source\+\_\+code/samples/cpp/dft.\+cpp 
\item (Python) An example using the dft functionality to perform Wiener deconvolution can be found at opencv\+\_\+source/samples/python2/deconvolution.\+py 
\item (Python) An example rearranging the quadrants of a Fourier image can be found at opencv\+\_\+source/samples/python2/dft.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input array that could be real or complex. \\
\hline
{\em dst} & output array whose size and type depends on the {\ttfamily flags}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#dft}{\tt org.\+opencv.\+core.\+Core.\+dft} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab7f64647bb4d0400664056af42b90063}{org.\+opencv.\+imgproc.\+Imgproc\+::match\+Template}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a249146033929c968ef948e290c2a438c}{org.\+opencv.\+core.\+Core\+::mul\+Spectrums}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8dc68bbfca84b4fdfb9cd7bd79fc893e}{org.\+opencv.\+core.\+Core\+::flip}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{org.\+opencv.\+core.\+Core\+::magnitude}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a09f94d89796effb89e2bff15c54b383a}{org.\+opencv.\+core.\+Core\+::phase}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1f0b3c28295d4db1ecd755201833d6cb}{org.\+opencv.\+core.\+Core\+::dct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{org.\+opencv.\+imgproc.\+Imgproc\+::filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}{org.\+opencv.\+core.\+Core\+::get\+Optimal\+D\+F\+T\+Size}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ad0cc67e80d303076c4a8d486fe6b82c9}\label{classorg_1_1opencv_1_1core_1_1_core_ad0cc67e80d303076c4a8d486fe6b82c9}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!divide@{divide}}
\index{divide@{divide}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{divide()}{divide()}\hspace{0.1cm}{\footnotesize\ttfamily [1/8]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+divide (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{scale,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs per-\/element division of two arrays or a scalar by an array.

The functions {\ttfamily divide} divide one array by another\+:

{\itshape dst(\+I) = saturate(src1(\+I)$\ast$scale/src2(I))}

or a scalar by an array when there is no {\ttfamily src1} \+:

{\itshape dst(\+I) = saturate(scale/src2(I))}

When {\ttfamily src2(\+I)} is zero, {\ttfamily dst(\+I)} will also be zero. Different channels of multi-\/channel arrays are processed independently.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src2}. \\
\hline
{\em scale} & scalar factor. \\
\hline
{\em dtype} & optional depth of the output array; if {\ttfamily -\/1}, {\ttfamily dst} will have depth {\ttfamily src2.\+depth()}, but in case of an array-\/by-\/array division, you can only pass {\ttfamily -\/1} when {\ttfamily src1.\+depth()==src2.\+depth()}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide}{\tt org.\+opencv.\+core.\+Core.\+divide} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa49b10c74b442ec7cc890f9ce812918a}{org.\+opencv.\+core.\+Core\+::multiply}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_af2bc7a755d5d149644b0eceef2c3decc}\label{classorg_1_1opencv_1_1core_1_1_core_af2bc7a755d5d149644b0eceef2c3decc}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!divide@{divide}}
\index{divide@{divide}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{divide()}{divide()}\hspace{0.1cm}{\footnotesize\ttfamily [2/8]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+divide (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{scale }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs per-\/element division of two arrays or a scalar by an array.

The functions {\ttfamily divide} divide one array by another\+:

{\itshape dst(\+I) = saturate(src1(\+I)$\ast$scale/src2(I))}

or a scalar by an array when there is no {\ttfamily src1} \+:

{\itshape dst(\+I) = saturate(scale/src2(I))}

When {\ttfamily src2(\+I)} is zero, {\ttfamily dst(\+I)} will also be zero. Different channels of multi-\/channel arrays are processed independently.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src2}. \\
\hline
{\em scale} & scalar factor.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide}{\tt org.\+opencv.\+core.\+Core.\+divide} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa49b10c74b442ec7cc890f9ce812918a}{org.\+opencv.\+core.\+Core\+::multiply}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a7fb1d61ed82296b38b4e5a2a15d0bb8e}\label{classorg_1_1opencv_1_1core_1_1_core_a7fb1d61ed82296b38b4e5a2a15d0bb8e}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!divide@{divide}}
\index{divide@{divide}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{divide()}{divide()}\hspace{0.1cm}{\footnotesize\ttfamily [3/8]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+divide (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs per-\/element division of two arrays or a scalar by an array.

The functions {\ttfamily divide} divide one array by another\+:

{\itshape dst(\+I) = saturate(src1(\+I)$\ast$scale/src2(I))}

or a scalar by an array when there is no {\ttfamily src1} \+:

{\itshape dst(\+I) = saturate(scale/src2(I))}

When {\ttfamily src2(\+I)} is zero, {\ttfamily dst(\+I)} will also be zero. Different channels of multi-\/channel arrays are processed independently.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src2}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide}{\tt org.\+opencv.\+core.\+Core.\+divide} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa49b10c74b442ec7cc890f9ce812918a}{org.\+opencv.\+core.\+Core\+::multiply}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a72e29fcc15a837f2f76e2cc2c8429f06}\label{classorg_1_1opencv_1_1core_1_1_core_a72e29fcc15a837f2f76e2cc2c8429f06}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!divide@{divide}}
\index{divide@{divide}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{divide()}{divide()}\hspace{0.1cm}{\footnotesize\ttfamily [4/8]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+divide (\begin{DoxyParamCaption}\item[{double}]{scale,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs per-\/element division of two arrays or a scalar by an array.

The functions {\ttfamily divide} divide one array by another\+:

{\itshape dst(\+I) = saturate(src1(\+I)$\ast$scale/src2(I))}

or a scalar by an array when there is no {\ttfamily src1} \+:

{\itshape dst(\+I) = saturate(scale/src2(I))}

When {\ttfamily src2(\+I)} is zero, {\ttfamily dst(\+I)} will also be zero. Different channels of multi-\/channel arrays are processed independently.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em scale} & scalar factor. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src2}. \\
\hline
{\em dtype} & optional depth of the output array; if {\ttfamily -\/1}, {\ttfamily dst} will have depth {\ttfamily src2.\+depth()}, but in case of an array-\/by-\/array division, you can only pass {\ttfamily -\/1} when {\ttfamily src1.\+depth()==src2.\+depth()}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide}{\tt org.\+opencv.\+core.\+Core.\+divide} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa49b10c74b442ec7cc890f9ce812918a}{org.\+opencv.\+core.\+Core\+::multiply}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a1600c192648e1f09e86b9b7ae8d6ea82}\label{classorg_1_1opencv_1_1core_1_1_core_a1600c192648e1f09e86b9b7ae8d6ea82}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!divide@{divide}}
\index{divide@{divide}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{divide()}{divide()}\hspace{0.1cm}{\footnotesize\ttfamily [5/8]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+divide (\begin{DoxyParamCaption}\item[{double}]{scale,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs per-\/element division of two arrays or a scalar by an array.

The functions {\ttfamily divide} divide one array by another\+:

{\itshape dst(\+I) = saturate(src1(\+I)$\ast$scale/src2(I))}

or a scalar by an array when there is no {\ttfamily src1} \+:

{\itshape dst(\+I) = saturate(scale/src2(I))}

When {\ttfamily src2(\+I)} is zero, {\ttfamily dst(\+I)} will also be zero. Different channels of multi-\/channel arrays are processed independently.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em scale} & scalar factor. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src2}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide}{\tt org.\+opencv.\+core.\+Core.\+divide} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa49b10c74b442ec7cc890f9ce812918a}{org.\+opencv.\+core.\+Core\+::multiply}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ae4f6a61347c1af3819e65925d34f0d45}\label{classorg_1_1opencv_1_1core_1_1_core_ae4f6a61347c1af3819e65925d34f0d45}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!divide@{divide}}
\index{divide@{divide}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{divide()}{divide()}\hspace{0.1cm}{\footnotesize\ttfamily [6/8]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+divide (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{scale,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs per-\/element division of two arrays or a scalar by an array.

The functions {\ttfamily divide} divide one array by another\+:

{\itshape dst(\+I) = saturate(src1(\+I)$\ast$scale/src2(I))}

or a scalar by an array when there is no {\ttfamily src1} \+:

{\itshape dst(\+I) = saturate(scale/src2(I))}

When {\ttfamily src2(\+I)} is zero, {\ttfamily dst(\+I)} will also be zero. Different channels of multi-\/channel arrays are processed independently.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src2}. \\
\hline
{\em scale} & scalar factor. \\
\hline
{\em dtype} & optional depth of the output array; if {\ttfamily -\/1}, {\ttfamily dst} will have depth {\ttfamily src2.\+depth()}, but in case of an array-\/by-\/array division, you can only pass {\ttfamily -\/1} when {\ttfamily src1.\+depth()==src2.\+depth()}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide}{\tt org.\+opencv.\+core.\+Core.\+divide} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa49b10c74b442ec7cc890f9ce812918a}{org.\+opencv.\+core.\+Core\+::multiply}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ae25ecaef7b81165a9700c04ca6a14ad8}\label{classorg_1_1opencv_1_1core_1_1_core_ae25ecaef7b81165a9700c04ca6a14ad8}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!divide@{divide}}
\index{divide@{divide}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{divide()}{divide()}\hspace{0.1cm}{\footnotesize\ttfamily [7/8]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+divide (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{scale }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs per-\/element division of two arrays or a scalar by an array.

The functions {\ttfamily divide} divide one array by another\+:

{\itshape dst(\+I) = saturate(src1(\+I)$\ast$scale/src2(I))}

or a scalar by an array when there is no {\ttfamily src1} \+:

{\itshape dst(\+I) = saturate(scale/src2(I))}

When {\ttfamily src2(\+I)} is zero, {\ttfamily dst(\+I)} will also be zero. Different channels of multi-\/channel arrays are processed independently.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src2}. \\
\hline
{\em scale} & scalar factor.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide}{\tt org.\+opencv.\+core.\+Core.\+divide} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa49b10c74b442ec7cc890f9ce812918a}{org.\+opencv.\+core.\+Core\+::multiply}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aee28f9ac9f6b8cb02b05f34007cf84bc}\label{classorg_1_1opencv_1_1core_1_1_core_aee28f9ac9f6b8cb02b05f34007cf84bc}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!divide@{divide}}
\index{divide@{divide}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{divide()}{divide()}\hspace{0.1cm}{\footnotesize\ttfamily [8/8]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+divide (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs per-\/element division of two arrays or a scalar by an array.

The functions {\ttfamily divide} divide one array by another\+:

{\itshape dst(\+I) = saturate(src1(\+I)$\ast$scale/src2(I))}

or a scalar by an array when there is no {\ttfamily src1} \+:

{\itshape dst(\+I) = saturate(scale/src2(I))}

When {\ttfamily src2(\+I)} is zero, {\ttfamily dst(\+I)} will also be zero. Different channels of multi-\/channel arrays are processed independently.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src2}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#divide}{\tt org.\+opencv.\+core.\+Core.\+divide} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa49b10c74b442ec7cc890f9ce812918a}{org.\+opencv.\+core.\+Core\+::multiply}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ab44f09e696b045957316b9b384ef0c70}\label{classorg_1_1opencv_1_1core_1_1_core_ab44f09e696b045957316b9b384ef0c70}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!eigen@{eigen}}
\index{eigen@{eigen}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{eigen()}{eigen()}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+core.\+Core.\+eigen (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{boolean}]{compute\+Eigenvectors,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{eigenvalues,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{eigenvectors }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates eigenvalues and eigenvectors of a symmetric matrix.

The functions {\ttfamily eigen} calculate just eigenvalues, or eigenvalues and eigenvectors of the symmetric matrix {\ttfamily src} \+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily src$\ast$eigenvectors.row(i).t() = eigenvalues.\+at$<$src\+Type$>$(i)$\ast$eigenvectors.row(i).t()}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: in the new and the old interfaces different ordering of eigenvalues and eigenvectors parameters is used. }


\begin{DoxyParams}{Parameters}
{\em src} & input matrix that must have {\ttfamily C\+V\+\_\+32\+F\+C1} or {\ttfamily C\+V\+\_\+64\+F\+C1} type, square size and be symmetrical ({\ttfamily src}$^\wedge$\char`\"{}\+T\char`\"{} == {\ttfamily src}). \\
\hline
{\em compute\+Eigenvectors} & a compute\+Eigenvectors \\
\hline
{\em eigenvalues} & output vector of eigenvalues of the same type as {\ttfamily src}; the eigenvalues are stored in the descending order. \\
\hline
{\em eigenvectors} & output matrix of eigenvectors; it has the same size and type as {\ttfamily src}; the eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#eigen}{\tt org.\+opencv.\+core.\+Core.\+eigen} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad3a0199c2b0bbc9d254768b566fd257e}{org.\+opencv.\+core.\+Core\+::complete\+Symm}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a3ef54117896a561685fd30cd374c2ce6}\label{classorg_1_1opencv_1_1core_1_1_core_a3ef54117896a561685fd30cd374c2ce6}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!ellipse@{ellipse}}
\index{ellipse@{ellipse}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{ellipse()}{ellipse()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+ellipse (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{center,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{axes,  }\item[{double}]{angle,  }\item[{double}]{start\+Angle,  }\item[{double}]{end\+Angle,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness,  }\item[{int}]{line\+Type,  }\item[{int}]{shift }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a simple or thick elliptic arc or fills an ellipse sector.

The functions {\ttfamily ellipse} with less parameters draw an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. A piecewise-\/linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using \char`\"{}ellipse2\+Poly\char`\"{} and then render it with \char`\"{}polylines\char`\"{} or fill it with \char`\"{}fill\+Poly\char`\"{}. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass {\ttfamily start\+Angle=0} and {\ttfamily end\+Angle=360}. The figure below explains the meaning of the parameters. Figure 1. Parameters of Elliptic Arc


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em center} & Center of the ellipse. \\
\hline
{\em axes} & Half of the size of the ellipse main axes. \\
\hline
{\em angle} & Ellipse rotation angle in degrees. \\
\hline
{\em start\+Angle} & Starting angle of the elliptic arc in degrees. \\
\hline
{\em end\+Angle} & Ending angle of the elliptic arc in degrees. \\
\hline
{\em color} & Ellipse color. \\
\hline
{\em thickness} & Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. \\
\hline
{\em line\+Type} & Type of the ellipse boundary. See the \char`\"{}line\char`\"{} description. \\
\hline
{\em shift} & Number of fractional bits in the coordinates of the center and values of axes.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse}{\tt org.\+opencv.\+core.\+Core.\+ellipse} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a55af7b6ca8fdb3e8c2d13cca74081267}\label{classorg_1_1opencv_1_1core_1_1_core_a55af7b6ca8fdb3e8c2d13cca74081267}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!ellipse@{ellipse}}
\index{ellipse@{ellipse}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{ellipse()}{ellipse()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+ellipse (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{center,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{axes,  }\item[{double}]{angle,  }\item[{double}]{start\+Angle,  }\item[{double}]{end\+Angle,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a simple or thick elliptic arc or fills an ellipse sector.

The functions {\ttfamily ellipse} with less parameters draw an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. A piecewise-\/linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using \char`\"{}ellipse2\+Poly\char`\"{} and then render it with \char`\"{}polylines\char`\"{} or fill it with \char`\"{}fill\+Poly\char`\"{}. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass {\ttfamily start\+Angle=0} and {\ttfamily end\+Angle=360}. The figure below explains the meaning of the parameters. Figure 1. Parameters of Elliptic Arc


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em center} & Center of the ellipse. \\
\hline
{\em axes} & Half of the size of the ellipse main axes. \\
\hline
{\em angle} & Ellipse rotation angle in degrees. \\
\hline
{\em start\+Angle} & Starting angle of the elliptic arc in degrees. \\
\hline
{\em end\+Angle} & Ending angle of the elliptic arc in degrees. \\
\hline
{\em color} & Ellipse color. \\
\hline
{\em thickness} & Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse}{\tt org.\+opencv.\+core.\+Core.\+ellipse} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a288c270183c0a0930910e55bf421c1a2}\label{classorg_1_1opencv_1_1core_1_1_core_a288c270183c0a0930910e55bf421c1a2}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!ellipse@{ellipse}}
\index{ellipse@{ellipse}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{ellipse()}{ellipse()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+ellipse (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{center,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{axes,  }\item[{double}]{angle,  }\item[{double}]{start\+Angle,  }\item[{double}]{end\+Angle,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a simple or thick elliptic arc or fills an ellipse sector.

The functions {\ttfamily ellipse} with less parameters draw an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. A piecewise-\/linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using \char`\"{}ellipse2\+Poly\char`\"{} and then render it with \char`\"{}polylines\char`\"{} or fill it with \char`\"{}fill\+Poly\char`\"{}. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass {\ttfamily start\+Angle=0} and {\ttfamily end\+Angle=360}. The figure below explains the meaning of the parameters. Figure 1. Parameters of Elliptic Arc


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em center} & Center of the ellipse. \\
\hline
{\em axes} & Half of the size of the ellipse main axes. \\
\hline
{\em angle} & Ellipse rotation angle in degrees. \\
\hline
{\em start\+Angle} & Starting angle of the elliptic arc in degrees. \\
\hline
{\em end\+Angle} & Ending angle of the elliptic arc in degrees. \\
\hline
{\em color} & Ellipse color.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse}{\tt org.\+opencv.\+core.\+Core.\+ellipse} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a90332fb5cef2fa8e33b3e304f7c868ff}\label{classorg_1_1opencv_1_1core_1_1_core_a90332fb5cef2fa8e33b3e304f7c868ff}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!ellipse@{ellipse}}
\index{ellipse@{ellipse}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{ellipse()}{ellipse()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+ellipse (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rotated_rect}{Rotated\+Rect}}}]{box,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness,  }\item[{int}]{line\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a simple or thick elliptic arc or fills an ellipse sector.

The functions {\ttfamily ellipse} with less parameters draw an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. A piecewise-\/linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using \char`\"{}ellipse2\+Poly\char`\"{} and then render it with \char`\"{}polylines\char`\"{} or fill it with \char`\"{}fill\+Poly\char`\"{}. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass {\ttfamily start\+Angle=0} and {\ttfamily end\+Angle=360}. The figure below explains the meaning of the parameters. Figure 1. Parameters of Elliptic Arc


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em box} & Alternative ellipse representation via \char`\"{}\+Rotated\+Rect\char`\"{} or {\ttfamily Cv\+Box2D}. This means that the function draws an ellipse inscribed in the rotated rectangle. \\
\hline
{\em color} & Ellipse color. \\
\hline
{\em thickness} & Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. \\
\hline
{\em line\+Type} & Type of the ellipse boundary. See the \char`\"{}line\char`\"{} description.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse}{\tt org.\+opencv.\+core.\+Core.\+ellipse} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ab32656b0a495ca643801145d700afcc4}\label{classorg_1_1opencv_1_1core_1_1_core_ab32656b0a495ca643801145d700afcc4}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!ellipse@{ellipse}}
\index{ellipse@{ellipse}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{ellipse()}{ellipse()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+ellipse (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rotated_rect}{Rotated\+Rect}}}]{box,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a simple or thick elliptic arc or fills an ellipse sector.

The functions {\ttfamily ellipse} with less parameters draw an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. A piecewise-\/linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using \char`\"{}ellipse2\+Poly\char`\"{} and then render it with \char`\"{}polylines\char`\"{} or fill it with \char`\"{}fill\+Poly\char`\"{}. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass {\ttfamily start\+Angle=0} and {\ttfamily end\+Angle=360}. The figure below explains the meaning of the parameters. Figure 1. Parameters of Elliptic Arc


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em box} & Alternative ellipse representation via \char`\"{}\+Rotated\+Rect\char`\"{} or {\ttfamily Cv\+Box2D}. This means that the function draws an ellipse inscribed in the rotated rectangle. \\
\hline
{\em color} & Ellipse color. \\
\hline
{\em thickness} & Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse}{\tt org.\+opencv.\+core.\+Core.\+ellipse} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a31b26443f36f448e4ed2714ca3558150}\label{classorg_1_1opencv_1_1core_1_1_core_a31b26443f36f448e4ed2714ca3558150}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!ellipse@{ellipse}}
\index{ellipse@{ellipse}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{ellipse()}{ellipse()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+ellipse (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rotated_rect}{Rotated\+Rect}}}]{box,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a simple or thick elliptic arc or fills an ellipse sector.

The functions {\ttfamily ellipse} with less parameters draw an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. A piecewise-\/linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using \char`\"{}ellipse2\+Poly\char`\"{} and then render it with \char`\"{}polylines\char`\"{} or fill it with \char`\"{}fill\+Poly\char`\"{}. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass {\ttfamily start\+Angle=0} and {\ttfamily end\+Angle=360}. The figure below explains the meaning of the parameters. Figure 1. Parameters of Elliptic Arc


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em box} & Alternative ellipse representation via \char`\"{}\+Rotated\+Rect\char`\"{} or {\ttfamily Cv\+Box2D}. This means that the function draws an ellipse inscribed in the rotated rectangle. \\
\hline
{\em color} & Ellipse color.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse}{\tt org.\+opencv.\+core.\+Core.\+ellipse} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ab4ab635dc04de40b7dd1722a99bfcc34}\label{classorg_1_1opencv_1_1core_1_1_core_ab4ab635dc04de40b7dd1722a99bfcc34}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!ellipse2\+Poly@{ellipse2\+Poly}}
\index{ellipse2\+Poly@{ellipse2\+Poly}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{ellipse2\+Poly()}{ellipse2Poly()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+ellipse2\+Poly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{center,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{axes,  }\item[{int}]{angle,  }\item[{int}]{arc\+Start,  }\item[{int}]{arc\+End,  }\item[{int}]{delta,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}}}]{pts }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Approximates an elliptic arc with a polyline.

The function {\ttfamily ellipse2\+Poly} computes the vertices of a polyline that approximates the specified elliptic arc. It is used by \char`\"{}ellipse\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em center} & Center of the arc. \\
\hline
{\em axes} & Half of the size of the ellipse main axes. See the \char`\"{}ellipse\char`\"{} for details. \\
\hline
{\em angle} & Rotation angle of the ellipse in degrees. See the \char`\"{}ellipse\char`\"{} for details. \\
\hline
{\em arc\+Start} & Starting angle of the elliptic arc in degrees. \\
\hline
{\em arc\+End} & Ending angle of the elliptic arc in degrees. \\
\hline
{\em delta} & Angle between the subsequent polyline vertices. It defines the approximation accuracy. \\
\hline
{\em pts} & Output vector of polyline vertices.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#ellipse2poly}{\tt org.\+opencv.\+core.\+Core.\+ellipse2\+Poly} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a18688b13789043dfaa98161fe663f075}\label{classorg_1_1opencv_1_1core_1_1_core_a18688b13789043dfaa98161fe663f075}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!exp@{exp}}
\index{exp@{exp}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{exp()}{exp()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+exp (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the exponent of every array element.

The function {\ttfamily exp} calculates the exponent of every element of the input array\+:

{\itshape dst \mbox{[}I\mbox{]} = e$^\wedge$(src(\+I))}

The maximum relative error is about {\ttfamily 7e-\/6} for single-\/precision input and less than {\ttfamily 1e-\/10} for double-\/precision input. Currently, the function converts denormalized values to zeros on output. Special values (NaN, Inf) are not handled.


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#exp}{\tt org.\+opencv.\+core.\+Core.\+exp} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a34d89a9c8e2562fc85bfecca3dca7d76}{org.\+opencv.\+core.\+Core\+::log}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a29c20af97ae09c75246777774bc6d41b}{org.\+opencv.\+core.\+Core\+::pow}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5a2235761d8876294b3277876479107b}{org.\+opencv.\+core.\+Core\+::sqrt}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{org.\+opencv.\+core.\+Core\+::magnitude}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a90c17a6d7e194cd8baf45819267a4539}{org.\+opencv.\+core.\+Core\+::polar\+To\+Cart}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a09f94d89796effb89e2bff15c54b383a}{org.\+opencv.\+core.\+Core\+::phase}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aed121d8dfc230918f9086b7ba06c0b57}\label{classorg_1_1opencv_1_1core_1_1_core_aed121d8dfc230918f9086b7ba06c0b57}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!extract\+Channel@{extract\+Channel}}
\index{extract\+Channel@{extract\+Channel}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{extract\+Channel()}{extractChannel()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+extract\+Channel (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{coi }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aeb2a09f9bb80c8c33e4b5074078d892c}\label{classorg_1_1opencv_1_1core_1_1_core_aeb2a09f9bb80c8c33e4b5074078d892c}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!fast\+Atan2@{fast\+Atan2}}
\index{fast\+Atan2@{fast\+Atan2}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{fast\+Atan2()}{fastAtan2()}}
{\footnotesize\ttfamily static float org.\+opencv.\+core.\+Core.\+fast\+Atan2 (\begin{DoxyParamCaption}\item[{float}]{y,  }\item[{float}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the angle of a 2D vector in degrees.

The function {\ttfamily fast\+Atan2} calculates the full-\/range angle of an input 2D vector. The angle is measured in degrees and varies from 0 to 360 degrees. The accuracy is about 0.\+3 degrees.


\begin{DoxyParams}{Parameters}
{\em y} & y-\/coordinate of the vector. \\
\hline
{\em x} & x-\/coordinate of the vector.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#fastatan2}{\tt org.\+opencv.\+core.\+Core.\+fast\+Atan2} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ad5886a0bea843f9e8b5d6680309b53a7}\label{classorg_1_1opencv_1_1core_1_1_core_ad5886a0bea843f9e8b5d6680309b53a7}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!fill\+Convex\+Poly@{fill\+Convex\+Poly}}
\index{fill\+Convex\+Poly@{fill\+Convex\+Poly}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{fill\+Convex\+Poly()}{fillConvexPoly()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+fill\+Convex\+Poly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}}}]{points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{line\+Type,  }\item[{int}]{shift }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Fills a convex polygon.

The function {\ttfamily fill\+Convex\+Poly} draws a filled convex polygon. This function is much faster than the function {\ttfamily fill\+Poly}. It can fill not only convex polygons but any monotonic polygon without self-\/intersections, that is, a polygon whose contour intersects every horizontal line (scan line) twice at the most (though, its top-\/most and/or the bottom edge could be horizontal).


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em points} & a points \\
\hline
{\em color} & Polygon color. \\
\hline
{\em line\+Type} & Type of the polygon boundaries. See the \char`\"{}line\char`\"{} description. \\
\hline
{\em shift} & Number of fractional bits in the vertex coordinates.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillconvexpoly}{\tt org.\+opencv.\+core.\+Core.\+fill\+Convex\+Poly} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_af384d6fce35de3e8e9dbed55b13e51a6}\label{classorg_1_1opencv_1_1core_1_1_core_af384d6fce35de3e8e9dbed55b13e51a6}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!fill\+Convex\+Poly@{fill\+Convex\+Poly}}
\index{fill\+Convex\+Poly@{fill\+Convex\+Poly}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{fill\+Convex\+Poly()}{fillConvexPoly()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+fill\+Convex\+Poly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}}}]{points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Fills a convex polygon.

The function {\ttfamily fill\+Convex\+Poly} draws a filled convex polygon. This function is much faster than the function {\ttfamily fill\+Poly}. It can fill not only convex polygons but any monotonic polygon without self-\/intersections, that is, a polygon whose contour intersects every horizontal line (scan line) twice at the most (though, its top-\/most and/or the bottom edge could be horizontal).


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em points} & a points \\
\hline
{\em color} & Polygon color.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillconvexpoly}{\tt org.\+opencv.\+core.\+Core.\+fill\+Convex\+Poly} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ad8378847b326f2e9edfba5c6ad68a171}\label{classorg_1_1opencv_1_1core_1_1_core_ad8378847b326f2e9edfba5c6ad68a171}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!fill\+Poly@{fill\+Poly}}
\index{fill\+Poly@{fill\+Poly}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{fill\+Poly()}{fillPoly()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+fill\+Poly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$}]{pts,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{line\+Type,  }\item[{int}]{shift,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{offset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Fills the area bounded by one or more polygons.

The function {\ttfamily fill\+Poly} fills an area bounded by several polygonal contours. The function can fill complex areas, for example, areas with holes, contours with self-\/intersections (some of their parts), and so forth.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em pts} & Array of polygons where each polygon is represented as an array of points. \\
\hline
{\em color} & Polygon color. \\
\hline
{\em line\+Type} & Type of the polygon boundaries. See the \char`\"{}line\char`\"{} description. \\
\hline
{\em shift} & Number of fractional bits in the vertex coordinates. \\
\hline
{\em offset} & Optional offset of all points of the contours.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillpoly}{\tt org.\+opencv.\+core.\+Core.\+fill\+Poly} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a315055271ede64d63610b0f03b31026b}\label{classorg_1_1opencv_1_1core_1_1_core_a315055271ede64d63610b0f03b31026b}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!fill\+Poly@{fill\+Poly}}
\index{fill\+Poly@{fill\+Poly}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{fill\+Poly()}{fillPoly()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+fill\+Poly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$}]{pts,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Fills the area bounded by one or more polygons.

The function {\ttfamily fill\+Poly} fills an area bounded by several polygonal contours. The function can fill complex areas, for example, areas with holes, contours with self-\/intersections (some of their parts), and so forth.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em pts} & Array of polygons where each polygon is represented as an array of points. \\
\hline
{\em color} & Polygon color.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#fillpoly}{\tt org.\+opencv.\+core.\+Core.\+fill\+Poly} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a386b6ad3e80eca8a6afa48a2e5423140}\label{classorg_1_1opencv_1_1core_1_1_core_a386b6ad3e80eca8a6afa48a2e5423140}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!find\+Non\+Zero@{find\+Non\+Zero}}
\index{find\+Non\+Zero@{find\+Non\+Zero}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{find\+Non\+Zero()}{findNonZero()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+find\+Non\+Zero (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{idx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a8dc68bbfca84b4fdfb9cd7bd79fc893e}\label{classorg_1_1opencv_1_1core_1_1_core_a8dc68bbfca84b4fdfb9cd7bd79fc893e}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!flip@{flip}}
\index{flip@{flip}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{flip()}{flip()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+flip (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{flip\+Code }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Flips a 2D array around vertical, horizontal, or both axes.

The function {\ttfamily flip} flips the array in one of three different ways (row and column indices are 0-\/based)\+:

{\itshape dst \+\_\+(ij) =\&lt\+BR\&gt $<$= ft(\&lt\+BR\&gt lt\+BR gtsrc \+\_\+(src.\+rows-\/i-\/1,j) if flip\+Code = 0 lt\+BR gtsrc \+\_\+(i, src.\+cols -\/j-\/1) if flip\+Code gt 0 lt\+BR gtsrc \+\_\+(src.\+rows -\/i-\/1, src.\+cols -\/j-\/1) if flip\+Code lt 0 lt\+BR gt\&lt\+BR\&gtright.}

The example scenarios of using the function are the following\+:


\begin{DoxyItemize}
\item Vertical flipping of the image ({\ttfamily flip\+Code == 0}) to switch between top-\/left and bottom-\/left image origin. This is a typical operation in video processing on Microsoft Windows$\ast$ OS. 
\item Horizontal flipping of the image with the subsequent horizontal shift and absolute difference calculation to check for a vertical-\/axis symmetry ({\ttfamily flip\+Code $>$ 0}). 
\item Simultaneous horizontal and vertical flipping of the image with the subsequent shift and absolute difference calculation to check for a central symmetry ({\ttfamily flip\+Code $<$ 0}). 
\item Reversing the order of point arrays ({\ttfamily flip\+Code $>$ 0} or {\ttfamily flip\+Code == 0}). 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}. \\
\hline
{\em flip\+Code} & a flag to specify how to flip the array; 0 means flipping around the x-\/axis and positive value (for example, 1) means flipping around y-\/axis. Negative value (for example, -\/1) means flipping around both axes (see the discussion below for the formulas).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#flip}{\tt org.\+opencv.\+core.\+Core.\+flip} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afcf15abfb6c9bf3a4126ae8199fc5ff3}{org.\+opencv.\+core.\+Core\+::repeat}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4536de6a43f5dfb4d4ba1bf24735696a}{org.\+opencv.\+core.\+Core\+::transpose}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad3a0199c2b0bbc9d254768b566fd257e}{org.\+opencv.\+core.\+Core\+::complete\+Symm}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a68aea4eb6784b0aaa0f5c0770fa7bde0}\label{classorg_1_1opencv_1_1core_1_1_core_a68aea4eb6784b0aaa0f5c0770fa7bde0}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!gemm@{gemm}}
\index{gemm@{gemm}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{gemm()}{gemm()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+gemm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{double}]{alpha,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src3,  }\item[{double}]{gamma,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs generalized matrix multiplication.

The function performs generalized matrix multiplication similar to the {\ttfamily gemm} functions in B\+L\+AS level 3. For example, {\ttfamily gemm(src1, src2, alpha, src3, beta, dst, G\+E\+M\+M\+\_\+1\+\_\+T + G\+E\+M\+M\+\_\+3\+\_\+T)} corresponds to

{\itshape dst = alpha $\ast$ src1 $^\wedge$T $\ast$ src2 + beta $\ast$ src3 $^\wedge$T\&lt\+BR\&gt\+The function can be replaced with a matrix expression. For example, the above call can be replaced with\+: \&lt\+BR\&gt\&ltcode\&gt}

// C++ code\+:

dst = alpha$\ast$src1.t()$\ast$src2 + beta$\ast$src3.t();


\begin{DoxyParams}{Parameters}
{\em src1} & first multiplied input matrix that should have {\ttfamily C\+V\+\_\+32\+F\+C1}, {\ttfamily C\+V\+\_\+64\+F\+C1}, {\ttfamily C\+V\+\_\+32\+F\+C2}, or {\ttfamily C\+V\+\_\+64\+F\+C2} type. \\
\hline
{\em src2} & second multiplied input matrix of the same type as {\ttfamily src1}. \\
\hline
{\em alpha} & weight of the matrix product. \\
\hline
{\em src3} & third optional delta matrix added to the matrix product; it should have the same type as {\ttfamily src1} and {\ttfamily src2}. \\
\hline
{\em gamma} & a gamma \\
\hline
{\em dst} & output matrix; it has the proper size and the same type as input matrices. \\
\hline
{\em flags} & operation flags\+: 
\begin{DoxyItemize}
\item G\+E\+M\+M\+\_\+1\+\_\+T transposes {\ttfamily src1}. 
\item G\+E\+M\+M\+\_\+2\+\_\+T transposes {\ttfamily src2}. 
\item G\+E\+M\+M\+\_\+3\+\_\+T transposes {\ttfamily src3}. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#gemm}{\tt org.\+opencv.\+core.\+Core.\+gemm} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aecfddbae696272a338eb12056603d4e9}{org.\+opencv.\+core.\+Core\+::mul\+Transposed}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a221e7697d1a57961ee8a843b7aa05b75}{org.\+opencv.\+core.\+Core\+::transform}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ae2574392283beecd4f987326489e38c4}\label{classorg_1_1opencv_1_1core_1_1_core_ae2574392283beecd4f987326489e38c4}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!gemm@{gemm}}
\index{gemm@{gemm}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{gemm()}{gemm()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+gemm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{double}]{alpha,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src3,  }\item[{double}]{gamma,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs generalized matrix multiplication.

The function performs generalized matrix multiplication similar to the {\ttfamily gemm} functions in B\+L\+AS level 3. For example, {\ttfamily gemm(src1, src2, alpha, src3, beta, dst, G\+E\+M\+M\+\_\+1\+\_\+T + G\+E\+M\+M\+\_\+3\+\_\+T)} corresponds to

{\itshape dst = alpha $\ast$ src1 $^\wedge$T $\ast$ src2 + beta $\ast$ src3 $^\wedge$T\&lt\+BR\&gt\+The function can be replaced with a matrix expression. For example, the above call can be replaced with\+: \&lt\+BR\&gt\&ltcode\&gt}

// C++ code\+:

dst = alpha$\ast$src1.t()$\ast$src2 + beta$\ast$src3.t();


\begin{DoxyParams}{Parameters}
{\em src1} & first multiplied input matrix that should have {\ttfamily C\+V\+\_\+32\+F\+C1}, {\ttfamily C\+V\+\_\+64\+F\+C1}, {\ttfamily C\+V\+\_\+32\+F\+C2}, or {\ttfamily C\+V\+\_\+64\+F\+C2} type. \\
\hline
{\em src2} & second multiplied input matrix of the same type as {\ttfamily src1}. \\
\hline
{\em alpha} & weight of the matrix product. \\
\hline
{\em src3} & third optional delta matrix added to the matrix product; it should have the same type as {\ttfamily src1} and {\ttfamily src2}. \\
\hline
{\em gamma} & a gamma \\
\hline
{\em dst} & output matrix; it has the proper size and the same type as input matrices.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#gemm}{\tt org.\+opencv.\+core.\+Core.\+gemm} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aecfddbae696272a338eb12056603d4e9}{org.\+opencv.\+core.\+Core\+::mul\+Transposed}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a221e7697d1a57961ee8a843b7aa05b75}{org.\+opencv.\+core.\+Core\+::transform}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a359cc7a14c10ba08bd29761bd9ec607c}\label{classorg_1_1opencv_1_1core_1_1_core_a359cc7a14c10ba08bd29761bd9ec607c}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!get\+Build\+Information@{get\+Build\+Information}}
\index{get\+Build\+Information@{get\+Build\+Information}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{get\+Build\+Information()}{getBuildInformation()}}
{\footnotesize\ttfamily static String org.\+opencv.\+core.\+Core.\+get\+Build\+Information (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns full configuration time cmake output.

Returned value is raw cmake output including version control system revision, compiler version, compiler flags, enabled modules and third party libraries, etc. Output format depends on target architecture.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#getbuildinformation}{\tt org.\+opencv.\+core.\+Core.\+get\+Build\+Information} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a63858b4080485f600e39a29c722a7a85}\label{classorg_1_1opencv_1_1core_1_1_core_a63858b4080485f600e39a29c722a7a85}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!get\+C\+P\+U\+Tick\+Count@{get\+C\+P\+U\+Tick\+Count}}
\index{get\+C\+P\+U\+Tick\+Count@{get\+C\+P\+U\+Tick\+Count}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{get\+C\+P\+U\+Tick\+Count()}{getCPUTickCount()}}
{\footnotesize\ttfamily static long org.\+opencv.\+core.\+Core.\+get\+C\+P\+U\+Tick\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the number of C\+PU ticks.

The function returns the current number of C\+PU ticks on some architectures (such as x86, x64, Power\+PC). On other platforms the function is equivalent to {\ttfamily get\+Tick\+Count}. It can also be used for very accurate time measurements, as well as for R\+NG initialization. Note that in case of multi-\/\+C\+PU systems a thread, from which {\ttfamily get\+C\+P\+U\+Tick\+Count} is called, can be suspended and resumed at another C\+PU with its own counter. So, theoretically (and practically) the subsequent calls to the function do not necessary return the monotonously increasing values. Also, since a modern C\+PU varies the C\+PU frequency depending on the load, the number of C\+PU clocks spent in some code cannot be directly converted to time units. Therefore, {\ttfamily get\+Tick\+Count} is generally a preferable solution for measuring execution time.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#getcputickcount}{\tt org.\+opencv.\+core.\+Core.\+get\+C\+P\+U\+Tick\+Count} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a4f58562c2297384087202e154b2b7555}\label{classorg_1_1opencv_1_1core_1_1_core_a4f58562c2297384087202e154b2b7555}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!get\+Number\+Of\+C\+P\+Us@{get\+Number\+Of\+C\+P\+Us}}
\index{get\+Number\+Of\+C\+P\+Us@{get\+Number\+Of\+C\+P\+Us}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{get\+Number\+Of\+C\+P\+Us()}{getNumberOfCPUs()}}
{\footnotesize\ttfamily static int org.\+opencv.\+core.\+Core.\+get\+Number\+Of\+C\+P\+Us (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the number of logical C\+P\+Us available for the process.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#getnumberofcpus}{\tt org.\+opencv.\+core.\+Core.\+get\+Number\+Of\+C\+P\+Us} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}\label{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!get\+Optimal\+D\+F\+T\+Size@{get\+Optimal\+D\+F\+T\+Size}}
\index{get\+Optimal\+D\+F\+T\+Size@{get\+Optimal\+D\+F\+T\+Size}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{get\+Optimal\+D\+F\+T\+Size()}{getOptimalDFTSize()}}
{\footnotesize\ttfamily static int org.\+opencv.\+core.\+Core.\+get\+Optimal\+D\+F\+T\+Size (\begin{DoxyParamCaption}\item[{int}]{vecsize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the optimal D\+FT size for a given vector size.

D\+FT performance is not a monotonic function of a vector size. Therefore, when you calculate convolution of two arrays or perform the spectral analysis of an array, it usually makes sense to pad the input data with zeros to get a bit larger array that can be transformed much faster than the original one. Arrays whose size is a power-\/of-\/two (2, 4, 8, 16, 32,...) are the fastest to process. Though, the arrays whose size is a product of 2\textquotesingle{}s, 3\textquotesingle{}s, and 5\textquotesingle{}s (for example, 300 = 5$\ast$5$\ast$3$\ast$2$\ast$2) are also processed quite efficiently.

The function {\ttfamily get\+Optimal\+D\+F\+T\+Size} returns the minimum number {\ttfamily N} that is greater than or equal to {\ttfamily vecsize} so that the D\+FT of a vector of size {\ttfamily N} can be processed efficiently. In the current implementation {\ttfamily N} = 2$^\wedge$\char`\"{}p\char`\"{} $\ast$ 3$^\wedge$\char`\"{}q\char`\"{} $\ast$ 5$^\wedge$\char`\"{}r\char`\"{} for some integer {\ttfamily p}, {\ttfamily q}, {\ttfamily r}.

The function returns a negative number if {\ttfamily vecsize} is too large (very close to {\ttfamily I\+N\+T\+\_\+\+M\+AX}).

While the function cannot be used directly to estimate the optimal vector size for D\+CT transform (since the current D\+CT implementation supports only even-\/size vectors), it can be easily processed as {\ttfamily get\+Optimal\+D\+F\+T\+Size((vecsize+1)/2)$\ast$2}.


\begin{DoxyParams}{Parameters}
{\em vecsize} & vector size.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#getoptimaldftsize}{\tt org.\+opencv.\+core.\+Core.\+get\+Optimal\+D\+F\+T\+Size} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1f0b3c28295d4db1ecd755201833d6cb}{org.\+opencv.\+core.\+Core\+::dct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a64eb690877f2d4ac16c1b1c3375c0b7b}{org.\+opencv.\+core.\+Core\+::idct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a249146033929c968ef948e290c2a438c}{org.\+opencv.\+core.\+Core\+::mul\+Spectrums}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4fc0b0f22fef014f5e602e8d5b367a44}{org.\+opencv.\+core.\+Core\+::idft}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ab6071e8e7cb8266aad46d7d95cb73fe7}\label{classorg_1_1opencv_1_1core_1_1_core_ab6071e8e7cb8266aad46d7d95cb73fe7}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!get\+Text\+Size@{get\+Text\+Size}}
\index{get\+Text\+Size@{get\+Text\+Size}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{get\+Text\+Size()}{getTextSize()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} org.\+opencv.\+core.\+Core.\+get\+Text\+Size (\begin{DoxyParamCaption}\item[{String}]{text,  }\item[{int}]{font\+Face,  }\item[{double}]{font\+Scale,  }\item[{int}]{thickness,  }\item[{int \mbox{[}$\,$\mbox{]}}]{base\+Line }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the width and height of a text string.

The function {\ttfamily get\+Text\+Size} calculates and returns the size of a box that contains the specified text.\+That is, the following code renders some text, the tight box surrounding it, and the baseline\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily string text = \char`\"{}\+Funny text inside the box\char`\"{};}

{\ttfamily }

{\ttfamily }

{\ttfamily int font\+Face = F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+S\+C\+R\+I\+P\+T\+\_\+\+S\+I\+M\+P\+L\+EX;}

{\ttfamily }

{\ttfamily }

{\ttfamily double font\+Scale = 2;}

{\ttfamily }

{\ttfamily }

{\ttfamily int thickness = 3;}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img(600, 800, C\+V\+\_\+8\+U\+C3, Scalar.\+all(0));}

{\ttfamily }

{\ttfamily }

{\ttfamily int baseline=0;}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} text\+Size = get\+Text\+Size(text, font\+Face,}

{\ttfamily }

{\ttfamily }

{\ttfamily font\+Scale, thickness, \&baseline);}

{\ttfamily }

{\ttfamily }

{\ttfamily baseline += thickness;}

{\ttfamily }

{\ttfamily }

{\ttfamily // center the text}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} text\+Org((img.\+cols -\/ text\+Size.\+width)/2,}

{\ttfamily }

{\ttfamily }

{\ttfamily (img.\+rows + text\+Size.\+height)/2);}

{\ttfamily }

{\ttfamily }

{\ttfamily // draw the box}

{\ttfamily }

{\ttfamily }

{\ttfamily rectangle(img, text\+Org + Point(0, baseline),}

{\ttfamily }

{\ttfamily }

{\ttfamily text\+Org + \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}(text\+Size.\+width, -\/text\+Size.\+height),}

{\ttfamily }

{\ttfamily }

{\ttfamily Scalar(0,0,255));}

{\ttfamily }

{\ttfamily }

{\ttfamily //... and the baseline first}

{\ttfamily }

{\ttfamily }

{\ttfamily line(img, text\+Org + Point(0, thickness),}

{\ttfamily }

{\ttfamily }

{\ttfamily text\+Org + \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}(text\+Size.\+width, thickness),}

{\ttfamily }

{\ttfamily }

{\ttfamily Scalar(0, 0, 255));}

{\ttfamily }

{\ttfamily }

{\ttfamily // then put the text itself}

{\ttfamily }

{\ttfamily }

{\ttfamily put\+Text(img, text, text\+Org, font\+Face, font\+Scale,}

{\ttfamily }

{\ttfamily }

{\ttfamily Scalar.\+all(255), thickness, 8);}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em text} & Input text string. \\
\hline
{\em font\+Face} & Font to use. See the \char`\"{}put\+Text\char`\"{} for details. \\
\hline
{\em font\+Scale} & Font scale. See the \char`\"{}put\+Text\char`\"{} for details. \\
\hline
{\em thickness} & Thickness of lines used to render the text. See \char`\"{}put\+Text\char`\"{} for details. \\
\hline
{\em base\+Line} & Output parameter -\/ y-\/coordinate of the baseline relative to the bottom-\/most text point.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#gettextsize}{\tt org.\+opencv.\+core.\+Core.\+get\+Text\+Size} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_adffc76724114188de1dcad5582ce7631}\label{classorg_1_1opencv_1_1core_1_1_core_adffc76724114188de1dcad5582ce7631}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!get\+Tick\+Count@{get\+Tick\+Count}}
\index{get\+Tick\+Count@{get\+Tick\+Count}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{get\+Tick\+Count()}{getTickCount()}}
{\footnotesize\ttfamily static long org.\+opencv.\+core.\+Core.\+get\+Tick\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the number of ticks.

The function returns the number of ticks after the certain event (for example, when the machine was turned on). It can be used to initialize \char`\"{}\+R\+N\+G\char`\"{} or to measure a function execution time by reading the tick count before and after the function call. See also the tick frequency.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#gettickcount}{\tt org.\+opencv.\+core.\+Core.\+get\+Tick\+Count} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_afc3677eba8a0186c9b92ebfa096301ec}\label{classorg_1_1opencv_1_1core_1_1_core_afc3677eba8a0186c9b92ebfa096301ec}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!get\+Tick\+Frequency@{get\+Tick\+Frequency}}
\index{get\+Tick\+Frequency@{get\+Tick\+Frequency}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{get\+Tick\+Frequency()}{getTickFrequency()}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+get\+Tick\+Frequency (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the number of ticks per second.

The function returns the number of ticks per second.\+That is, the following code computes the execution time in seconds\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily double t = (double)\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adffc76724114188de1dcad5582ce7631}{get\+Tick\+Count()}};}

{\ttfamily }

{\ttfamily }

{\ttfamily // do something...}

{\ttfamily }

{\ttfamily }

{\ttfamily t = ((double)\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adffc76724114188de1dcad5582ce7631}{get\+Tick\+Count()}} -\/ t)/get\+Tick\+Frequency();}

{\ttfamily }

{\ttfamily \begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/utility_and_system_functions_and_macros.html#gettickfrequency}{\tt org.\+opencv.\+core.\+Core.\+get\+Tick\+Frequency} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ae809cca27285b20fc31b42ffb7e5b5cb}\label{classorg_1_1opencv_1_1core_1_1_core_ae809cca27285b20fc31b42ffb7e5b5cb}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!hconcat@{hconcat}}
\index{hconcat@{hconcat}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{hconcat()}{hconcat()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+hconcat (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a64eb690877f2d4ac16c1b1c3375c0b7b}\label{classorg_1_1opencv_1_1core_1_1_core_a64eb690877f2d4ac16c1b1c3375c0b7b}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!idct@{idct}}
\index{idct@{idct}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{idct()}{idct()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+idct (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.

{\ttfamily idct(src, dst, flags)} is equivalent to {\ttfamily dct(src, dst, flags $\vert$ D\+C\+T\+\_\+\+I\+N\+V\+E\+R\+SE)}.


\begin{DoxyParams}{Parameters}
{\em src} & input floating-\/point single-\/channel array. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}. \\
\hline
{\em flags} & operation flags.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idct}{\tt org.\+opencv.\+core.\+Core.\+idct} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1f0b3c28295d4db1ecd755201833d6cb}{org.\+opencv.\+core.\+Core\+::dct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}{org.\+opencv.\+core.\+Core\+::get\+Optimal\+D\+F\+T\+Size}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4fc0b0f22fef014f5e602e8d5b367a44}{org.\+opencv.\+core.\+Core\+::idft}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a4f55e86b56025dd6bd516a43c2b7ad46}\label{classorg_1_1opencv_1_1core_1_1_core_a4f55e86b56025dd6bd516a43c2b7ad46}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!idct@{idct}}
\index{idct@{idct}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{idct()}{idct()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+idct (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.

{\ttfamily idct(src, dst, flags)} is equivalent to {\ttfamily dct(src, dst, flags $\vert$ D\+C\+T\+\_\+\+I\+N\+V\+E\+R\+SE)}.


\begin{DoxyParams}{Parameters}
{\em src} & input floating-\/point single-\/channel array. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idct}{\tt org.\+opencv.\+core.\+Core.\+idct} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1f0b3c28295d4db1ecd755201833d6cb}{org.\+opencv.\+core.\+Core\+::dct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}{org.\+opencv.\+core.\+Core\+::get\+Optimal\+D\+F\+T\+Size}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4fc0b0f22fef014f5e602e8d5b367a44}{org.\+opencv.\+core.\+Core\+::idft}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a4fc0b0f22fef014f5e602e8d5b367a44}\label{classorg_1_1opencv_1_1core_1_1_core_a4fc0b0f22fef014f5e602e8d5b367a44}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!idft@{idft}}
\index{idft@{idft}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{idft()}{idft()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+idft (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{flags,  }\item[{int}]{nonzero\+Rows }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.

{\ttfamily idft(src, dst, flags)} is equivalent to {\ttfamily dft(src, dst, flags $\vert$ D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE)}.

See \char`\"{}dft\char`\"{} for details.

Note\+: None of {\ttfamily dft} and {\ttfamily idft} scales the result by default. So, you should pass {\ttfamily D\+F\+T\+\_\+\+S\+C\+A\+LE} to one of {\ttfamily dft} or {\ttfamily idft} explicitly to make these transforms mutually inverse.


\begin{DoxyParams}{Parameters}
{\em src} & input floating-\/point real or complex array. \\
\hline
{\em dst} & output array whose size and type depend on the {\ttfamily flags}. \\
\hline
{\em flags} & operation flags (see \char`\"{}dft\char`\"{}). \\
\hline
{\em nonzero\+Rows} & number of {\ttfamily dst} rows to process; the rest of the rows have undefined content (see the convolution sample in \char`\"{}dft\char`\"{} description.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idft}{\tt org.\+opencv.\+core.\+Core.\+idft} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1f0b3c28295d4db1ecd755201833d6cb}{org.\+opencv.\+core.\+Core\+::dct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}{org.\+opencv.\+core.\+Core\+::get\+Optimal\+D\+F\+T\+Size}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a64eb690877f2d4ac16c1b1c3375c0b7b}{org.\+opencv.\+core.\+Core\+::idct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a249146033929c968ef948e290c2a438c}{org.\+opencv.\+core.\+Core\+::mul\+Spectrums}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a117c710f5f551746f7e4e836a271f853}\label{classorg_1_1opencv_1_1core_1_1_core_a117c710f5f551746f7e4e836a271f853}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!idft@{idft}}
\index{idft@{idft}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{idft()}{idft()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+idft (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.

{\ttfamily idft(src, dst, flags)} is equivalent to {\ttfamily dft(src, dst, flags $\vert$ D\+F\+T\+\_\+\+I\+N\+V\+E\+R\+SE)}.

See \char`\"{}dft\char`\"{} for details.

Note\+: None of {\ttfamily dft} and {\ttfamily idft} scales the result by default. So, you should pass {\ttfamily D\+F\+T\+\_\+\+S\+C\+A\+LE} to one of {\ttfamily dft} or {\ttfamily idft} explicitly to make these transforms mutually inverse.


\begin{DoxyParams}{Parameters}
{\em src} & input floating-\/point real or complex array. \\
\hline
{\em dst} & output array whose size and type depend on the {\ttfamily flags}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#idft}{\tt org.\+opencv.\+core.\+Core.\+idft} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1f0b3c28295d4db1ecd755201833d6cb}{org.\+opencv.\+core.\+Core\+::dct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}{org.\+opencv.\+core.\+Core\+::get\+Optimal\+D\+F\+T\+Size}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a64eb690877f2d4ac16c1b1c3375c0b7b}{org.\+opencv.\+core.\+Core\+::idct}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a249146033929c968ef948e290c2a438c}{org.\+opencv.\+core.\+Core\+::mul\+Spectrums}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_adda843559663a35e9a710c93b1f86096}\label{classorg_1_1opencv_1_1core_1_1_core_adda843559663a35e9a710c93b1f86096}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!in\+Range@{in\+Range}}
\index{in\+Range@{in\+Range}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{in\+Range()}{inRange()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+in\+Range (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{lowerb,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{upperb,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Checks if array elements lie between the elements of two other arrays.

The function checks the range as follows\+:


\begin{DoxyItemize}
\item For every element of a single-\/channel input array\+: 
\end{DoxyItemize}

{\itshape dst(\+I)= lowerb(\+I)\+\_\+0 $<$= src(\+I)\+\_\+0 $<$= upperb(\+I)\+\_\+0}


\begin{DoxyItemize}
\item For two-\/channel arrays\+: 
\end{DoxyItemize}

{\itshape dst(\+I)= lowerb(\+I)\+\_\+0 $<$= src(\+I)\+\_\+0 $<$= upperb(\+I)\+\_\+0 land lowerb(\+I)\+\_\+1 $<$= src(\+I)\+\_\+1 $<$= upperb(\+I)\+\_\+1}


\begin{DoxyItemize}
\item and so forth. 
\end{DoxyItemize}

That is, {\ttfamily dst} (I) is set to 255 (all {\ttfamily 1} -\/bits) if {\ttfamily src} (I) is within the specified 1D, 2D, 3D,... box and 0 otherwise.

When the lower and/or upper boundary parameters are scalars, the indexes {\ttfamily (I)} at {\ttfamily lowerb} and {\ttfamily upperb} in the above formulas should be omitted.


\begin{DoxyParams}{Parameters}
{\em src} & first input array. \\
\hline
{\em lowerb} & inclusive lower boundary array or a scalar. \\
\hline
{\em upperb} & inclusive upper boundary array or a scalar. \\
\hline
{\em dst} & output array of the same size as {\ttfamily src} and {\ttfamily C\+V\+\_\+8U} type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#inrange}{\tt org.\+opencv.\+core.\+Core.\+in\+Range} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aafde7d856dba7bb7446caf2caeb2dd20}\label{classorg_1_1opencv_1_1core_1_1_core_aafde7d856dba7bb7446caf2caeb2dd20}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!insert\+Channel@{insert\+Channel}}
\index{insert\+Channel@{insert\+Channel}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{insert\+Channel()}{insertChannel()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+insert\+Channel (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{coi }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_af7c788172a8e426cf6b6cedc8d828f1b}\label{classorg_1_1opencv_1_1core_1_1_core_af7c788172a8e426cf6b6cedc8d828f1b}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!invert@{invert}}
\index{invert@{invert}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{invert()}{invert()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+invert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the inverse or pseudo-\/inverse of a matrix.

The function {\ttfamily invert} inverts the matrix {\ttfamily src} and stores the result in {\ttfamily dst}. When the matrix {\ttfamily src} is singular or non-\/square, the function calculates the pseudo-\/inverse matrix (the {\ttfamily dst} matrix) so that {\ttfamily norm(src$\ast$dst -\/ I)} is minimal, where I is an identity matrix.

In case of the {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+LU} method, the function returns non-\/zero value if the inverse has been successfully calculated and 0 if {\ttfamily src} is singular.

In case of the {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+S\+VD} method, the function returns the inverse condition number of {\ttfamily src} (the ratio of the smallest singular value to the largest singular value) and 0 if {\ttfamily src} is singular. The S\+VD method calculates a pseudo-\/inverse matrix if {\ttfamily src} is singular.

Similarly to {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+LU}, the method {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+C\+H\+O\+L\+E\+S\+KY} works only with non-\/singular square matrices that should also be symmetrical and positively defined. In this case, the function stores the inverted matrix in {\ttfamily dst} and returns non-\/zero. Otherwise, it returns 0.


\begin{DoxyParams}{Parameters}
{\em src} & input floating-\/point {\ttfamily M x N} matrix. \\
\hline
{\em dst} & output matrix of {\ttfamily N x M} size and the same type as {\ttfamily src}. \\
\hline
{\em flags} & inversion method \+: 
\begin{DoxyItemize}
\item D\+E\+C\+O\+M\+P\+\_\+\+LU Gaussian elimination with the optimal pivot element chosen. 
\item D\+E\+C\+O\+M\+P\+\_\+\+S\+VD singular value decomposition (S\+VD) method. 
\item D\+E\+C\+O\+M\+P\+\_\+\+C\+H\+O\+L\+E\+S\+KY Cholesky decomposition; the matrix must be symmetrical and positively defined. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#invert}{\tt org.\+opencv.\+core.\+Core.\+invert} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af6e1ab8eaa1618c30a16e38da739bbeb}{org.\+opencv.\+core.\+Core\+::solve}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a454495bfa5d22875cd357fd28b537619}\label{classorg_1_1opencv_1_1core_1_1_core_a454495bfa5d22875cd357fd28b537619}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!invert@{invert}}
\index{invert@{invert}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{invert()}{invert()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+invert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the inverse or pseudo-\/inverse of a matrix.

The function {\ttfamily invert} inverts the matrix {\ttfamily src} and stores the result in {\ttfamily dst}. When the matrix {\ttfamily src} is singular or non-\/square, the function calculates the pseudo-\/inverse matrix (the {\ttfamily dst} matrix) so that {\ttfamily norm(src$\ast$dst -\/ I)} is minimal, where I is an identity matrix.

In case of the {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+LU} method, the function returns non-\/zero value if the inverse has been successfully calculated and 0 if {\ttfamily src} is singular.

In case of the {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+S\+VD} method, the function returns the inverse condition number of {\ttfamily src} (the ratio of the smallest singular value to the largest singular value) and 0 if {\ttfamily src} is singular. The S\+VD method calculates a pseudo-\/inverse matrix if {\ttfamily src} is singular.

Similarly to {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+LU}, the method {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+C\+H\+O\+L\+E\+S\+KY} works only with non-\/singular square matrices that should also be symmetrical and positively defined. In this case, the function stores the inverted matrix in {\ttfamily dst} and returns non-\/zero. Otherwise, it returns 0.


\begin{DoxyParams}{Parameters}
{\em src} & input floating-\/point {\ttfamily M x N} matrix. \\
\hline
{\em dst} & output matrix of {\ttfamily N x M} size and the same type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#invert}{\tt org.\+opencv.\+core.\+Core.\+invert} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af6e1ab8eaa1618c30a16e38da739bbeb}{org.\+opencv.\+core.\+Core\+::solve}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a9870d70cc55618004735e38a0931ab3a}\label{classorg_1_1opencv_1_1core_1_1_core_a9870d70cc55618004735e38a0931ab3a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!kmeans@{kmeans}}
\index{kmeans@{kmeans}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{kmeans()}{kmeans()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+kmeans (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{data,  }\item[{int}]{K,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{best\+Labels,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}}}]{criteria,  }\item[{int}]{attempts,  }\item[{int}]{flags,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{centers }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds centers of clusters and groups input samples around the clusters.

The function {\ttfamily kmeans} implements a k-\/means algorithm that finds the centers of {\ttfamily cluster\+\_\+count} clusters and groups the input samples around the clusters. As an output, {\itshape labels\+\_\+i} contains a 0-\/based cluster index for the sample stored in the {\itshape i$^\wedge$(th)} row of the {\ttfamily samples} matrix.

The function returns the compactness measure that is computed as

{\itshape sum \+\_\+i$\vert$samples \+\_\+i -\/ centers \+\_\+(labels \+\_\+i)$\vert$ $^\wedge$2}

after every attempt. The best (minimum) value is chosen and the corresponding labels and the compactness value are returned by the function. Basically, you can use only the core of the function, set the number of attempts to 1, initialize labels each time using a custom algorithm, pass them with the ({\ttfamily flags} = {\ttfamily K\+M\+E\+A\+N\+S\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+L\+A\+B\+E\+LS}) flag, and then choose the best (most-\/compact) clustering.

Note\+:


\begin{DoxyItemize}
\item An example on K-\/means clustering can be found at opencv\+\_\+source\+\_\+code/samples/cpp/kmeans.\+cpp 
\item (Python) An example on K-\/means clustering can be found at opencv\+\_\+source\+\_\+code/samples/python2/kmeans.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em data} & Data for clustering. \\
\hline
{\em K} & Number of clusters to split the set by. \\
\hline
{\em best\+Labels} & a best\+Labels \\
\hline
{\em criteria} & The algorithm termination criteria, that is, the maximum number of iterations and/or the desired accuracy. The accuracy is specified as {\ttfamily criteria.\+epsilon}. As soon as each of the cluster centers moves by less than {\ttfamily criteria.\+epsilon} on some iteration, the algorithm stops. \\
\hline
{\em attempts} & Flag to specify the number of times the algorithm is executed using different initial labellings. The algorithm returns the labels that yield the best compactness (see the last function parameter). \\
\hline
{\em flags} & Flag that can take the following values\+: 
\begin{DoxyItemize}
\item K\+M\+E\+A\+N\+S\+\_\+\+R\+A\+N\+D\+O\+M\+\_\+\+C\+E\+N\+T\+E\+RS Select random initial centers in each attempt. 
\item K\+M\+E\+A\+N\+S\+\_\+\+P\+P\+\_\+\+C\+E\+N\+T\+E\+RS Use {\ttfamily kmeans++} center initialization by Arthur and Vassilvitskii \mbox{[}Arthur2007\mbox{]}. 
\item K\+M\+E\+A\+N\+S\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+L\+A\+B\+E\+LS During the first (and possibly the only) attempt, use the user-\/supplied labels instead of computing them from the initial centers. For the second and further attempts, use the random or semi-\/random centers. Use one of {\ttfamily K\+M\+E\+A\+N\+S\+\_\+$\ast$\+\_\+\+C\+E\+N\+T\+E\+RS} flag to specify the exact method. 
\end{DoxyItemize}\\
\hline
{\em centers} & Output matrix of the cluster centers, one row per each cluster center.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/clustering.html#kmeans}{\tt org.\+opencv.\+core.\+Core.\+kmeans} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a5e0e7f71bc5434aedfbca27eb1a51450}\label{classorg_1_1opencv_1_1core_1_1_core_a5e0e7f71bc5434aedfbca27eb1a51450}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!kmeans@{kmeans}}
\index{kmeans@{kmeans}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{kmeans()}{kmeans()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+kmeans (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{data,  }\item[{int}]{K,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{best\+Labels,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}}}]{criteria,  }\item[{int}]{attempts,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds centers of clusters and groups input samples around the clusters.

The function {\ttfamily kmeans} implements a k-\/means algorithm that finds the centers of {\ttfamily cluster\+\_\+count} clusters and groups the input samples around the clusters. As an output, {\itshape labels\+\_\+i} contains a 0-\/based cluster index for the sample stored in the {\itshape i$^\wedge$(th)} row of the {\ttfamily samples} matrix.

The function returns the compactness measure that is computed as

{\itshape sum \+\_\+i$\vert$samples \+\_\+i -\/ centers \+\_\+(labels \+\_\+i)$\vert$ $^\wedge$2}

after every attempt. The best (minimum) value is chosen and the corresponding labels and the compactness value are returned by the function. Basically, you can use only the core of the function, set the number of attempts to 1, initialize labels each time using a custom algorithm, pass them with the ({\ttfamily flags} = {\ttfamily K\+M\+E\+A\+N\+S\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+L\+A\+B\+E\+LS}) flag, and then choose the best (most-\/compact) clustering.

Note\+:


\begin{DoxyItemize}
\item An example on K-\/means clustering can be found at opencv\+\_\+source\+\_\+code/samples/cpp/kmeans.\+cpp 
\item (Python) An example on K-\/means clustering can be found at opencv\+\_\+source\+\_\+code/samples/python2/kmeans.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em data} & Data for clustering. \\
\hline
{\em K} & Number of clusters to split the set by. \\
\hline
{\em best\+Labels} & a best\+Labels \\
\hline
{\em criteria} & The algorithm termination criteria, that is, the maximum number of iterations and/or the desired accuracy. The accuracy is specified as {\ttfamily criteria.\+epsilon}. As soon as each of the cluster centers moves by less than {\ttfamily criteria.\+epsilon} on some iteration, the algorithm stops. \\
\hline
{\em attempts} & Flag to specify the number of times the algorithm is executed using different initial labellings. The algorithm returns the labels that yield the best compactness (see the last function parameter). \\
\hline
{\em flags} & Flag that can take the following values\+: 
\begin{DoxyItemize}
\item K\+M\+E\+A\+N\+S\+\_\+\+R\+A\+N\+D\+O\+M\+\_\+\+C\+E\+N\+T\+E\+RS Select random initial centers in each attempt. 
\item K\+M\+E\+A\+N\+S\+\_\+\+P\+P\+\_\+\+C\+E\+N\+T\+E\+RS Use {\ttfamily kmeans++} center initialization by Arthur and Vassilvitskii \mbox{[}Arthur2007\mbox{]}. 
\item K\+M\+E\+A\+N\+S\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+L\+A\+B\+E\+LS During the first (and possibly the only) attempt, use the user-\/supplied labels instead of computing them from the initial centers. For the second and further attempts, use the random or semi-\/random centers. Use one of {\ttfamily K\+M\+E\+A\+N\+S\+\_\+$\ast$\+\_\+\+C\+E\+N\+T\+E\+RS} flag to specify the exact method. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/clustering.html#kmeans}{\tt org.\+opencv.\+core.\+Core.\+kmeans} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a9273ae8a7351870e645bd3a185af79b9}\label{classorg_1_1opencv_1_1core_1_1_core_a9273ae8a7351870e645bd3a185af79b9}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!line@{line}}
\index{line@{line}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{line()}{line()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+line (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness,  }\item[{int}]{line\+Type,  }\item[{int}]{shift }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a line segment connecting two points.

The function {\ttfamily line} draws the line segment between {\ttfamily pt1} and {\ttfamily pt2} points in the image. The line is clipped by the image boundaries. For non-\/antialiased lines with integer coordinates, the 8-\/connected or 4-\/connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering. To specify the line color, you may use the macro {\ttfamily C\+V\+\_\+\+R\+G\+B(r, g, b)}.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em pt1} & First point of the line segment. \\
\hline
{\em pt2} & Second point of the line segment. \\
\hline
{\em color} & Line color. \\
\hline
{\em thickness} & Line thickness. \\
\hline
{\em line\+Type} & Type of the line\+: 
\begin{DoxyItemize}
\item 8 (or omitted) -\/ 8-\/connected line. 
\item 4 -\/ 4-\/connected line. 
\item C\+V\+\_\+\+AA -\/ antialiased line. 
\end{DoxyItemize}\\
\hline
{\em shift} & Number of fractional bits in the point coordinates.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#line}{\tt org.\+opencv.\+core.\+Core.\+line} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aae5f5687ccac9691ecb1c5ee0d99575a}\label{classorg_1_1opencv_1_1core_1_1_core_aae5f5687ccac9691ecb1c5ee0d99575a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!line@{line}}
\index{line@{line}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{line()}{line()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+line (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a line segment connecting two points.

The function {\ttfamily line} draws the line segment between {\ttfamily pt1} and {\ttfamily pt2} points in the image. The line is clipped by the image boundaries. For non-\/antialiased lines with integer coordinates, the 8-\/connected or 4-\/connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering. To specify the line color, you may use the macro {\ttfamily C\+V\+\_\+\+R\+G\+B(r, g, b)}.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em pt1} & First point of the line segment. \\
\hline
{\em pt2} & Second point of the line segment. \\
\hline
{\em color} & Line color. \\
\hline
{\em thickness} & Line thickness.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#line}{\tt org.\+opencv.\+core.\+Core.\+line} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ae8bbb241c117c20adae94f394110473c}\label{classorg_1_1opencv_1_1core_1_1_core_ae8bbb241c117c20adae94f394110473c}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!line@{line}}
\index{line@{line}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{line()}{line()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+line (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a line segment connecting two points.

The function {\ttfamily line} draws the line segment between {\ttfamily pt1} and {\ttfamily pt2} points in the image. The line is clipped by the image boundaries. For non-\/antialiased lines with integer coordinates, the 8-\/connected or 4-\/connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering. To specify the line color, you may use the macro {\ttfamily C\+V\+\_\+\+R\+G\+B(r, g, b)}.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em pt1} & First point of the line segment. \\
\hline
{\em pt2} & Second point of the line segment. \\
\hline
{\em color} & Line color.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#line}{\tt org.\+opencv.\+core.\+Core.\+line} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a34d89a9c8e2562fc85bfecca3dca7d76}\label{classorg_1_1opencv_1_1core_1_1_core_a34d89a9c8e2562fc85bfecca3dca7d76}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!log@{log}}
\index{log@{log}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{log()}{log()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+log (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the natural logarithm of every array element.

The function {\ttfamily log} calculates the natural logarithm of the absolute value of every element of the input array\+:

{\itshape dst(\+I) = log$\vert$src(I)$\vert$ if src(\+I) != 0 ; C otherwise}

where {\ttfamily C} is a large negative number (about -\/700 in the current implementation). The maximum relative error is about {\ttfamily 7e-\/6} for single-\/precision input and less than {\ttfamily 1e-\/10} for double-\/precision input. Special values (NaN, Inf) are not handled.


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#log}{\tt org.\+opencv.\+core.\+Core.\+log} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a29c20af97ae09c75246777774bc6d41b}{org.\+opencv.\+core.\+Core\+::pow}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5a2235761d8876294b3277876479107b}{org.\+opencv.\+core.\+Core\+::sqrt}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{org.\+opencv.\+core.\+Core\+::magnitude}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a90c17a6d7e194cd8baf45819267a4539}{org.\+opencv.\+core.\+Core\+::polar\+To\+Cart}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a18688b13789043dfaa98161fe663f075}{org.\+opencv.\+core.\+Core\+::exp}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a09f94d89796effb89e2bff15c54b383a}{org.\+opencv.\+core.\+Core\+::phase}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a51b34caa90fa1c30524b3cb852d840d6}\label{classorg_1_1opencv_1_1core_1_1_core_a51b34caa90fa1c30524b3cb852d840d6}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!L\+UT@{L\+UT}}
\index{L\+UT@{L\+UT}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{L\+U\+T()}{LUT()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+L\+UT (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{lut,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{interpolation }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs a look-\/up table transform of an array.

The function {\ttfamily L\+UT} fills the output array with values from the look-\/up table. Indices of the entries are taken from the input array. That is, the function processes each element of {\ttfamily src} as follows\+:

{\itshape dst(\+I) $<$-\/ lut(src(\+I) + d)}

where

{\itshape d = 0 if src has depth C\+V\+\_\+8U; 128 if src has depth C\+V\+\_\+8S}


\begin{DoxyParams}{Parameters}
{\em src} & input array of 8-\/bit elements. \\
\hline
{\em lut} & look-\/up table of 256 elements; in case of multi-\/channel input array, the table should either have a single channel (in this case the same table is used for all channels) or the same number of channels as in the input array. \\
\hline
{\em dst} & output array of the same size and number of channels as {\ttfamily src}, and the same depth as {\ttfamily lut}. \\
\hline
{\em interpolation} & a interpolation\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#lut}{\tt org.\+opencv.\+core.\+Core.\+L\+UT} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a42f107c63200e26f87ddb11631980be7}{org.\+opencv.\+core.\+Core\+::convert\+Scale\+Abs}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a8536482ca714c4dc25fff4c48ae64bca}\label{classorg_1_1opencv_1_1core_1_1_core_a8536482ca714c4dc25fff4c48ae64bca}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!L\+UT@{L\+UT}}
\index{L\+UT@{L\+UT}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{L\+U\+T()}{LUT()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+L\+UT (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{lut,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs a look-\/up table transform of an array.

The function {\ttfamily L\+UT} fills the output array with values from the look-\/up table. Indices of the entries are taken from the input array. That is, the function processes each element of {\ttfamily src} as follows\+:

{\itshape dst(\+I) $<$-\/ lut(src(\+I) + d)}

where

{\itshape d = 0 if src has depth C\+V\+\_\+8U; 128 if src has depth C\+V\+\_\+8S}


\begin{DoxyParams}{Parameters}
{\em src} & input array of 8-\/bit elements. \\
\hline
{\em lut} & look-\/up table of 256 elements; in case of multi-\/channel input array, the table should either have a single channel (in this case the same table is used for all channels) or the same number of channels as in the input array. \\
\hline
{\em dst} & output array of the same size and number of channels as {\ttfamily src}, and the same depth as {\ttfamily lut}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#lut}{\tt org.\+opencv.\+core.\+Core.\+L\+UT} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a42f107c63200e26f87ddb11631980be7}{org.\+opencv.\+core.\+Core\+::convert\+Scale\+Abs}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}\label{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!magnitude@{magnitude}}
\index{magnitude@{magnitude}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{magnitude()}{magnitude()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+magnitude (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{x,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{y,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{magnitude }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the magnitude of 2D vectors.

The function {\ttfamily magnitude} calculates the magnitude of 2D vectors formed from the corresponding elements of {\ttfamily x} and {\ttfamily y} arrays\+:

{\itshape dst(\+I) = sqrt(x(\+I)$^\wedge$2 + y(\+I)$^\wedge$2)}


\begin{DoxyParams}{Parameters}
{\em x} & floating-\/point array of x-\/coordinates of the vectors. \\
\hline
{\em y} & floating-\/point array of y-\/coordinates of the vectors; it must have the same size as {\ttfamily x}. \\
\hline
{\em magnitude} & output array of the same size and type as {\ttfamily x}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#magnitude}{\tt org.\+opencv.\+core.\+Core.\+magnitude} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a09f94d89796effb89e2bff15c54b383a}{org.\+opencv.\+core.\+Core\+::phase}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5a2235761d8876294b3277876479107b}{org.\+opencv.\+core.\+Core\+::sqrt}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a90c17a6d7e194cd8baf45819267a4539}{org.\+opencv.\+core.\+Core\+::polar\+To\+Cart}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ae6da41381cc2fc87daa1a14a2c476781}\label{classorg_1_1opencv_1_1core_1_1_core_ae6da41381cc2fc87daa1a14a2c476781}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!Mahalanobis@{Mahalanobis}}
\index{Mahalanobis@{Mahalanobis}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{Mahalanobis()}{Mahalanobis()}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+Mahalanobis (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{v1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{v2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{icovar }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the Mahalanobis distance between two vectors.

The function {\ttfamily Mahalanobis} calculates and returns the weighted distance between two vectors\+:

{\itshape d(vec1, vec2)= sqrt(sum\+\_\+(i,j)(icovar(i,j)$\ast$(vec1(\+I)-\/vec2(I))$\ast$(vec1(j)-\/vec2(j))))}

The covariance matrix may be calculated using the \char`\"{}calc\+Covar\+Matrix\char`\"{} function and then inverted using the \char`\"{}invert\char`\"{} function (preferably using the {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+S\+VD} method, as the most accurate).


\begin{DoxyParams}{Parameters}
{\em v1} & a v1 \\
\hline
{\em v2} & a v2 \\
\hline
{\em icovar} & inverse covariance matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mahalanobis}{\tt org.\+opencv.\+core.\+Core.\+Mahalanobis} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aae8ad4feaca1ca8234bd88cbf9090cf5}\label{classorg_1_1opencv_1_1core_1_1_core_aae8ad4feaca1ca8234bd88cbf9090cf5}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!max@{max}}
\index{max@{max}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{max()}{max()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+max (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates per-\/element maximum of two arrays or an array and a scalar.

The functions {\ttfamily max} calculate the per-\/element maximum of two arrays\+:

{\itshape dst(\+I)= max(src1(\+I), src2(\+I))}

or array and a scalar\+:

{\itshape dst(\+I)= max(src1(\+I), value)}

In the second variant, when the input array is multi-\/channel, each channel is compared with {\ttfamily value} independently.

The first 3 variants of the function listed above are actually a part of \char`\"{}\+Matrix\+Expressions\char`\"{}. They return an expression object that can be further either transformed/ assigned to a matrix, or passed to a function, and so on.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src1}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#max}{\tt org.\+opencv.\+core.\+Core.\+max} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a6f1dc64655b7da1219d82f809efb7e16}{org.\+opencv.\+core.\+Core\+::compare}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adda843559663a35e9a710c93b1f86096}{org.\+opencv.\+core.\+Core\+::in\+Range}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}{org.\+opencv.\+core.\+Core\+::min\+Max\+Loc}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a24561bfde2c7fe7d2b7bee9d5ba8c92e}{org.\+opencv.\+core.\+Core\+::min}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aba74797cfade029693c6737957fe3b7f}\label{classorg_1_1opencv_1_1core_1_1_core_aba74797cfade029693c6737957fe3b7f}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!max@{max}}
\index{max@{max}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{max()}{max()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+max (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates per-\/element maximum of two arrays or an array and a scalar.

The functions {\ttfamily max} calculate the per-\/element maximum of two arrays\+:

{\itshape dst(\+I)= max(src1(\+I), src2(\+I))}

or array and a scalar\+:

{\itshape dst(\+I)= max(src1(\+I), value)}

In the second variant, when the input array is multi-\/channel, each channel is compared with {\ttfamily value} independently.

The first 3 variants of the function listed above are actually a part of \char`\"{}\+Matrix\+Expressions\char`\"{}. They return an expression object that can be further either transformed/ assigned to a matrix, or passed to a function, and so on.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src1}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#max}{\tt org.\+opencv.\+core.\+Core.\+max} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a6f1dc64655b7da1219d82f809efb7e16}{org.\+opencv.\+core.\+Core\+::compare}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adda843559663a35e9a710c93b1f86096}{org.\+opencv.\+core.\+Core\+::in\+Range}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}{org.\+opencv.\+core.\+Core\+::min\+Max\+Loc}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a24561bfde2c7fe7d2b7bee9d5ba8c92e}{org.\+opencv.\+core.\+Core\+::min}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}\label{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!mean@{mean}}
\index{mean@{mean}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{mean()}{mean()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} org.\+opencv.\+core.\+Core.\+mean (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates an average (mean) of array elements.

The function {\ttfamily mean} calculates the mean value {\ttfamily M} of array elements, independently for each channel, and return it\+:

{\itshape N = sum(by\+: I\+: mask(\+I) != 0) 1 M\+\_\+c = (sum(by\+: I\+: mask(\+I) != 0)(mtx(\+I)\+\_\+c))/N }

When all the mask elements are 0\textquotesingle{}s, the functions return {\ttfamily Scalar.\+all(0)}.


\begin{DoxyParams}{Parameters}
{\em src} & input array that should have from 1 to 4 channels so that the result can be stored in \char`\"{}\+Scalar\+\_\+\char`\"{}. \\
\hline
{\em mask} & optional operation mask.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mean}{\tt org.\+opencv.\+core.\+Core.\+mean} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a216308f36e765f82c521087fe283e045}{org.\+opencv.\+core.\+Core\+::count\+Non\+Zero}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af8d7fbb33c11fbf6115d4c242dbbb5b3}{org.\+opencv.\+core.\+Core\+::mean\+Std\+Dev}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}{org.\+opencv.\+core.\+Core\+::norm}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}{org.\+opencv.\+core.\+Core\+::min\+Max\+Loc}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a25ced9c1cf960900fbed712b13235dbd}\label{classorg_1_1opencv_1_1core_1_1_core_a25ced9c1cf960900fbed712b13235dbd}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!mean@{mean}}
\index{mean@{mean}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{mean()}{mean()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} org.\+opencv.\+core.\+Core.\+mean (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates an average (mean) of array elements.

The function {\ttfamily mean} calculates the mean value {\ttfamily M} of array elements, independently for each channel, and return it\+:

{\itshape N = sum(by\+: I\+: mask(\+I) != 0) 1 M\+\_\+c = (sum(by\+: I\+: mask(\+I) != 0)(mtx(\+I)\+\_\+c))/N }

When all the mask elements are 0\textquotesingle{}s, the functions return {\ttfamily Scalar.\+all(0)}.


\begin{DoxyParams}{Parameters}
{\em src} & input array that should have from 1 to 4 channels so that the result can be stored in \char`\"{}\+Scalar\+\_\+\char`\"{}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mean}{\tt org.\+opencv.\+core.\+Core.\+mean} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a216308f36e765f82c521087fe283e045}{org.\+opencv.\+core.\+Core\+::count\+Non\+Zero}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af8d7fbb33c11fbf6115d4c242dbbb5b3}{org.\+opencv.\+core.\+Core\+::mean\+Std\+Dev}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}{org.\+opencv.\+core.\+Core\+::norm}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}{org.\+opencv.\+core.\+Core\+::min\+Max\+Loc}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_af8d7fbb33c11fbf6115d4c242dbbb5b3}\label{classorg_1_1opencv_1_1core_1_1_core_af8d7fbb33c11fbf6115d4c242dbbb5b3}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!mean\+Std\+Dev@{mean\+Std\+Dev}}
\index{mean\+Std\+Dev@{mean\+Std\+Dev}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{mean\+Std\+Dev()}{meanStdDev()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+mean\+Std\+Dev (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}}}]{mean,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}}}]{stddev,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a mean and standard deviation of array elements.

The function {\ttfamily mean\+Std\+Dev} calculates the mean and the standard deviation {\ttfamily M} of array elements independently for each channel and returns it via the output parameters\+:

{\itshape N = sum(by\+: I, mask(\+I) != 0) 1 mean {\itshape c = (sum}(I\+: mask(\+I) != 0) src(\+I)\+\_\+c)/(N) stddev {\itshape c = sqrt((sum}(I\+: mask(\+I) != 0)(src(\+I)\+\_\+c -\/ mean \+\_\+c)$^\wedge$2)/(N)) }

When all the mask elements are 0\textquotesingle{}s, the functions return {\ttfamily mean=stddev=Scalar.\+all(0)}.

Note\+: The calculated standard deviation is only the diagonal of the complete normalized covariance matrix. If the full matrix is needed, you can reshape the multi-\/channel array {\ttfamily M x N} to the single-\/channel array {\ttfamily M$\ast$N x mtx.\+channels()} (only possible when the matrix is continuous) and then pass the matrix to \char`\"{}calc\+Covar\+Matrix\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em src} & input array that should have from 1 to 4 channels so that the results can be stored in \char`\"{}\+Scalar\+\_\+\char`\"{} \textquotesingle{}s. \\
\hline
{\em mean} & output parameter\+: calculated mean value. \\
\hline
{\em stddev} & output parameter\+: calculateded standard deviation. \\
\hline
{\em mask} & optional operation mask.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#meanstddev}{\tt org.\+opencv.\+core.\+Core.\+mean\+Std\+Dev} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a216308f36e765f82c521087fe283e045}{org.\+opencv.\+core.\+Core\+::count\+Non\+Zero}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afebca901f30f80a2a6db7a67cc2afb0a}{org.\+opencv.\+core.\+Core\+::calc\+Covar\+Matrix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}{org.\+opencv.\+core.\+Core\+::min\+Max\+Loc}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}{org.\+opencv.\+core.\+Core\+::norm}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{org.\+opencv.\+core.\+Core\+::mean}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a94a681b5485885aa1fbf868fc0718188}\label{classorg_1_1opencv_1_1core_1_1_core_a94a681b5485885aa1fbf868fc0718188}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!mean\+Std\+Dev@{mean\+Std\+Dev}}
\index{mean\+Std\+Dev@{mean\+Std\+Dev}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{mean\+Std\+Dev()}{meanStdDev()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+mean\+Std\+Dev (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}}}]{mean,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_double}{Mat\+Of\+Double}}}]{stddev }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a mean and standard deviation of array elements.

The function {\ttfamily mean\+Std\+Dev} calculates the mean and the standard deviation {\ttfamily M} of array elements independently for each channel and returns it via the output parameters\+:

{\itshape N = sum(by\+: I, mask(\+I) != 0) 1 mean {\itshape c = (sum}(I\+: mask(\+I) != 0) src(\+I)\+\_\+c)/(N) stddev {\itshape c = sqrt((sum}(I\+: mask(\+I) != 0)(src(\+I)\+\_\+c -\/ mean \+\_\+c)$^\wedge$2)/(N)) }

When all the mask elements are 0\textquotesingle{}s, the functions return {\ttfamily mean=stddev=Scalar.\+all(0)}.

Note\+: The calculated standard deviation is only the diagonal of the complete normalized covariance matrix. If the full matrix is needed, you can reshape the multi-\/channel array {\ttfamily M x N} to the single-\/channel array {\ttfamily M$\ast$N x mtx.\+channels()} (only possible when the matrix is continuous) and then pass the matrix to \char`\"{}calc\+Covar\+Matrix\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em src} & input array that should have from 1 to 4 channels so that the results can be stored in \char`\"{}\+Scalar\+\_\+\char`\"{} \textquotesingle{}s. \\
\hline
{\em mean} & output parameter\+: calculated mean value. \\
\hline
{\em stddev} & output parameter\+: calculateded standard deviation.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#meanstddev}{\tt org.\+opencv.\+core.\+Core.\+mean\+Std\+Dev} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a216308f36e765f82c521087fe283e045}{org.\+opencv.\+core.\+Core\+::count\+Non\+Zero}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afebca901f30f80a2a6db7a67cc2afb0a}{org.\+opencv.\+core.\+Core\+::calc\+Covar\+Matrix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}{org.\+opencv.\+core.\+Core\+::min\+Max\+Loc}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}{org.\+opencv.\+core.\+Core\+::norm}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{org.\+opencv.\+core.\+Core\+::mean}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_af245932b4a6d1aee20be9610388bb06a}\label{classorg_1_1opencv_1_1core_1_1_core_af245932b4a6d1aee20be9610388bb06a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!merge@{merge}}
\index{merge@{merge}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{merge()}{merge()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+merge (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{mv,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Creates one multichannel array out of several single-\/channel ones.

The functions {\ttfamily merge} merge several arrays to make a single multi-\/channel array. That is, each element of the output array will be a concatenation of the elements of the input arrays, where elements of i-\/th input array are treated as {\ttfamily mv\mbox{[}i\mbox{]}.channels()}-\/element vectors.

The function \char`\"{}split\char`\"{} does the reverse operation. If you need to shuffle channels in some other advanced way, use \char`\"{}mix\+Channels\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em mv} & input array or vector of matrices to be merged; all the matrices in {\ttfamily mv} must have the same size and the same depth. \\
\hline
{\em dst} & output array of the same size and the same depth as {\ttfamily mv\mbox{[}0\mbox{]}}; The number of channels will be the total number of channels in the matrix array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#merge}{\tt org.\+opencv.\+core.\+Core.\+merge} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ac272e7518dba0da8e7480df63163040b}{org.\+opencv.\+core.\+Mat\+::reshape}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a812a71941c37c615cb474bff0eacbb2e}{org.\+opencv.\+core.\+Core\+::mix\+Channels}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa22f046c4f14cda50c10f5d22ffdbb26}{org.\+opencv.\+core.\+Core\+::split}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a24561bfde2c7fe7d2b7bee9d5ba8c92e}\label{classorg_1_1opencv_1_1core_1_1_core_a24561bfde2c7fe7d2b7bee9d5ba8c92e}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!min@{min}}
\index{min@{min}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{min()}{min()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+min (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates per-\/element minimum of two arrays or an array and a scalar.

The functions {\ttfamily min} calculate the per-\/element minimum of two arrays\+:

{\itshape dst(\+I)= min(src1(\+I), src2(\+I))}

or array and a scalar\+:

{\itshape dst(\+I)= min(src1(\+I), value)}

In the second variant, when the input array is multi-\/channel, each channel is compared with {\ttfamily value} independently.

The first three variants of the function listed above are actually a part of \char`\"{}\+Matrix\+Expressions\char`\"{}. They return the expression object that can be further either transformed/assigned to a matrix, or passed to a function, and so on.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src1}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#min}{\tt org.\+opencv.\+core.\+Core.\+min} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aae8ad4feaca1ca8234bd88cbf9090cf5}{org.\+opencv.\+core.\+Core\+::max}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a6f1dc64655b7da1219d82f809efb7e16}{org.\+opencv.\+core.\+Core\+::compare}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adda843559663a35e9a710c93b1f86096}{org.\+opencv.\+core.\+Core\+::in\+Range}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}{org.\+opencv.\+core.\+Core\+::min\+Max\+Loc}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a89f8b6dddb1448f5e525dbe8a0a4390f}\label{classorg_1_1opencv_1_1core_1_1_core_a89f8b6dddb1448f5e525dbe8a0a4390f}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!min@{min}}
\index{min@{min}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{min()}{min()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+min (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates per-\/element minimum of two arrays or an array and a scalar.

The functions {\ttfamily min} calculate the per-\/element minimum of two arrays\+:

{\itshape dst(\+I)= min(src1(\+I), src2(\+I))}

or array and a scalar\+:

{\itshape dst(\+I)= min(src1(\+I), value)}

In the second variant, when the input array is multi-\/channel, each channel is compared with {\ttfamily value} independently.

The first three variants of the function listed above are actually a part of \char`\"{}\+Matrix\+Expressions\char`\"{}. They return the expression object that can be further either transformed/assigned to a matrix, or passed to a function, and so on.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src1}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#min}{\tt org.\+opencv.\+core.\+Core.\+min} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aae8ad4feaca1ca8234bd88cbf9090cf5}{org.\+opencv.\+core.\+Core\+::max}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a6f1dc64655b7da1219d82f809efb7e16}{org.\+opencv.\+core.\+Core\+::compare}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adda843559663a35e9a710c93b1f86096}{org.\+opencv.\+core.\+Core\+::in\+Range}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}{org.\+opencv.\+core.\+Core\+::min\+Max\+Loc}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}\label{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!min\+Max\+Loc@{min\+Max\+Loc}}
\index{min\+Max\+Loc@{min\+Max\+Loc}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{min\+Max\+Loc()}{minMaxLoc()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static Min\+Max\+Loc\+Result org.\+opencv.\+core.\+Core.\+min\+Max\+Loc (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the global minimum and maximum in an array.

The functions {\ttfamily min\+Max\+Loc} find the minimum and maximum element values and their positions. The extremums are searched across the whole array or, if {\ttfamily mask} is not an empty array, in the specified array region.

The functions do not work with multi-\/channel arrays. If you need to find minimum or maximum elements across all the channels, use \char`\"{}\+Mat.\+reshape\char`\"{} first to reinterpret the array as single-\/channel. Or you may extract the particular channel using either \char`\"{}extract\+Image\+C\+O\+I\char`\"{}, or \char`\"{}mix\+Channels\char`\"{}, or \char`\"{}split\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em src} & input single-\/channel array. \\
\hline
{\em mask} & optional mask used to select a sub-\/array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#minmaxloc}{\tt org.\+opencv.\+core.\+Core.\+min\+Max\+Loc} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a6f1dc64655b7da1219d82f809efb7e16}{org.\+opencv.\+core.\+Core\+::compare}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a24561bfde2c7fe7d2b7bee9d5ba8c92e}{org.\+opencv.\+core.\+Core\+::min}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a812a71941c37c615cb474bff0eacbb2e}{org.\+opencv.\+core.\+Core\+::mix\+Channels}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ac272e7518dba0da8e7480df63163040b}{org.\+opencv.\+core.\+Mat\+::reshape}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa22f046c4f14cda50c10f5d22ffdbb26}{org.\+opencv.\+core.\+Core\+::split}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aae8ad4feaca1ca8234bd88cbf9090cf5}{org.\+opencv.\+core.\+Core\+::max}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adda843559663a35e9a710c93b1f86096}{org.\+opencv.\+core.\+Core\+::in\+Range}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_af85a1994a360e2c955622a2583de1d81}\label{classorg_1_1opencv_1_1core_1_1_core_af85a1994a360e2c955622a2583de1d81}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!min\+Max\+Loc@{min\+Max\+Loc}}
\index{min\+Max\+Loc@{min\+Max\+Loc}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{min\+Max\+Loc()}{minMaxLoc()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static Min\+Max\+Loc\+Result org.\+opencv.\+core.\+Core.\+min\+Max\+Loc (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the global minimum and maximum in an array.

The functions {\ttfamily min\+Max\+Loc} find the minimum and maximum element values and their positions. The extremums are searched across the whole array or, if {\ttfamily mask} is not an empty array, in the specified array region.

The functions do not work with multi-\/channel arrays. If you need to find minimum or maximum elements across all the channels, use \char`\"{}\+Mat.\+reshape\char`\"{} first to reinterpret the array as single-\/channel. Or you may extract the particular channel using either \char`\"{}extract\+Image\+C\+O\+I\char`\"{}, or \char`\"{}mix\+Channels\char`\"{}, or \char`\"{}split\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em src} & input single-\/channel array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#minmaxloc}{\tt org.\+opencv.\+core.\+Core.\+min\+Max\+Loc} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a6f1dc64655b7da1219d82f809efb7e16}{org.\+opencv.\+core.\+Core\+::compare}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a24561bfde2c7fe7d2b7bee9d5ba8c92e}{org.\+opencv.\+core.\+Core\+::min}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a812a71941c37c615cb474bff0eacbb2e}{org.\+opencv.\+core.\+Core\+::mix\+Channels}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ac272e7518dba0da8e7480df63163040b}{org.\+opencv.\+core.\+Mat\+::reshape}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa22f046c4f14cda50c10f5d22ffdbb26}{org.\+opencv.\+core.\+Core\+::split}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aae8ad4feaca1ca8234bd88cbf9090cf5}{org.\+opencv.\+core.\+Core\+::max}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adda843559663a35e9a710c93b1f86096}{org.\+opencv.\+core.\+Core\+::in\+Range}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a812a71941c37c615cb474bff0eacbb2e}\label{classorg_1_1opencv_1_1core_1_1_core_a812a71941c37c615cb474bff0eacbb2e}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!mix\+Channels@{mix\+Channels}}
\index{mix\+Channels@{mix\+Channels}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{mix\+Channels()}{mixChannels()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+mix\+Channels (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{src,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}}}]{from\+To }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Copies specified channels from input arrays to the specified channels of output arrays.

The functions {\ttfamily mix\+Channels} provide an advanced mechanism for shuffling image channels.

\char`\"{}split\char`\"{} and \char`\"{}merge\char`\"{} and some forms of \char`\"{}cvt\+Color\char`\"{} are partial cases of {\ttfamily mix\+Channels}. In the example below, the code splits a 4-\/channel R\+G\+BA image into a 3-\/channel B\+GR (with \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} and B channels swapped) and a separate alpha-\/channel image\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} rgba(100, 100, C\+V\+\_\+8\+U\+C4, Scalar(1,2,3,4));}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} bgr(rgba.\+rows, rgba.\+cols, C\+V\+\_\+8\+U\+C3);}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} alpha(rgba.\+rows, rgba.\+cols, C\+V\+\_\+8\+U\+C1);}

{\ttfamily }

{\ttfamily }

{\ttfamily // forming an array of matrices is a quite efficient operation,}

{\ttfamily }

{\ttfamily }

{\ttfamily // because the matrix data is not copied, only the headers}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} out\mbox{[}\mbox{]} = \{ bgr, alpha \};}

{\ttfamily }

{\ttfamily }

{\ttfamily // rgba\mbox{[}0\mbox{]} -\/$>$ bgr\mbox{[}2\mbox{]}, rgba\mbox{[}1\mbox{]} -\/$>$ bgr\mbox{[}1\mbox{]},}

{\ttfamily }

{\ttfamily }

{\ttfamily // rgba\mbox{[}2\mbox{]} -\/$>$ bgr\mbox{[}0\mbox{]}, rgba\mbox{[}3\mbox{]} -\/$>$ alpha\mbox{[}0\mbox{]}}

{\ttfamily }

{\ttfamily }

{\ttfamily int from\+\_\+to\mbox{[}\mbox{]} = \{ 0,2, 1,1, 2,0, 3,3 \};}

{\ttfamily }

{\ttfamily }

{\ttfamily mix\+Channels(\&rgba, 1, out, 2, from\+\_\+to, 4);}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: Unlike many other new-\/style C++ functions in Open\+CV (see the introduction section and \char`\"{}\+Mat.\+create\char`\"{}), {\ttfamily mix\+Channels} requires the output arrays to be pre-\/allocated before calling the function. }


\begin{DoxyParams}{Parameters}
{\em src} & input array or vector of matricesl; all of the matrices must have the same size and the same depth. \\
\hline
{\em dst} & output array or vector of matrices; all the matrices {\itshape must be allocated}; their size and depth must be the same as in {\ttfamily src\mbox{[}0\mbox{]}}. \\
\hline
{\em from\+To} & array of index pairs specifying which channels are copied and where; {\ttfamily from\+To\mbox{[}k$\ast$2\mbox{]}} is a 0-\/based index of the input channel in {\ttfamily src}, {\ttfamily from\+To\mbox{[}k$\ast$2+1\mbox{]}} is an index of the output channel in {\ttfamily dst}; the continuous channel numbering is used\+: the first input image channels are indexed from {\ttfamily 0} to {\ttfamily src\mbox{[}0\mbox{]}.channels()-\/1}, the second input image channels are indexed from {\ttfamily src\mbox{[}0\mbox{]}.channels()} to {\ttfamily src\mbox{[}0\mbox{]}.channels() + src\mbox{[}1\mbox{]}.channels()-\/1}, and so on, the same scheme is used for the output image channels; as a special case, when {\ttfamily from\+To\mbox{[}k$\ast$2\mbox{]}} is negative, the corresponding output channel is filled with zero.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mixchannels}{\tt org.\+opencv.\+core.\+Core.\+mix\+Channels} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af245932b4a6d1aee20be9610388bb06a}{org.\+opencv.\+core.\+Core\+::merge}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aa22f046c4f14cda50c10f5d22ffdbb26}{org.\+opencv.\+core.\+Core\+::split}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab8fb70fea379b4215a77122d698d860d}{org.\+opencv.\+imgproc.\+Imgproc\+::cvt\+Color}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a249146033929c968ef948e290c2a438c}\label{classorg_1_1opencv_1_1core_1_1_core_a249146033929c968ef948e290c2a438c}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!mul\+Spectrums@{mul\+Spectrums}}
\index{mul\+Spectrums@{mul\+Spectrums}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{mul\+Spectrums()}{mulSpectrums()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+mul\+Spectrums (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{a,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{b,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{c,  }\item[{int}]{flags,  }\item[{boolean}]{conjB }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs the per-\/element multiplication of two Fourier spectrums.

The function {\ttfamily mul\+Spectrums} performs the per-\/element multiplication of the two C\+C\+S-\/packed or complex matrices that are results of a real or complex Fourier transform.

The function, together with \char`\"{}dft\char`\"{} and \char`\"{}idft\char`\"{}, may be used to calculate convolution (pass {\ttfamily conjB=false}) or correlation (pass {\ttfamily conjB=true}) of two arrays rapidly. When the arrays are complex, they are simply multiplied (per element) with an optional conjugation of the second-\/array elements. When the arrays are real, they are assumed to be C\+C\+S-\/packed (see \char`\"{}dft\char`\"{} for details).


\begin{DoxyParams}{Parameters}
{\em a} & a a \\
\hline
{\em b} & a b \\
\hline
{\em c} & a c \\
\hline
{\em flags} & operation flags; currently, the only supported flag is {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS}, which indicates that each row of {\ttfamily src1} and {\ttfamily src2} is an independent 1D Fourier spectrum. \\
\hline
{\em conjB} & optional flag that conjugates the second input array before the multiplication (true) or not (false).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mulspectrums}{\tt org.\+opencv.\+core.\+Core.\+mul\+Spectrums} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a781f8481b692f31be8a086df59de3eab}\label{classorg_1_1opencv_1_1core_1_1_core_a781f8481b692f31be8a086df59de3eab}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!mul\+Spectrums@{mul\+Spectrums}}
\index{mul\+Spectrums@{mul\+Spectrums}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{mul\+Spectrums()}{mulSpectrums()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+mul\+Spectrums (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{a,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{b,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{c,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs the per-\/element multiplication of two Fourier spectrums.

The function {\ttfamily mul\+Spectrums} performs the per-\/element multiplication of the two C\+C\+S-\/packed or complex matrices that are results of a real or complex Fourier transform.

The function, together with \char`\"{}dft\char`\"{} and \char`\"{}idft\char`\"{}, may be used to calculate convolution (pass {\ttfamily conjB=false}) or correlation (pass {\ttfamily conjB=true}) of two arrays rapidly. When the arrays are complex, they are simply multiplied (per element) with an optional conjugation of the second-\/array elements. When the arrays are real, they are assumed to be C\+C\+S-\/packed (see \char`\"{}dft\char`\"{} for details).


\begin{DoxyParams}{Parameters}
{\em a} & a a \\
\hline
{\em b} & a b \\
\hline
{\em c} & a c \\
\hline
{\em flags} & operation flags; currently, the only supported flag is {\ttfamily D\+F\+T\+\_\+\+R\+O\+WS}, which indicates that each row of {\ttfamily src1} and {\ttfamily src2} is an independent 1D Fourier spectrum.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#mulspectrums}{\tt org.\+opencv.\+core.\+Core.\+mul\+Spectrums} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aa49b10c74b442ec7cc890f9ce812918a}\label{classorg_1_1opencv_1_1core_1_1_core_aa49b10c74b442ec7cc890f9ce812918a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!multiply@{multiply}}
\index{multiply@{multiply}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{multiply()}{multiply()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+multiply (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{scale,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element scaled product of two arrays.

The function {\ttfamily multiply} calculates the per-\/element product of two arrays\+:

{\itshape dst(\+I)= saturate(scale $\ast$ src1(\+I) $\ast$ src2(\+I))}

There is also a \char`\"{}\+Matrix\+Expressions\char`\"{} -\/friendly variant of the first function. See \char`\"{}\+Mat.\+mul\char`\"{}.

For a not-\/per-\/element matrix product, see \char`\"{}gemm\char`\"{}.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and the same type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src1}. \\
\hline
{\em scale} & optional scale factor. \\
\hline
{\em dtype} & a dtype\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply}{\tt org.\+opencv.\+core.\+Core.\+multiply} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad0cc67e80d303076c4a8d486fe6b82c9}{org.\+opencv.\+core.\+Core\+::divide}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ae8964daf7682cfd4170fae06b195939d}\label{classorg_1_1opencv_1_1core_1_1_core_ae8964daf7682cfd4170fae06b195939d}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!multiply@{multiply}}
\index{multiply@{multiply}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{multiply()}{multiply()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+multiply (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{scale }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element scaled product of two arrays.

The function {\ttfamily multiply} calculates the per-\/element product of two arrays\+:

{\itshape dst(\+I)= saturate(scale $\ast$ src1(\+I) $\ast$ src2(\+I))}

There is also a \char`\"{}\+Matrix\+Expressions\char`\"{} -\/friendly variant of the first function. See \char`\"{}\+Mat.\+mul\char`\"{}.

For a not-\/per-\/element matrix product, see \char`\"{}gemm\char`\"{}.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and the same type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src1}. \\
\hline
{\em scale} & optional scale factor.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply}{\tt org.\+opencv.\+core.\+Core.\+multiply} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad0cc67e80d303076c4a8d486fe6b82c9}{org.\+opencv.\+core.\+Core\+::divide}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ad159823509d5f6cfac9839f7589f9a7e}\label{classorg_1_1opencv_1_1core_1_1_core_ad159823509d5f6cfac9839f7589f9a7e}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!multiply@{multiply}}
\index{multiply@{multiply}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{multiply()}{multiply()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+multiply (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element scaled product of two arrays.

The function {\ttfamily multiply} calculates the per-\/element product of two arrays\+:

{\itshape dst(\+I)= saturate(scale $\ast$ src1(\+I) $\ast$ src2(\+I))}

There is also a \char`\"{}\+Matrix\+Expressions\char`\"{} -\/friendly variant of the first function. See \char`\"{}\+Mat.\+mul\char`\"{}.

For a not-\/per-\/element matrix product, see \char`\"{}gemm\char`\"{}.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and the same type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src1}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply}{\tt org.\+opencv.\+core.\+Core.\+multiply} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad0cc67e80d303076c4a8d486fe6b82c9}{org.\+opencv.\+core.\+Core\+::divide}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a1b59367e832360dfa8cef944ecbc17ec}\label{classorg_1_1opencv_1_1core_1_1_core_a1b59367e832360dfa8cef944ecbc17ec}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!multiply@{multiply}}
\index{multiply@{multiply}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{multiply()}{multiply()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+multiply (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{scale,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element scaled product of two arrays.

The function {\ttfamily multiply} calculates the per-\/element product of two arrays\+:

{\itshape dst(\+I)= saturate(scale $\ast$ src1(\+I) $\ast$ src2(\+I))}

There is also a \char`\"{}\+Matrix\+Expressions\char`\"{} -\/friendly variant of the first function. See \char`\"{}\+Mat.\+mul\char`\"{}.

For a not-\/per-\/element matrix product, see \char`\"{}gemm\char`\"{}.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and the same type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src1}. \\
\hline
{\em scale} & optional scale factor. \\
\hline
{\em dtype} & a dtype\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply}{\tt org.\+opencv.\+core.\+Core.\+multiply} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad0cc67e80d303076c4a8d486fe6b82c9}{org.\+opencv.\+core.\+Core\+::divide}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a9ba18c691a0cb984dcb9408e3d6721fb}\label{classorg_1_1opencv_1_1core_1_1_core_a9ba18c691a0cb984dcb9408e3d6721fb}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!multiply@{multiply}}
\index{multiply@{multiply}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{multiply()}{multiply()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+multiply (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{scale }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element scaled product of two arrays.

The function {\ttfamily multiply} calculates the per-\/element product of two arrays\+:

{\itshape dst(\+I)= saturate(scale $\ast$ src1(\+I) $\ast$ src2(\+I))}

There is also a \char`\"{}\+Matrix\+Expressions\char`\"{} -\/friendly variant of the first function. See \char`\"{}\+Mat.\+mul\char`\"{}.

For a not-\/per-\/element matrix product, see \char`\"{}gemm\char`\"{}.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and the same type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src1}. \\
\hline
{\em scale} & optional scale factor.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply}{\tt org.\+opencv.\+core.\+Core.\+multiply} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad0cc67e80d303076c4a8d486fe6b82c9}{org.\+opencv.\+core.\+Core\+::divide}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a248747a674dce2ed86c45e4d66caaddf}\label{classorg_1_1opencv_1_1core_1_1_core_a248747a674dce2ed86c45e4d66caaddf}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!multiply@{multiply}}
\index{multiply@{multiply}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{multiply()}{multiply()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+multiply (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element scaled product of two arrays.

The function {\ttfamily multiply} calculates the per-\/element product of two arrays\+:

{\itshape dst(\+I)= saturate(scale $\ast$ src1(\+I) $\ast$ src2(\+I))}

There is also a \char`\"{}\+Matrix\+Expressions\char`\"{} -\/friendly variant of the first function. See \char`\"{}\+Mat.\+mul\char`\"{}.

For a not-\/per-\/element matrix product, see \char`\"{}gemm\char`\"{}.

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and the same type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src1}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multiply}{\tt org.\+opencv.\+core.\+Core.\+multiply} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ad0cc67e80d303076c4a8d486fe6b82c9}{org.\+opencv.\+core.\+Core\+::divide}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aecfddbae696272a338eb12056603d4e9}\label{classorg_1_1opencv_1_1core_1_1_core_aecfddbae696272a338eb12056603d4e9}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!mul\+Transposed@{mul\+Transposed}}
\index{mul\+Transposed@{mul\+Transposed}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{mul\+Transposed()}{mulTransposed()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+mul\+Transposed (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{boolean}]{a\+Ta,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{delta,  }\item[{double}]{scale,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the product of a matrix and its transposition.

The function {\ttfamily mul\+Transposed} calculates the product of {\ttfamily src} and its transposition\+:

{\itshape dst = scale(src -\/ delta)$^\wedge$T(src -\/ delta)}

if {\ttfamily a\+Ta=true}, and

{\itshape dst = scale(src -\/ delta)(src -\/ delta)$^\wedge$T}

otherwise. The function is used to calculate the covariance matrix. With zero delta, it can be used as a faster substitute for general matrix product {\ttfamily A$\ast$B} when {\ttfamily B=A\textquotesingle{}}


\begin{DoxyParams}{Parameters}
{\em src} & input single-\/channel matrix. Note that unlike \char`\"{}gemm\char`\"{}, the function can multiply not only floating-\/point matrices. \\
\hline
{\em dst} & output square matrix. \\
\hline
{\em a\+Ta} & Flag specifying the multiplication ordering. See the description below. \\
\hline
{\em delta} & Optional delta matrix subtracted from {\ttfamily src} before the multiplication. When the matrix is empty ({\ttfamily delta=no\+Array()}), it is assumed to be zero, that is, nothing is subtracted. If it has the same size as {\ttfamily src}, it is simply subtracted. Otherwise, it is \char`\"{}repeated\char`\"{} (see \char`\"{}repeat\char`\"{}) to cover the full {\ttfamily src} and then subtracted. Type of the delta matrix, when it is not empty, must be the same as the type of created output matrix. See the {\ttfamily dtype} parameter description below. \\
\hline
{\em scale} & Optional scale factor for the matrix product. \\
\hline
{\em dtype} & Optional type of the output matrix. When it is negative, the output matrix will have the same type as {\ttfamily src}. Otherwise, it will be {\ttfamily type=C\+V\+\_\+\+M\+A\+T\+\_\+\+D\+E\+P\+T\+H(dtype)} that should be either {\ttfamily C\+V\+\_\+32F} or {\ttfamily C\+V\+\_\+64F}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multransposed}{\tt org.\+opencv.\+core.\+Core.\+mul\+Transposed} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afebca901f30f80a2a6db7a67cc2afb0a}{org.\+opencv.\+core.\+Core\+::calc\+Covar\+Matrix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afcf15abfb6c9bf3a4126ae8199fc5ff3}{org.\+opencv.\+core.\+Core\+::repeat}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1849fb31954ac7655a174184f2eba671}{org.\+opencv.\+core.\+Core\+::reduce}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a68aea4eb6784b0aaa0f5c0770fa7bde0}{org.\+opencv.\+core.\+Core\+::gemm}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ac98f79bd02ed3a8202f516f2bf6c0053}\label{classorg_1_1opencv_1_1core_1_1_core_ac98f79bd02ed3a8202f516f2bf6c0053}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!mul\+Transposed@{mul\+Transposed}}
\index{mul\+Transposed@{mul\+Transposed}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{mul\+Transposed()}{mulTransposed()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+mul\+Transposed (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{boolean}]{a\+Ta,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{delta,  }\item[{double}]{scale }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the product of a matrix and its transposition.

The function {\ttfamily mul\+Transposed} calculates the product of {\ttfamily src} and its transposition\+:

{\itshape dst = scale(src -\/ delta)$^\wedge$T(src -\/ delta)}

if {\ttfamily a\+Ta=true}, and

{\itshape dst = scale(src -\/ delta)(src -\/ delta)$^\wedge$T}

otherwise. The function is used to calculate the covariance matrix. With zero delta, it can be used as a faster substitute for general matrix product {\ttfamily A$\ast$B} when {\ttfamily B=A\textquotesingle{}}


\begin{DoxyParams}{Parameters}
{\em src} & input single-\/channel matrix. Note that unlike \char`\"{}gemm\char`\"{}, the function can multiply not only floating-\/point matrices. \\
\hline
{\em dst} & output square matrix. \\
\hline
{\em a\+Ta} & Flag specifying the multiplication ordering. See the description below. \\
\hline
{\em delta} & Optional delta matrix subtracted from {\ttfamily src} before the multiplication. When the matrix is empty ({\ttfamily delta=no\+Array()}), it is assumed to be zero, that is, nothing is subtracted. If it has the same size as {\ttfamily src}, it is simply subtracted. Otherwise, it is \char`\"{}repeated\char`\"{} (see \char`\"{}repeat\char`\"{}) to cover the full {\ttfamily src} and then subtracted. Type of the delta matrix, when it is not empty, must be the same as the type of created output matrix. See the {\ttfamily dtype} parameter description below. \\
\hline
{\em scale} & Optional scale factor for the matrix product.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multransposed}{\tt org.\+opencv.\+core.\+Core.\+mul\+Transposed} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afebca901f30f80a2a6db7a67cc2afb0a}{org.\+opencv.\+core.\+Core\+::calc\+Covar\+Matrix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afcf15abfb6c9bf3a4126ae8199fc5ff3}{org.\+opencv.\+core.\+Core\+::repeat}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1849fb31954ac7655a174184f2eba671}{org.\+opencv.\+core.\+Core\+::reduce}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a68aea4eb6784b0aaa0f5c0770fa7bde0}{org.\+opencv.\+core.\+Core\+::gemm}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a9b09383bb522f3de2ba10c7e406cedec}\label{classorg_1_1opencv_1_1core_1_1_core_a9b09383bb522f3de2ba10c7e406cedec}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!mul\+Transposed@{mul\+Transposed}}
\index{mul\+Transposed@{mul\+Transposed}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{mul\+Transposed()}{mulTransposed()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+mul\+Transposed (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{boolean}]{a\+Ta }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the product of a matrix and its transposition.

The function {\ttfamily mul\+Transposed} calculates the product of {\ttfamily src} and its transposition\+:

{\itshape dst = scale(src -\/ delta)$^\wedge$T(src -\/ delta)}

if {\ttfamily a\+Ta=true}, and

{\itshape dst = scale(src -\/ delta)(src -\/ delta)$^\wedge$T}

otherwise. The function is used to calculate the covariance matrix. With zero delta, it can be used as a faster substitute for general matrix product {\ttfamily A$\ast$B} when {\ttfamily B=A\textquotesingle{}}


\begin{DoxyParams}{Parameters}
{\em src} & input single-\/channel matrix. Note that unlike \char`\"{}gemm\char`\"{}, the function can multiply not only floating-\/point matrices. \\
\hline
{\em dst} & output square matrix. \\
\hline
{\em a\+Ta} & Flag specifying the multiplication ordering. See the description below.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#multransposed}{\tt org.\+opencv.\+core.\+Core.\+mul\+Transposed} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afebca901f30f80a2a6db7a67cc2afb0a}{org.\+opencv.\+core.\+Core\+::calc\+Covar\+Matrix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afcf15abfb6c9bf3a4126ae8199fc5ff3}{org.\+opencv.\+core.\+Core\+::repeat}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1849fb31954ac7655a174184f2eba671}{org.\+opencv.\+core.\+Core\+::reduce}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a68aea4eb6784b0aaa0f5c0770fa7bde0}{org.\+opencv.\+core.\+Core\+::gemm}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}\label{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!norm@{norm}}
\index{norm@{norm}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{norm()}{norm()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+norm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{int}]{norm\+Type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates an absolute array norm, an absolute difference norm, or a relative difference norm.

The functions {\ttfamily norm} calculate an absolute norm of {\ttfamily src1} (when there is no {\ttfamily src2})\+:

{\itshape norm = forkthree($\vert$src1$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+\+I src1(\+I)$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or an absolute or relative difference norm if {\ttfamily src2} is there\+:

{\itshape norm = forkthree($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+I(src1(\+I) -\/ src2(\+I))$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or

{\itshape norm = forkthree(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)))/($\vert$src2$\vert$\+\_\+(L\+\_\+(infty))))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+I\+NF)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+1))/($\vert$src2$\vert$\+\_\+(L\+\_\+1)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L1)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+2))/($\vert$src2$\vert$\+\_\+(L\+\_\+2)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L2)}

The functions {\ttfamily norm} return the calculated norm.

When the {\ttfamily mask} parameter is specified and it is not empty, the norm is calculated only over the region specified by the mask.

A multi-\/channel input arrays are treated as a single-\/channel, that is, the results for all channels are combined.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em norm\+Type} & type of the norm (see the details below). \\
\hline
{\em mask} & optional operation mask; it must have the same size as {\ttfamily src1} and {\ttfamily C\+V\+\_\+8\+U\+C1} type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm}{\tt org.\+opencv.\+core.\+Core.\+norm} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a622a34c86e60dff3ad3990cae4bc3766}\label{classorg_1_1opencv_1_1core_1_1_core_a622a34c86e60dff3ad3990cae4bc3766}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!norm@{norm}}
\index{norm@{norm}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{norm()}{norm()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+norm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{int}]{norm\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates an absolute array norm, an absolute difference norm, or a relative difference norm.

The functions {\ttfamily norm} calculate an absolute norm of {\ttfamily src1} (when there is no {\ttfamily src2})\+:

{\itshape norm = forkthree($\vert$src1$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+\+I src1(\+I)$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or an absolute or relative difference norm if {\ttfamily src2} is there\+:

{\itshape norm = forkthree($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+I(src1(\+I) -\/ src2(\+I))$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or

{\itshape norm = forkthree(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)))/($\vert$src2$\vert$\+\_\+(L\+\_\+(infty))))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+I\+NF)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+1))/($\vert$src2$\vert$\+\_\+(L\+\_\+1)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L1)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+2))/($\vert$src2$\vert$\+\_\+(L\+\_\+2)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L2)}

The functions {\ttfamily norm} return the calculated norm.

When the {\ttfamily mask} parameter is specified and it is not empty, the norm is calculated only over the region specified by the mask.

A multi-\/channel input arrays are treated as a single-\/channel, that is, the results for all channels are combined.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em norm\+Type} & type of the norm (see the details below).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm}{\tt org.\+opencv.\+core.\+Core.\+norm} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a3ba2adc811656da873ceecb3c4c70335}\label{classorg_1_1opencv_1_1core_1_1_core_a3ba2adc811656da873ceecb3c4c70335}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!norm@{norm}}
\index{norm@{norm}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{norm()}{norm()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+norm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates an absolute array norm, an absolute difference norm, or a relative difference norm.

The functions {\ttfamily norm} calculate an absolute norm of {\ttfamily src1} (when there is no {\ttfamily src2})\+:

{\itshape norm = forkthree($\vert$src1$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+\+I src1(\+I)$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or an absolute or relative difference norm if {\ttfamily src2} is there\+:

{\itshape norm = forkthree($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+I(src1(\+I) -\/ src2(\+I))$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or

{\itshape norm = forkthree(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)))/($\vert$src2$\vert$\+\_\+(L\+\_\+(infty))))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+I\+NF)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+1))/($\vert$src2$\vert$\+\_\+(L\+\_\+1)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L1)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+2))/($\vert$src2$\vert$\+\_\+(L\+\_\+2)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L2)}

The functions {\ttfamily norm} return the calculated norm.

When the {\ttfamily mask} parameter is specified and it is not empty, the norm is calculated only over the region specified by the mask.

A multi-\/channel input arrays are treated as a single-\/channel, that is, the results for all channels are combined.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm}{\tt org.\+opencv.\+core.\+Core.\+norm} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a23c3e3b3fa55f87f23805428dde2a157}\label{classorg_1_1opencv_1_1core_1_1_core_a23c3e3b3fa55f87f23805428dde2a157}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!norm@{norm}}
\index{norm@{norm}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{norm()}{norm()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+norm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{int}]{norm\+Type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates an absolute array norm, an absolute difference norm, or a relative difference norm.

The functions {\ttfamily norm} calculate an absolute norm of {\ttfamily src1} (when there is no {\ttfamily src2})\+:

{\itshape norm = forkthree($\vert$src1$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+\+I src1(\+I)$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or an absolute or relative difference norm if {\ttfamily src2} is there\+:

{\itshape norm = forkthree($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+I(src1(\+I) -\/ src2(\+I))$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or

{\itshape norm = forkthree(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)))/($\vert$src2$\vert$\+\_\+(L\+\_\+(infty))))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+I\+NF)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+1))/($\vert$src2$\vert$\+\_\+(L\+\_\+1)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L1)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+2))/($\vert$src2$\vert$\+\_\+(L\+\_\+2)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L2)}

The functions {\ttfamily norm} return the calculated norm.

When the {\ttfamily mask} parameter is specified and it is not empty, the norm is calculated only over the region specified by the mask.

A multi-\/channel input arrays are treated as a single-\/channel, that is, the results for all channels are combined.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and the same type as {\ttfamily src1}. \\
\hline
{\em norm\+Type} & type of the norm (see the details below). \\
\hline
{\em mask} & optional operation mask; it must have the same size as {\ttfamily src1} and {\ttfamily C\+V\+\_\+8\+U\+C1} type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm}{\tt org.\+opencv.\+core.\+Core.\+norm} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a9701be26bf1d6b0266034f83a7f85535}\label{classorg_1_1opencv_1_1core_1_1_core_a9701be26bf1d6b0266034f83a7f85535}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!norm@{norm}}
\index{norm@{norm}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{norm()}{norm()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+norm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{int}]{norm\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates an absolute array norm, an absolute difference norm, or a relative difference norm.

The functions {\ttfamily norm} calculate an absolute norm of {\ttfamily src1} (when there is no {\ttfamily src2})\+:

{\itshape norm = forkthree($\vert$src1$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+\+I src1(\+I)$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or an absolute or relative difference norm if {\ttfamily src2} is there\+:

{\itshape norm = forkthree($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+I(src1(\+I) -\/ src2(\+I))$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or

{\itshape norm = forkthree(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)))/($\vert$src2$\vert$\+\_\+(L\+\_\+(infty))))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+I\+NF)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+1))/($\vert$src2$\vert$\+\_\+(L\+\_\+1)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L1)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+2))/($\vert$src2$\vert$\+\_\+(L\+\_\+2)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L2)}

The functions {\ttfamily norm} return the calculated norm.

When the {\ttfamily mask} parameter is specified and it is not empty, the norm is calculated only over the region specified by the mask.

A multi-\/channel input arrays are treated as a single-\/channel, that is, the results for all channels are combined.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and the same type as {\ttfamily src1}. \\
\hline
{\em norm\+Type} & type of the norm (see the details below).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm}{\tt org.\+opencv.\+core.\+Core.\+norm} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a94edbb7146566314b150cb3434db8dfa}\label{classorg_1_1opencv_1_1core_1_1_core_a94edbb7146566314b150cb3434db8dfa}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!norm@{norm}}
\index{norm@{norm}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{norm()}{norm()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+norm (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates an absolute array norm, an absolute difference norm, or a relative difference norm.

The functions {\ttfamily norm} calculate an absolute norm of {\ttfamily src1} (when there is no {\ttfamily src2})\+:

{\itshape norm = forkthree($\vert$src1$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+\+I src1(\+I)$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or an absolute or relative difference norm if {\ttfamily src2} is there\+:

{\itshape norm = forkthree($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)) = max {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+I\+NF)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+1) = sum {\itshape I$\vert$src1(I) -\/ src2(\+I)$\vert$)(if norm\+Type = N\+O\+R\+M\+\_\+\+L1)\&lt\+BR\&gt($\vert$src1 -\/ src2$\vert$}(L\+\_\+2) = sqrt(sum\+\_\+I(src1(\+I) -\/ src2(\+I))$^\wedge$2))(if norm\+Type = N\+O\+R\+M\+\_\+\+L2)}

or

{\itshape norm = forkthree(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+(infty)))/($\vert$src2$\vert$\+\_\+(L\+\_\+(infty))))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+I\+NF)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+1))/($\vert$src2$\vert$\+\_\+(L\+\_\+1)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L1)\&lt\+BR\&gt(($\vert$src1-\/src2$\vert$\+\_\+(L\+\_\+2))/($\vert$src2$\vert$\+\_\+(L\+\_\+2)))(if norm\+Type = N\+O\+R\+M\+\_\+\+R\+E\+L\+A\+T\+I\+V\+E\+\_\+\+L2)}

The functions {\ttfamily norm} return the calculated norm.

When the {\ttfamily mask} parameter is specified and it is not empty, the norm is calculated only over the region specified by the mask.

A multi-\/channel input arrays are treated as a single-\/channel, that is, the results for all channels are combined.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em src2} & second input array of the same size and the same type as {\ttfamily src1}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#norm}{\tt org.\+opencv.\+core.\+Core.\+norm} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a10833c4c941f13d93e3c5e702efa482e}\label{classorg_1_1opencv_1_1core_1_1_core_a10833c4c941f13d93e3c5e702efa482e}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!normalize@{normalize}}
\index{normalize@{normalize}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{normalize()}{normalize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+normalize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{alpha,  }\item[{double}]{beta,  }\item[{int}]{norm\+\_\+type,  }\item[{int}]{dtype,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Normalizes the norm or value range of an array.

The functions {\ttfamily normalize} scale and shift the input array elements so that

{\itshape $\vert$ dst$\vert$\+\_\+(L\+\_\+p)= alpha}

(where p=Inf, 1 or 2) when {\ttfamily norm\+Type=N\+O\+R\+M\+\_\+\+I\+NF}, {\ttfamily N\+O\+R\+M\+\_\+\+L1}, or {\ttfamily N\+O\+R\+M\+\_\+\+L2}, respectively; or so that

{\itshape min \+\_\+I dst(\+I)= alpha, max \+\_\+I dst(\+I)= beta}

when {\ttfamily norm\+Type=N\+O\+R\+M\+\_\+\+M\+I\+N\+M\+AX} (for dense arrays only). The optional mask specifies a sub-\/array to be normalized. This means that the norm or min-\/n-\/max are calculated over the sub-\/array, and then this sub-\/array is modified to be normalized. If you want to only use the mask to calculate the norm or min-\/max but modify the whole array, you can use \char`\"{}norm\char`\"{} and \char`\"{}\+Mat.\+convert\+To\char`\"{}.

In case of sparse matrices, only the non-\/zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array of the same size as {\ttfamily src}. \\
\hline
{\em alpha} & norm value to normalize to or the lower range boundary in case of the range normalization. \\
\hline
{\em beta} & upper range boundary in case of the range normalization; it is not used for the norm normalization. \\
\hline
{\em norm\+\_\+type} & a norm\+\_\+type \\
\hline
{\em dtype} & when negative, the output array has the same type as {\ttfamily src}; otherwise, it has the same number of channels as {\ttfamily src} and the depth {\ttfamily =C\+V\+\_\+\+M\+A\+T\+\_\+\+D\+E\+P\+T\+H(dtype)}. \\
\hline
{\em mask} & optional operation mask.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize}{\tt org.\+opencv.\+core.\+Core.\+normalize} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}{org.\+opencv.\+core.\+Core\+::norm}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a339332679c8e7d52cc2e1bba2187b8ff}\label{classorg_1_1opencv_1_1core_1_1_core_a339332679c8e7d52cc2e1bba2187b8ff}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!normalize@{normalize}}
\index{normalize@{normalize}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{normalize()}{normalize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+normalize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{alpha,  }\item[{double}]{beta,  }\item[{int}]{norm\+\_\+type,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Normalizes the norm or value range of an array.

The functions {\ttfamily normalize} scale and shift the input array elements so that

{\itshape $\vert$ dst$\vert$\+\_\+(L\+\_\+p)= alpha}

(where p=Inf, 1 or 2) when {\ttfamily norm\+Type=N\+O\+R\+M\+\_\+\+I\+NF}, {\ttfamily N\+O\+R\+M\+\_\+\+L1}, or {\ttfamily N\+O\+R\+M\+\_\+\+L2}, respectively; or so that

{\itshape min \+\_\+I dst(\+I)= alpha, max \+\_\+I dst(\+I)= beta}

when {\ttfamily norm\+Type=N\+O\+R\+M\+\_\+\+M\+I\+N\+M\+AX} (for dense arrays only). The optional mask specifies a sub-\/array to be normalized. This means that the norm or min-\/n-\/max are calculated over the sub-\/array, and then this sub-\/array is modified to be normalized. If you want to only use the mask to calculate the norm or min-\/max but modify the whole array, you can use \char`\"{}norm\char`\"{} and \char`\"{}\+Mat.\+convert\+To\char`\"{}.

In case of sparse matrices, only the non-\/zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array of the same size as {\ttfamily src}. \\
\hline
{\em alpha} & norm value to normalize to or the lower range boundary in case of the range normalization. \\
\hline
{\em beta} & upper range boundary in case of the range normalization; it is not used for the norm normalization. \\
\hline
{\em norm\+\_\+type} & a norm\+\_\+type \\
\hline
{\em dtype} & when negative, the output array has the same type as {\ttfamily src}; otherwise, it has the same number of channels as {\ttfamily src} and the depth {\ttfamily =C\+V\+\_\+\+M\+A\+T\+\_\+\+D\+E\+P\+T\+H(dtype)}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize}{\tt org.\+opencv.\+core.\+Core.\+normalize} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}{org.\+opencv.\+core.\+Core\+::norm}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_af2e92f82c3f412aa25d1065065d07afe}\label{classorg_1_1opencv_1_1core_1_1_core_af2e92f82c3f412aa25d1065065d07afe}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!normalize@{normalize}}
\index{normalize@{normalize}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{normalize()}{normalize()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+normalize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{alpha,  }\item[{double}]{beta,  }\item[{int}]{norm\+\_\+type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Normalizes the norm or value range of an array.

The functions {\ttfamily normalize} scale and shift the input array elements so that

{\itshape $\vert$ dst$\vert$\+\_\+(L\+\_\+p)= alpha}

(where p=Inf, 1 or 2) when {\ttfamily norm\+Type=N\+O\+R\+M\+\_\+\+I\+NF}, {\ttfamily N\+O\+R\+M\+\_\+\+L1}, or {\ttfamily N\+O\+R\+M\+\_\+\+L2}, respectively; or so that

{\itshape min \+\_\+I dst(\+I)= alpha, max \+\_\+I dst(\+I)= beta}

when {\ttfamily norm\+Type=N\+O\+R\+M\+\_\+\+M\+I\+N\+M\+AX} (for dense arrays only). The optional mask specifies a sub-\/array to be normalized. This means that the norm or min-\/n-\/max are calculated over the sub-\/array, and then this sub-\/array is modified to be normalized. If you want to only use the mask to calculate the norm or min-\/max but modify the whole array, you can use \char`\"{}norm\char`\"{} and \char`\"{}\+Mat.\+convert\+To\char`\"{}.

In case of sparse matrices, only the non-\/zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array of the same size as {\ttfamily src}. \\
\hline
{\em alpha} & norm value to normalize to or the lower range boundary in case of the range normalization. \\
\hline
{\em beta} & upper range boundary in case of the range normalization; it is not used for the norm normalization. \\
\hline
{\em norm\+\_\+type} & a norm\+\_\+type\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize}{\tt org.\+opencv.\+core.\+Core.\+normalize} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}{org.\+opencv.\+core.\+Core\+::norm}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a659f5c8fc2f3d5ee432879bf968f6743}\label{classorg_1_1opencv_1_1core_1_1_core_a659f5c8fc2f3d5ee432879bf968f6743}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!normalize@{normalize}}
\index{normalize@{normalize}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{normalize()}{normalize()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+normalize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Normalizes the norm or value range of an array.

The functions {\ttfamily normalize} scale and shift the input array elements so that

{\itshape $\vert$ dst$\vert$\+\_\+(L\+\_\+p)= alpha}

(where p=Inf, 1 or 2) when {\ttfamily norm\+Type=N\+O\+R\+M\+\_\+\+I\+NF}, {\ttfamily N\+O\+R\+M\+\_\+\+L1}, or {\ttfamily N\+O\+R\+M\+\_\+\+L2}, respectively; or so that

{\itshape min \+\_\+I dst(\+I)= alpha, max \+\_\+I dst(\+I)= beta}

when {\ttfamily norm\+Type=N\+O\+R\+M\+\_\+\+M\+I\+N\+M\+AX} (for dense arrays only). The optional mask specifies a sub-\/array to be normalized. This means that the norm or min-\/n-\/max are calculated over the sub-\/array, and then this sub-\/array is modified to be normalized. If you want to only use the mask to calculate the norm or min-\/max but modify the whole array, you can use \char`\"{}norm\char`\"{} and \char`\"{}\+Mat.\+convert\+To\char`\"{}.

In case of sparse matrices, only the non-\/zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array of the same size as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#normalize}{\tt org.\+opencv.\+core.\+Core.\+normalize} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}{org.\+opencv.\+core.\+Core\+::norm}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ab0dae7a8f13b75f48d05b12fc327009a}\label{classorg_1_1opencv_1_1core_1_1_core_ab0dae7a8f13b75f48d05b12fc327009a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!patch\+Na\+Ns@{patch\+Na\+Ns}}
\index{patch\+Na\+Ns@{patch\+Na\+Ns}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{patch\+Na\+Ns()}{patchNaNs()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+patch\+Na\+Ns (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{a,  }\item[{double}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a044bc13c2a268300ece0f51213b37cfe}\label{classorg_1_1opencv_1_1core_1_1_core_a044bc13c2a268300ece0f51213b37cfe}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!patch\+Na\+Ns@{patch\+Na\+Ns}}
\index{patch\+Na\+Ns@{patch\+Na\+Ns}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{patch\+Na\+Ns()}{patchNaNs()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+patch\+Na\+Ns (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{a }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a3b8b2b268d857381ddc7bba20b464d1f}\label{classorg_1_1opencv_1_1core_1_1_core_a3b8b2b268d857381ddc7bba20b464d1f}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!P\+C\+A\+Back\+Project@{P\+C\+A\+Back\+Project}}
\index{P\+C\+A\+Back\+Project@{P\+C\+A\+Back\+Project}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{P\+C\+A\+Back\+Project()}{PCABackProject()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+P\+C\+A\+Back\+Project (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{data,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mean,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{eigenvectors,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aab65f922f93f6aad0b5d10ba2f27f401}\label{classorg_1_1opencv_1_1core_1_1_core_aab65f922f93f6aad0b5d10ba2f27f401}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!P\+C\+A\+Compute@{P\+C\+A\+Compute}}
\index{P\+C\+A\+Compute@{P\+C\+A\+Compute}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{P\+C\+A\+Compute()}{PCACompute()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+P\+C\+A\+Compute (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{data,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mean,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{eigenvectors,  }\item[{int}]{max\+Components }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aa77b57fe39b738ce2260e77c84405e73}\label{classorg_1_1opencv_1_1core_1_1_core_aa77b57fe39b738ce2260e77c84405e73}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!P\+C\+A\+Compute@{P\+C\+A\+Compute}}
\index{P\+C\+A\+Compute@{P\+C\+A\+Compute}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{P\+C\+A\+Compute()}{PCACompute()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+P\+C\+A\+Compute (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{data,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mean,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{eigenvectors }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a05764d4479aec67351a6c96915053333}\label{classorg_1_1opencv_1_1core_1_1_core_a05764d4479aec67351a6c96915053333}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!P\+C\+A\+Compute\+Var@{P\+C\+A\+Compute\+Var}}
\index{P\+C\+A\+Compute\+Var@{P\+C\+A\+Compute\+Var}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{P\+C\+A\+Compute\+Var()}{PCAComputeVar()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+P\+C\+A\+Compute\+Var (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{data,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mean,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{eigenvectors,  }\item[{double}]{retained\+Variance }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ac1b1800fd7a0b44ef5c5fbfe45d42eda}\label{classorg_1_1opencv_1_1core_1_1_core_ac1b1800fd7a0b44ef5c5fbfe45d42eda}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!P\+C\+A\+Project@{P\+C\+A\+Project}}
\index{P\+C\+A\+Project@{P\+C\+A\+Project}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{P\+C\+A\+Project()}{PCAProject()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+P\+C\+A\+Project (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{data,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mean,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{eigenvectors,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a1ff0eace0f00e79af5228fdae120342a}\label{classorg_1_1opencv_1_1core_1_1_core_a1ff0eace0f00e79af5228fdae120342a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!perspective\+Transform@{perspective\+Transform}}
\index{perspective\+Transform@{perspective\+Transform}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{perspective\+Transform()}{perspectiveTransform()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+perspective\+Transform (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs the perspective matrix transformation of vectors.

The function {\ttfamily perspective\+Transform} transforms every element of {\ttfamily src} by treating it as a 2D or 3D vector, in the following way\+:

{\itshape (x, y, z) -\/$>$ (x\textquotesingle{}/w, y\textquotesingle{}/w, z\textquotesingle{}/w)}

where

{\itshape (x\textquotesingle{}, y\textquotesingle{}, z\textquotesingle{}, w\textquotesingle{}) = mat $\ast$ x y z 1 }

and

{\itshape w = w\textquotesingle{} if w\textquotesingle{} != 0; infty otherwise}

Here a 3D vector transformation is shown. In case of a 2D vector transformation, the {\ttfamily z} component is omitted.

Note\+: The function transforms a sparse set of 2D or 3D vectors. If you want to transform an image using perspective transformation, use \char`\"{}warp\+Perspective\char`\"{}. If you have an inverse problem, that is, you want to compute the most probable perspective transformation out of several pairs of corresponding points, you can use \char`\"{}get\+Perspective\+Transform\char`\"{} or \char`\"{}find\+Homography\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em src} & input two-\/channel or three-\/channel floating-\/point array; each element is a 2\+D/3D vector to be transformed. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}. \\
\hline
{\em m} & {\ttfamily 3x3} or {\ttfamily 4x4} floating-\/point transformation matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#perspectivetransform}{\tt org.\+opencv.\+core.\+Core.\+perspective\+Transform} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a2c32d44d2f35dc41aa09d54eb6829ab8}{org.\+opencv.\+calib3d.\+Calib3d\+::find\+Homography}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a221e7697d1a57961ee8a843b7aa05b75}{org.\+opencv.\+core.\+Core\+::transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab3727363e269af640d5254f76e14ddb6}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Perspective\+Transform}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a09f94d89796effb89e2bff15c54b383a}\label{classorg_1_1opencv_1_1core_1_1_core_a09f94d89796effb89e2bff15c54b383a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!phase@{phase}}
\index{phase@{phase}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{phase()}{phase()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+phase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{x,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{y,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{angle,  }\item[{boolean}]{angle\+In\+Degrees }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the rotation angle of 2D vectors.

The function {\ttfamily phase} calculates the rotation angle of each 2D vector that is formed from the corresponding elements of {\ttfamily x} and {\ttfamily y} \+:

{\itshape angle(\+I) = atan2(y(\+I), x(\+I))}

The angle estimation accuracy is about 0.\+3 degrees. When {\ttfamily x(\+I)=y(\+I)=0}, the corresponding {\ttfamily angle(\+I)} is set to 0.


\begin{DoxyParams}{Parameters}
{\em x} & input floating-\/point array of x-\/coordinates of 2D vectors. \\
\hline
{\em y} & input array of y-\/coordinates of 2D vectors; it must have the same size and the same type as {\ttfamily x}. \\
\hline
{\em angle} & output array of vector angles; it has the same size and same type as {\ttfamily x}. \\
\hline
{\em angle\+In\+Degrees} & when true, the function calculates the angle in degrees, otherwise, they are measured in radians.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#phase}{\tt org.\+opencv.\+core.\+Core.\+phase} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aac26449052db09ffe451743fffc92270}\label{classorg_1_1opencv_1_1core_1_1_core_aac26449052db09ffe451743fffc92270}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!phase@{phase}}
\index{phase@{phase}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{phase()}{phase()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+phase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{x,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{y,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{angle }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the rotation angle of 2D vectors.

The function {\ttfamily phase} calculates the rotation angle of each 2D vector that is formed from the corresponding elements of {\ttfamily x} and {\ttfamily y} \+:

{\itshape angle(\+I) = atan2(y(\+I), x(\+I))}

The angle estimation accuracy is about 0.\+3 degrees. When {\ttfamily x(\+I)=y(\+I)=0}, the corresponding {\ttfamily angle(\+I)} is set to 0.


\begin{DoxyParams}{Parameters}
{\em x} & input floating-\/point array of x-\/coordinates of 2D vectors. \\
\hline
{\em y} & input array of y-\/coordinates of 2D vectors; it must have the same size and the same type as {\ttfamily x}. \\
\hline
{\em angle} & output array of vector angles; it has the same size and same type as {\ttfamily x}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#phase}{\tt org.\+opencv.\+core.\+Core.\+phase} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a90c17a6d7e194cd8baf45819267a4539}\label{classorg_1_1opencv_1_1core_1_1_core_a90c17a6d7e194cd8baf45819267a4539}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!polar\+To\+Cart@{polar\+To\+Cart}}
\index{polar\+To\+Cart@{polar\+To\+Cart}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{polar\+To\+Cart()}{polarToCart()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+polar\+To\+Cart (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{magnitude,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{angle,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{x,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{y,  }\item[{boolean}]{angle\+In\+Degrees }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates x and y coordinates of 2D vectors from their magnitude and angle.

The function {\ttfamily polar\+To\+Cart} calculates the Cartesian coordinates of each 2D vector represented by the corresponding elements of {\ttfamily magnitude} and {\ttfamily angle} \+:

{\itshape x(\+I) = magnitude(\+I) cos(angle(\+I)) y(\+I) = magnitude(\+I) sin(angle(\+I)) }

The relative accuracy of the estimated coordinates is about {\ttfamily 1e-\/6}.


\begin{DoxyParams}{Parameters}
{\em magnitude} & input floating-\/point array of magnitudes of 2D vectors; it can be an empty matrix ({\ttfamily =Mat()}), in this case, the function assumes that all the magnitudes are =1; if it is not empty, it must have the same size and type as {\ttfamily angle}. \\
\hline
{\em angle} & input floating-\/point array of angles of 2D vectors. \\
\hline
{\em x} & output array of x-\/coordinates of 2D vectors; it has the same size and type as {\ttfamily angle}. \\
\hline
{\em y} & output array of y-\/coordinates of 2D vectors; it has the same size and type as {\ttfamily angle}. \\
\hline
{\em angle\+In\+Degrees} & when true, the input angles are measured in degrees, otherwise, they are measured in radians.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#polartocart}{\tt org.\+opencv.\+core.\+Core.\+polar\+To\+Cart} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a34d89a9c8e2562fc85bfecca3dca7d76}{org.\+opencv.\+core.\+Core\+::log}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a29c20af97ae09c75246777774bc6d41b}{org.\+opencv.\+core.\+Core\+::pow}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5a2235761d8876294b3277876479107b}{org.\+opencv.\+core.\+Core\+::sqrt}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{org.\+opencv.\+core.\+Core\+::magnitude}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a18688b13789043dfaa98161fe663f075}{org.\+opencv.\+core.\+Core\+::exp}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a09f94d89796effb89e2bff15c54b383a}{org.\+opencv.\+core.\+Core\+::phase}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aa5d94ecf80128fd344c06cd4d286cfd6}\label{classorg_1_1opencv_1_1core_1_1_core_aa5d94ecf80128fd344c06cd4d286cfd6}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!polar\+To\+Cart@{polar\+To\+Cart}}
\index{polar\+To\+Cart@{polar\+To\+Cart}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{polar\+To\+Cart()}{polarToCart()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+polar\+To\+Cart (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{magnitude,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{angle,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{x,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{y }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates x and y coordinates of 2D vectors from their magnitude and angle.

The function {\ttfamily polar\+To\+Cart} calculates the Cartesian coordinates of each 2D vector represented by the corresponding elements of {\ttfamily magnitude} and {\ttfamily angle} \+:

{\itshape x(\+I) = magnitude(\+I) cos(angle(\+I)) y(\+I) = magnitude(\+I) sin(angle(\+I)) }

The relative accuracy of the estimated coordinates is about {\ttfamily 1e-\/6}.


\begin{DoxyParams}{Parameters}
{\em magnitude} & input floating-\/point array of magnitudes of 2D vectors; it can be an empty matrix ({\ttfamily =Mat()}), in this case, the function assumes that all the magnitudes are =1; if it is not empty, it must have the same size and type as {\ttfamily angle}. \\
\hline
{\em angle} & input floating-\/point array of angles of 2D vectors. \\
\hline
{\em x} & output array of x-\/coordinates of 2D vectors; it has the same size and type as {\ttfamily angle}. \\
\hline
{\em y} & output array of y-\/coordinates of 2D vectors; it has the same size and type as {\ttfamily angle}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#polartocart}{\tt org.\+opencv.\+core.\+Core.\+polar\+To\+Cart} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a34d89a9c8e2562fc85bfecca3dca7d76}{org.\+opencv.\+core.\+Core\+::log}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a29c20af97ae09c75246777774bc6d41b}{org.\+opencv.\+core.\+Core\+::pow}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5a2235761d8876294b3277876479107b}{org.\+opencv.\+core.\+Core\+::sqrt}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{org.\+opencv.\+core.\+Core\+::magnitude}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a18688b13789043dfaa98161fe663f075}{org.\+opencv.\+core.\+Core\+::exp}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a09f94d89796effb89e2bff15c54b383a}{org.\+opencv.\+core.\+Core\+::phase}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ad24a7743adf154594355229a6c0a19cd}\label{classorg_1_1opencv_1_1core_1_1_core_ad24a7743adf154594355229a6c0a19cd}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!polylines@{polylines}}
\index{polylines@{polylines}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{polylines()}{polylines()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+polylines (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$}]{pts,  }\item[{boolean}]{is\+Closed,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness,  }\item[{int}]{line\+Type,  }\item[{int}]{shift }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws several polygonal curves.

The function {\ttfamily polylines} draws one or more polygonal curves.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em pts} & Array of polygonal curves. \\
\hline
{\em is\+Closed} & Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex. \\
\hline
{\em color} & Polyline color. \\
\hline
{\em thickness} & Thickness of the polyline edges. \\
\hline
{\em line\+Type} & Type of the line segments. See the \char`\"{}line\char`\"{} description. \\
\hline
{\em shift} & Number of fractional bits in the vertex coordinates.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#polylines}{\tt org.\+opencv.\+core.\+Core.\+polylines} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a377faf881106086b38611168440c5321}\label{classorg_1_1opencv_1_1core_1_1_core_a377faf881106086b38611168440c5321}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!polylines@{polylines}}
\index{polylines@{polylines}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{polylines()}{polylines()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+polylines (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$}]{pts,  }\item[{boolean}]{is\+Closed,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws several polygonal curves.

The function {\ttfamily polylines} draws one or more polygonal curves.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em pts} & Array of polygonal curves. \\
\hline
{\em is\+Closed} & Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex. \\
\hline
{\em color} & Polyline color. \\
\hline
{\em thickness} & Thickness of the polyline edges.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#polylines}{\tt org.\+opencv.\+core.\+Core.\+polylines} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a1f9634590e755ea36ed3e5bdc7245811}\label{classorg_1_1opencv_1_1core_1_1_core_a1f9634590e755ea36ed3e5bdc7245811}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!polylines@{polylines}}
\index{polylines@{polylines}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{polylines()}{polylines()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+polylines (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$}]{pts,  }\item[{boolean}]{is\+Closed,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws several polygonal curves.

The function {\ttfamily polylines} draws one or more polygonal curves.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em pts} & Array of polygonal curves. \\
\hline
{\em is\+Closed} & Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex. \\
\hline
{\em color} & Polyline color.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#polylines}{\tt org.\+opencv.\+core.\+Core.\+polylines} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a29c20af97ae09c75246777774bc6d41b}\label{classorg_1_1opencv_1_1core_1_1_core_a29c20af97ae09c75246777774bc6d41b}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!pow@{pow}}
\index{pow@{pow}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{pow()}{pow()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+pow (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{double}]{power,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Raises every array element to a power.

The function {\ttfamily pow} raises every element of the input array to {\ttfamily power} \+:

{\itshape dst(\+I) = src(\+I)$^\wedge$power if power is integer; $\vert$src(I)$\vert$$^\wedge$power otherwise\&lt\+BR\&gt\+So, for a non-\/integer power exponent, the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations. In the example below, computing the 5th root of array {\ttfamily src} shows\+: \&lt\+BR\&gt\&ltcode\&gt}

// C++ code\+:

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask = src $<$ 0;

pow(src, 1./5, dst);

subtract(Scalar.\+all(0), dst, dst, mask);

For some values of {\ttfamily power}, such as integer values, 0.\+5 and -\/0.\+5, specialized faster algorithms are used. 

Special values (NaN, Inf) are not handled.


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em power} & exponent of power. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#pow}{\tt org.\+opencv.\+core.\+Core.\+pow} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a90c17a6d7e194cd8baf45819267a4539}{org.\+opencv.\+core.\+Core\+::polar\+To\+Cart}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a18688b13789043dfaa98161fe663f075}{org.\+opencv.\+core.\+Core\+::exp}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5a2235761d8876294b3277876479107b}{org.\+opencv.\+core.\+Core\+::sqrt}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a34d89a9c8e2562fc85bfecca3dca7d76}{org.\+opencv.\+core.\+Core\+::log}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a83cb8f8058aead15a4f9995328aef154}\label{classorg_1_1opencv_1_1core_1_1_core_a83cb8f8058aead15a4f9995328aef154}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!put\+Text@{put\+Text}}
\index{put\+Text@{put\+Text}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{put\+Text()}{putText()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+put\+Text (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{String}]{text,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{org,  }\item[{int}]{font\+Face,  }\item[{double}]{font\+Scale,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness,  }\item[{int}]{line\+Type,  }\item[{boolean}]{bottom\+Left\+Origin }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a text string.

The function {\ttfamily put\+Text} renders the specified text string in the image. Symbols that cannot be rendered using the specified font are replaced by question marks. See \char`\"{}get\+Text\+Size\char`\"{} for a text rendering code example.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em text} & Text string to be drawn. \\
\hline
{\em org} & Bottom-\/left corner of the text string in the image. \\
\hline
{\em font\+Face} & Font type. One of {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+S\+I\+M\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+P\+L\+A\+IN}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+D\+U\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+C\+O\+M\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+T\+R\+I\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+C\+O\+M\+P\+L\+E\+X\+\_\+\+S\+M\+A\+LL}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+S\+C\+R\+I\+P\+T\+\_\+\+S\+I\+M\+P\+L\+EX}, or {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+S\+C\+R\+I\+P\+T\+\_\+\+C\+O\+M\+P\+L\+EX}, where each of the font ID\textquotesingle{}s can be combined with {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+I\+T\+A\+L\+IC} to get the slanted letters. \\
\hline
{\em font\+Scale} & Font scale factor that is multiplied by the font-\/specific base size. \\
\hline
{\em color} & Text color. \\
\hline
{\em thickness} & Thickness of the lines used to draw a text. \\
\hline
{\em line\+Type} & Line type. See the {\ttfamily line} for details. \\
\hline
{\em bottom\+Left\+Origin} & When true, the image data origin is at the bottom-\/left corner. Otherwise, it is at the top-\/left corner.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#puttext}{\tt org.\+opencv.\+core.\+Core.\+put\+Text} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a1a575810e5c02ecba186388a77e6af94}\label{classorg_1_1opencv_1_1core_1_1_core_a1a575810e5c02ecba186388a77e6af94}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!put\+Text@{put\+Text}}
\index{put\+Text@{put\+Text}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{put\+Text()}{putText()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+put\+Text (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{String}]{text,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{org,  }\item[{int}]{font\+Face,  }\item[{double}]{font\+Scale,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a text string.

The function {\ttfamily put\+Text} renders the specified text string in the image. Symbols that cannot be rendered using the specified font are replaced by question marks. See \char`\"{}get\+Text\+Size\char`\"{} for a text rendering code example.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em text} & Text string to be drawn. \\
\hline
{\em org} & Bottom-\/left corner of the text string in the image. \\
\hline
{\em font\+Face} & Font type. One of {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+S\+I\+M\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+P\+L\+A\+IN}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+D\+U\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+C\+O\+M\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+T\+R\+I\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+C\+O\+M\+P\+L\+E\+X\+\_\+\+S\+M\+A\+LL}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+S\+C\+R\+I\+P\+T\+\_\+\+S\+I\+M\+P\+L\+EX}, or {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+S\+C\+R\+I\+P\+T\+\_\+\+C\+O\+M\+P\+L\+EX}, where each of the font ID\textquotesingle{}s can be combined with {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+I\+T\+A\+L\+IC} to get the slanted letters. \\
\hline
{\em font\+Scale} & Font scale factor that is multiplied by the font-\/specific base size. \\
\hline
{\em color} & Text color. \\
\hline
{\em thickness} & Thickness of the lines used to draw a text.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#puttext}{\tt org.\+opencv.\+core.\+Core.\+put\+Text} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_acd34e2234dab5c2eb2f8f2c517bf9f2a}\label{classorg_1_1opencv_1_1core_1_1_core_acd34e2234dab5c2eb2f8f2c517bf9f2a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!put\+Text@{put\+Text}}
\index{put\+Text@{put\+Text}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{put\+Text()}{putText()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+put\+Text (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{String}]{text,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{org,  }\item[{int}]{font\+Face,  }\item[{double}]{font\+Scale,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a text string.

The function {\ttfamily put\+Text} renders the specified text string in the image. Symbols that cannot be rendered using the specified font are replaced by question marks. See \char`\"{}get\+Text\+Size\char`\"{} for a text rendering code example.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em text} & Text string to be drawn. \\
\hline
{\em org} & Bottom-\/left corner of the text string in the image. \\
\hline
{\em font\+Face} & Font type. One of {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+S\+I\+M\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+P\+L\+A\+IN}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+D\+U\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+C\+O\+M\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+T\+R\+I\+P\+L\+EX}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+C\+O\+M\+P\+L\+E\+X\+\_\+\+S\+M\+A\+LL}, {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+S\+C\+R\+I\+P\+T\+\_\+\+S\+I\+M\+P\+L\+EX}, or {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+S\+C\+R\+I\+P\+T\+\_\+\+C\+O\+M\+P\+L\+EX}, where each of the font ID\textquotesingle{}s can be combined with {\ttfamily F\+O\+N\+T\+\_\+\+H\+E\+R\+S\+H\+E\+Y\+\_\+\+I\+T\+A\+L\+IC} to get the slanted letters. \\
\hline
{\em font\+Scale} & Font scale factor that is multiplied by the font-\/specific base size. \\
\hline
{\em color} & Text color.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#puttext}{\tt org.\+opencv.\+core.\+Core.\+put\+Text} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_adc06c7d15abcade8d369a20bab2d7355}\label{classorg_1_1opencv_1_1core_1_1_core_adc06c7d15abcade8d369a20bab2d7355}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!randn@{randn}}
\index{randn@{randn}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{randn()}{randn()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+randn (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{mean,  }\item[{double}]{stddev }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Fills the array with normally distributed random numbers.

The function {\ttfamily randn} fills the matrix {\ttfamily dst} with normally distributed random numbers with the specified mean vector and the standard deviation matrix. The generated random numbers are clipped to fit the value range of the output array data type.


\begin{DoxyParams}{Parameters}
{\em dst} & output array of random numbers; the array must be pre-\/allocated and have 1 to 4 channels. \\
\hline
{\em mean} & mean value (expectation) of the generated random numbers. \\
\hline
{\em stddev} & standard deviation of the generated random numbers; it can be either a vector (in which case a diagonal standard deviation matrix is assumed) or a square matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#randn}{\tt org.\+opencv.\+core.\+Core.\+randn} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_abfe7d53276a89fcf1a78b744cd75b9fc}{org.\+opencv.\+core.\+Core\+::randu}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ab80ad04c349aee7d887830ec8de84ae2}\label{classorg_1_1opencv_1_1core_1_1_core_ab80ad04c349aee7d887830ec8de84ae2}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!rand\+Shuffle@{rand\+Shuffle}}
\index{rand\+Shuffle@{rand\+Shuffle}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{rand\+Shuffle()}{randShuffle()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+rand\+Shuffle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{iter\+Factor }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ac1698bb3fd0c489839e5dd5eccfe5260}\label{classorg_1_1opencv_1_1core_1_1_core_ac1698bb3fd0c489839e5dd5eccfe5260}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!rand\+Shuffle@{rand\+Shuffle}}
\index{rand\+Shuffle@{rand\+Shuffle}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{rand\+Shuffle()}{randShuffle()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+rand\+Shuffle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_abfe7d53276a89fcf1a78b744cd75b9fc}\label{classorg_1_1opencv_1_1core_1_1_core_abfe7d53276a89fcf1a78b744cd75b9fc}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!randu@{randu}}
\index{randu@{randu}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{randu()}{randu()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+randu (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{low,  }\item[{double}]{high }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Generates a single uniformly-\/distributed random number or an array of random numbers.

The template functions {\ttfamily randu} generate and return the next uniformly-\/distributed random value of the specified type. {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_abfe7d53276a89fcf1a78b744cd75b9fc}{randu$<$int$>$()}}} is an equivalent to {\ttfamily (int)the\+R\+N\+G();}, and so on. See \char`\"{}\+R\+N\+G\char`\"{} description.

The second non-\/template variant of the function fills the matrix {\ttfamily dst} with uniformly-\/distributed random numbers from the specified range\+:

{\itshape low \+\_\+c $<$= dst(\+I)\+\_\+c \&lt high \+\_\+c}


\begin{DoxyParams}{Parameters}
{\em dst} & output array of random numbers; the array must be pre-\/allocated. \\
\hline
{\em low} & inclusive lower boundary of the generated random numbers. \\
\hline
{\em high} & exclusive upper boundary of the generated random numbers.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#randu}{\tt org.\+opencv.\+core.\+Core.\+randu} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_adc06c7d15abcade8d369a20bab2d7355}{org.\+opencv.\+core.\+Core\+::randn}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a3d2d8fc68149238f6b3d7c0d6e70066a}\label{classorg_1_1opencv_1_1core_1_1_core_a3d2d8fc68149238f6b3d7c0d6e70066a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!rectangle@{rectangle}}
\index{rectangle@{rectangle}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{rectangle()}{rectangle()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+rectangle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness,  }\item[{int}]{line\+Type,  }\item[{int}]{shift }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a simple, thick, or filled up-\/right rectangle.

The function {\ttfamily rectangle} draws a rectangle outline or a filled rectangle whose two opposite corners are {\ttfamily pt1} and {\ttfamily pt2}, or {\ttfamily r.\+tl()} and {\ttfamily r.\+br()-\/\+Point(1,1)}.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em pt1} & Vertex of the rectangle. \\
\hline
{\em pt2} & Vertex of the rectangle opposite to {\ttfamily pt1}. \\
\hline
{\em color} & Rectangle color or brightness (grayscale image). \\
\hline
{\em thickness} & Thickness of lines that make up the rectangle. Negative values, like {\ttfamily C\+V\+\_\+\+F\+I\+L\+L\+ED}, mean that the function has to draw a filled rectangle. \\
\hline
{\em line\+Type} & Type of the line. See the \char`\"{}line\char`\"{} description. \\
\hline
{\em shift} & Number of fractional bits in the point coordinates.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#rectangle}{\tt org.\+opencv.\+core.\+Core.\+rectangle} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a713e32fc1ab8efed4d38172dc3731627}\label{classorg_1_1opencv_1_1core_1_1_core_a713e32fc1ab8efed4d38172dc3731627}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!rectangle@{rectangle}}
\index{rectangle@{rectangle}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{rectangle()}{rectangle()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+rectangle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a simple, thick, or filled up-\/right rectangle.

The function {\ttfamily rectangle} draws a rectangle outline or a filled rectangle whose two opposite corners are {\ttfamily pt1} and {\ttfamily pt2}, or {\ttfamily r.\+tl()} and {\ttfamily r.\+br()-\/\+Point(1,1)}.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em pt1} & Vertex of the rectangle. \\
\hline
{\em pt2} & Vertex of the rectangle opposite to {\ttfamily pt1}. \\
\hline
{\em color} & Rectangle color or brightness (grayscale image). \\
\hline
{\em thickness} & Thickness of lines that make up the rectangle. Negative values, like {\ttfamily C\+V\+\_\+\+F\+I\+L\+L\+ED}, mean that the function has to draw a filled rectangle.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#rectangle}{\tt org.\+opencv.\+core.\+Core.\+rectangle} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a867d653e8edc48f1c36ef0b44fdfbc2e}\label{classorg_1_1opencv_1_1core_1_1_core_a867d653e8edc48f1c36ef0b44fdfbc2e}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!rectangle@{rectangle}}
\index{rectangle@{rectangle}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{rectangle()}{rectangle()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+rectangle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws a simple, thick, or filled up-\/right rectangle.

The function {\ttfamily rectangle} draws a rectangle outline or a filled rectangle whose two opposite corners are {\ttfamily pt1} and {\ttfamily pt2}, or {\ttfamily r.\+tl()} and {\ttfamily r.\+br()-\/\+Point(1,1)}.


\begin{DoxyParams}{Parameters}
{\em img} & Image. \\
\hline
{\em pt1} & Vertex of the rectangle. \\
\hline
{\em pt2} & Vertex of the rectangle opposite to {\ttfamily pt1}. \\
\hline
{\em color} & Rectangle color or brightness (grayscale image).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/drawing_functions.html#rectangle}{\tt org.\+opencv.\+core.\+Core.\+rectangle} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a1849fb31954ac7655a174184f2eba671}\label{classorg_1_1opencv_1_1core_1_1_core_a1849fb31954ac7655a174184f2eba671}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!reduce@{reduce}}
\index{reduce@{reduce}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{reduce()}{reduce()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+reduce (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{dim,  }\item[{int}]{rtype,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Reduces a matrix to a vector.

The function {\ttfamily reduce} reduces the matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. For example, the function can be used to compute horizontal and vertical projections of a raster image. In case of {\ttfamily C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+S\+UM} and {\ttfamily C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+A\+VG}, the output may have a larger element bit-\/depth to preserve accuracy. And multi-\/channel arrays are also supported in these two reduction modes.


\begin{DoxyParams}{Parameters}
{\em src} & input 2D matrix. \\
\hline
{\em dst} & output vector. Its size and type is defined by {\ttfamily dim} and {\ttfamily dtype} parameters. \\
\hline
{\em dim} & dimension index along which the matrix is reduced. 0 means that the matrix is reduced to a single row. 1 means that the matrix is reduced to a single column. \\
\hline
{\em rtype} & reduction operation that could be one of the following\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+S\+UM\+: the output is the sum of all rows/columns of the matrix. 
\item C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+A\+VG\+: the output is the mean vector of all rows/columns of the matrix. 
\item C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+M\+AX\+: the output is the maximum (column/row-\/wise) of all rows/columns of the matrix. 
\item C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+M\+IN\+: the output is the minimum (column/row-\/wise) of all rows/columns of the matrix. 
\end{DoxyItemize}\\
\hline
{\em dtype} & when negative, the output vector will have the same type as the input matrix, otherwise, its type will be {\ttfamily C\+V\+\_\+\+M\+A\+K\+E\+\_\+\+T\+Y\+PE(C\+V\+\_\+\+M\+A\+T\+\_\+\+D\+E\+P\+T\+H(dtype), src.\+channels())}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#reduce}{\tt org.\+opencv.\+core.\+Core.\+reduce} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afcf15abfb6c9bf3a4126ae8199fc5ff3}{org.\+opencv.\+core.\+Core\+::repeat}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a40f3b2f5156462a56912093ce7d9dc47}\label{classorg_1_1opencv_1_1core_1_1_core_a40f3b2f5156462a56912093ce7d9dc47}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!reduce@{reduce}}
\index{reduce@{reduce}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{reduce()}{reduce()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+reduce (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{dim,  }\item[{int}]{rtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Reduces a matrix to a vector.

The function {\ttfamily reduce} reduces the matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. For example, the function can be used to compute horizontal and vertical projections of a raster image. In case of {\ttfamily C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+S\+UM} and {\ttfamily C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+A\+VG}, the output may have a larger element bit-\/depth to preserve accuracy. And multi-\/channel arrays are also supported in these two reduction modes.


\begin{DoxyParams}{Parameters}
{\em src} & input 2D matrix. \\
\hline
{\em dst} & output vector. Its size and type is defined by {\ttfamily dim} and {\ttfamily dtype} parameters. \\
\hline
{\em dim} & dimension index along which the matrix is reduced. 0 means that the matrix is reduced to a single row. 1 means that the matrix is reduced to a single column. \\
\hline
{\em rtype} & reduction operation that could be one of the following\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+S\+UM\+: the output is the sum of all rows/columns of the matrix. 
\item C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+A\+VG\+: the output is the mean vector of all rows/columns of the matrix. 
\item C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+M\+AX\+: the output is the maximum (column/row-\/wise) of all rows/columns of the matrix. 
\item C\+V\+\_\+\+R\+E\+D\+U\+C\+E\+\_\+\+M\+IN\+: the output is the minimum (column/row-\/wise) of all rows/columns of the matrix. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#reduce}{\tt org.\+opencv.\+core.\+Core.\+reduce} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_afcf15abfb6c9bf3a4126ae8199fc5ff3}{org.\+opencv.\+core.\+Core\+::repeat}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_afcf15abfb6c9bf3a4126ae8199fc5ff3}\label{classorg_1_1opencv_1_1core_1_1_core_afcf15abfb6c9bf3a4126ae8199fc5ff3}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!repeat@{repeat}}
\index{repeat@{repeat}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{repeat()}{repeat()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+repeat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{int}]{ny,  }\item[{int}]{nx,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Fills the output array with repeated copies of the input array.

The functions \char`\"{}repeat\char`\"{} duplicate the input array one or more times along each of the two axes\+:

{\itshape dst \+\_\+(ij)= src \+\_\+(i mod src.\+rows, j mod src.\+cols)}

The second variant of the function is more convenient to use with \char`\"{}\+Matrix\+Expressions\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em src} & input array to replicate. \\
\hline
{\em ny} & Flag to specify how many times the {\ttfamily src} is repeated along the vertical axis. \\
\hline
{\em nx} & Flag to specify how many times the {\ttfamily src} is repeated along the horizontal axis. \\
\hline
{\em dst} & output array of the same type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#repeat}{\tt org.\+opencv.\+core.\+Core.\+repeat} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1849fb31954ac7655a174184f2eba671}{org.\+opencv.\+core.\+Core\+::reduce}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}\label{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!scale\+Add@{scale\+Add}}
\index{scale\+Add@{scale\+Add}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{scale\+Add()}{scaleAdd()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+scale\+Add (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{double}]{alpha,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the sum of a scaled array and another array.

The function {\ttfamily scale\+Add} is one of the classical primitive linear algebra operations, known as {\ttfamily D\+A\+X\+PY} or {\ttfamily S\+A\+X\+PY} in B\+L\+AS (\href{http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Basic\+\_\+\+Linear\+\_\+\+Algebra\+\_\+\+Subprograms}). It calculates the sum of a scaled array and another array\+:

{\itshape dst(\+I)= scale $\ast$ src1(\+I) + src2(\+I)\&lt\+BR\&gt\+The function can also be emulated with a matrix expression, for example\+: \&lt\+BR\&gt\&ltcode\&gt}

// C++ code\+:

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A(3, 3, C\+V\+\_\+64\+F);...

A.\+row(0) = A.\+row(1)$\ast$2 + A.\+row(2);


\begin{DoxyParams}{Parameters}
{\em src1} & first input array. \\
\hline
{\em alpha} & a alpha \\
\hline
{\em src2} & second input array of the same size and type as {\ttfamily src1}. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src1}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#scaleadd}{\tt org.\+opencv.\+core.\+Core.\+scale\+Add} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a053eb46b103c30891659945a6434c5db}{org.\+opencv.\+core.\+Mat\+::dot}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}{org.\+opencv.\+core.\+Core\+::subtract}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a0932c141d51242fd49448aa6d4013101}\label{classorg_1_1opencv_1_1core_1_1_core_a0932c141d51242fd49448aa6d4013101}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!set\+Error\+Verbosity@{set\+Error\+Verbosity}}
\index{set\+Error\+Verbosity@{set\+Error\+Verbosity}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{set\+Error\+Verbosity()}{setErrorVerbosity()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+set\+Error\+Verbosity (\begin{DoxyParamCaption}\item[{boolean}]{verbose }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ae3f55d8eaa889edf706fb60874e92bd4}\label{classorg_1_1opencv_1_1core_1_1_core_ae3f55d8eaa889edf706fb60874e92bd4}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!set\+Identity@{set\+Identity}}
\index{set\+Identity@{set\+Identity}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{set\+Identity()}{setIdentity()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+set\+Identity (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mtx,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{s }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Initializes a scaled identity matrix.

The function \char`\"{}set\+Identity\char`\"{} initializes a scaled identity matrix\+:

{\itshape mtx(i,j)= value if i=j; 0 otherwise\&lt\+BR\&gt\+The function can also be emulated using the matrix initializers and the matrix expressions\+: \&lt\+BR\&gt\&ltcode\&gt}

// C++ code\+:

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A = Mat.\+eye(4, 3, C\+V\+\_\+32\+F)$\ast$5;

// A will be set to \mbox{[}\mbox{[}5, 0, 0\mbox{]}, \mbox{[}0, 5, 0\mbox{]}, \mbox{[}0, 0, 5\mbox{]}, \mbox{[}0, 0, 0\mbox{]}\mbox{]}


\begin{DoxyParams}{Parameters}
{\em mtx} & matrix to initialize (not necessarily square). \\
\hline
{\em s} & a s\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#setidentity}{\tt org.\+opencv.\+core.\+Core.\+set\+Identity} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a9316a305061d8ef51b7e7355d5e7440d}{org.\+opencv.\+core.\+Mat\+::set\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a34d703df023730d043298601b6962f57}{org.\+opencv.\+core.\+Mat\+::ones}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aff41070138369b96f792b19f01ab00d9}{org.\+opencv.\+core.\+Mat\+::zeros}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a9907da2380a9f7de76f9a82dc168cf56}\label{classorg_1_1opencv_1_1core_1_1_core_a9907da2380a9f7de76f9a82dc168cf56}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!set\+Identity@{set\+Identity}}
\index{set\+Identity@{set\+Identity}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{set\+Identity()}{setIdentity()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+set\+Identity (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mtx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Initializes a scaled identity matrix.

The function \char`\"{}set\+Identity\char`\"{} initializes a scaled identity matrix\+:

{\itshape mtx(i,j)= value if i=j; 0 otherwise\&lt\+BR\&gt\+The function can also be emulated using the matrix initializers and the matrix expressions\+: \&lt\+BR\&gt\&ltcode\&gt}

// C++ code\+:

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A = Mat.\+eye(4, 3, C\+V\+\_\+32\+F)$\ast$5;

// A will be set to \mbox{[}\mbox{[}5, 0, 0\mbox{]}, \mbox{[}0, 5, 0\mbox{]}, \mbox{[}0, 0, 5\mbox{]}, \mbox{[}0, 0, 0\mbox{]}\mbox{]}


\begin{DoxyParams}{Parameters}
{\em mtx} & matrix to initialize (not necessarily square).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#setidentity}{\tt org.\+opencv.\+core.\+Core.\+set\+Identity} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a9316a305061d8ef51b7e7355d5e7440d}{org.\+opencv.\+core.\+Mat\+::set\+To}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a34d703df023730d043298601b6962f57}{org.\+opencv.\+core.\+Mat\+::ones}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aff41070138369b96f792b19f01ab00d9}{org.\+opencv.\+core.\+Mat\+::zeros}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_af6e1ab8eaa1618c30a16e38da739bbeb}\label{classorg_1_1opencv_1_1core_1_1_core_af6e1ab8eaa1618c30a16e38da739bbeb}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!solve@{solve}}
\index{solve@{solve}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+core.\+Core.\+solve (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Solves one or more linear systems or least-\/squares problems.

The function {\ttfamily solve} solves a linear system or least-\/squares problem (the latter is possible with S\+VD or QR methods, or by specifying the flag {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+N\+O\+R\+M\+AL})\+:

{\itshape dst = arg min \+\_\+\+X$\vert$src1 $\ast$ X -\/ src2$\vert$}

If {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+LU} or {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+C\+H\+O\+L\+E\+S\+KY} method is used, the function returns 1 if {\ttfamily src1} (or {\itshape src1$^\wedge$\+Tsrc1}) is non-\/singular. Otherwise, it returns 0. In the latter case, {\ttfamily dst} is not valid. Other methods find a pseudo-\/solution in case of a singular left-\/hand side part.

Note\+: If you want to find a unity-\/norm solution of an under-\/defined singular system {\itshape src1$\ast$dst=0}, the function {\ttfamily solve} will not do the work. Use \char`\"{}\+S\+V\+D.\+solve\+Z\char`\"{} instead.


\begin{DoxyParams}{Parameters}
{\em src1} & input matrix on the left-\/hand side of the system. \\
\hline
{\em src2} & input matrix on the right-\/hand side of the system. \\
\hline
{\em dst} & output solution. \\
\hline
{\em flags} & solution (matrix inversion) method. 
\begin{DoxyItemize}
\item D\+E\+C\+O\+M\+P\+\_\+\+LU Gaussian elimination with optimal pivot element chosen. 
\item D\+E\+C\+O\+M\+P\+\_\+\+C\+H\+O\+L\+E\+S\+KY Cholesky {\itshape L\+L$^\wedge$T} factorization; the matrix {\ttfamily src1} must be symmetrical and positively defined. 
\item D\+E\+C\+O\+M\+P\+\_\+\+E\+IG eigenvalue decomposition; the matrix {\ttfamily src1} must be symmetrical. 
\item D\+E\+C\+O\+M\+P\+\_\+\+S\+VD singular value decomposition (S\+VD) method; the system can be over-\/defined and/or the matrix {\ttfamily src1} can be singular. 
\item D\+E\+C\+O\+M\+P\+\_\+\+QR QR factorization; the system can be over-\/defined and/or the matrix {\ttfamily src1} can be singular. 
\item D\+E\+C\+O\+M\+P\+\_\+\+N\+O\+R\+M\+AL while all the previous flags are mutually exclusive, this flag can be used together with any of the previous; it means that the normal equations {\itshape src1$^\wedge$\+T$\ast$src1$\ast$dst=src1$^\wedge$\+Tsrc2} are solved instead of the original system {\itshape src1$\ast$dst=src2}. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solve}{\tt org.\+opencv.\+core.\+Core.\+solve} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af7c788172a8e426cf6b6cedc8d828f1b}{org.\+opencv.\+core.\+Core\+::invert}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab44f09e696b045957316b9b384ef0c70}{org.\+opencv.\+core.\+Core\+::eigen}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a59b5de8a604e0fc96345da475f356bd3}\label{classorg_1_1opencv_1_1core_1_1_core_a59b5de8a604e0fc96345da475f356bd3}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!solve@{solve}}
\index{solve@{solve}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{solve()}{solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+core.\+Core.\+solve (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Solves one or more linear systems or least-\/squares problems.

The function {\ttfamily solve} solves a linear system or least-\/squares problem (the latter is possible with S\+VD or QR methods, or by specifying the flag {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+N\+O\+R\+M\+AL})\+:

{\itshape dst = arg min \+\_\+\+X$\vert$src1 $\ast$ X -\/ src2$\vert$}

If {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+LU} or {\ttfamily D\+E\+C\+O\+M\+P\+\_\+\+C\+H\+O\+L\+E\+S\+KY} method is used, the function returns 1 if {\ttfamily src1} (or {\itshape src1$^\wedge$\+Tsrc1}) is non-\/singular. Otherwise, it returns 0. In the latter case, {\ttfamily dst} is not valid. Other methods find a pseudo-\/solution in case of a singular left-\/hand side part.

Note\+: If you want to find a unity-\/norm solution of an under-\/defined singular system {\itshape src1$\ast$dst=0}, the function {\ttfamily solve} will not do the work. Use \char`\"{}\+S\+V\+D.\+solve\+Z\char`\"{} instead.


\begin{DoxyParams}{Parameters}
{\em src1} & input matrix on the left-\/hand side of the system. \\
\hline
{\em src2} & input matrix on the right-\/hand side of the system. \\
\hline
{\em dst} & output solution.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solve}{\tt org.\+opencv.\+core.\+Core.\+solve} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af7c788172a8e426cf6b6cedc8d828f1b}{org.\+opencv.\+core.\+Core\+::invert}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab44f09e696b045957316b9b384ef0c70}{org.\+opencv.\+core.\+Core\+::eigen}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ad5466c6635353bcb874f9fa8147c4368}\label{classorg_1_1opencv_1_1core_1_1_core_ad5466c6635353bcb874f9fa8147c4368}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!solve\+Cubic@{solve\+Cubic}}
\index{solve\+Cubic@{solve\+Cubic}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{solve\+Cubic()}{solveCubic()}}
{\footnotesize\ttfamily static int org.\+opencv.\+core.\+Core.\+solve\+Cubic (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{roots }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the real roots of a cubic equation.

The function {\ttfamily solve\+Cubic} finds the real roots of a cubic equation\+:


\begin{DoxyItemize}
\item if {\ttfamily coeffs} is a 4-\/element vector\+: 
\end{DoxyItemize}

{\itshape coeffs \mbox{[}0\mbox{]} x$^\wedge$3 + coeffs \mbox{[}1\mbox{]} x$^\wedge$2 + coeffs \mbox{[}2\mbox{]} x + coeffs \mbox{[}3\mbox{]} = 0}


\begin{DoxyItemize}
\item if {\ttfamily coeffs} is a 3-\/element vector\+: 
\end{DoxyItemize}

{\itshape x$^\wedge$3 + coeffs \mbox{[}0\mbox{]} x$^\wedge$2 + coeffs \mbox{[}1\mbox{]} x + coeffs \mbox{[}2\mbox{]} = 0}

The roots are stored in the {\ttfamily roots} array.


\begin{DoxyParams}{Parameters}
{\em coeffs} & equation coefficients, an array of 3 or 4 elements. \\
\hline
{\em roots} & output array of real roots that has 1 or 3 elements.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solvecubic}{\tt org.\+opencv.\+core.\+Core.\+solve\+Cubic} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_afff6c36fd7aad820639aa8de5b52a5f7}\label{classorg_1_1opencv_1_1core_1_1_core_afff6c36fd7aad820639aa8de5b52a5f7}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!solve\+Poly@{solve\+Poly}}
\index{solve\+Poly@{solve\+Poly}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{solve\+Poly()}{solvePoly()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+solve\+Poly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{roots,  }\item[{int}]{max\+Iters }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the real or complex roots of a polynomial equation.

The function {\ttfamily solve\+Poly} finds real and complex roots of a polynomial equation\+:

{\itshape coeffs \mbox{[}n\mbox{]} x$^\wedge$(n) + coeffs \mbox{[}n-\/1\mbox{]} x$^\wedge$(n-\/1) +... + coeffs \mbox{[}1\mbox{]} x + coeffs \mbox{[}0\mbox{]} = 0}


\begin{DoxyParams}{Parameters}
{\em coeffs} & array of polynomial coefficients. \\
\hline
{\em roots} & output (complex) array of roots. \\
\hline
{\em max\+Iters} & maximum number of iterations the algorithm does.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solvepoly}{\tt org.\+opencv.\+core.\+Core.\+solve\+Poly} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aec537b8ec1bca2bbff556a00efc08579}\label{classorg_1_1opencv_1_1core_1_1_core_aec537b8ec1bca2bbff556a00efc08579}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!solve\+Poly@{solve\+Poly}}
\index{solve\+Poly@{solve\+Poly}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{solve\+Poly()}{solvePoly()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static double org.\+opencv.\+core.\+Core.\+solve\+Poly (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{roots }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the real or complex roots of a polynomial equation.

The function {\ttfamily solve\+Poly} finds real and complex roots of a polynomial equation\+:

{\itshape coeffs \mbox{[}n\mbox{]} x$^\wedge$(n) + coeffs \mbox{[}n-\/1\mbox{]} x$^\wedge$(n-\/1) +... + coeffs \mbox{[}1\mbox{]} x + coeffs \mbox{[}0\mbox{]} = 0}


\begin{DoxyParams}{Parameters}
{\em coeffs} & array of polynomial coefficients. \\
\hline
{\em roots} & output (complex) array of roots.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#solvepoly}{\tt org.\+opencv.\+core.\+Core.\+solve\+Poly} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ae5b5fdaa4bafa45a5a43443016b037b6}\label{classorg_1_1opencv_1_1core_1_1_core_ae5b5fdaa4bafa45a5a43443016b037b6}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!sort@{sort}}
\index{sort@{sort}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{sort()}{sort()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+sort (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Sorts each row or each column of a matrix.

The function {\ttfamily sort} sorts each matrix row or each matrix column in ascending or descending order. So you should pass two operation flags to get desired behaviour. If you want to sort matrix rows or columns lexicographically, you can use S\+TL {\ttfamily std.\+sort} generic function with the proper comparison predicate.


\begin{DoxyParams}{Parameters}
{\em src} & input single-\/channel array. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}. \\
\hline
{\em flags} & operation flags, a combination of the following values\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+S\+O\+R\+T\+\_\+\+E\+V\+E\+R\+Y\+\_\+\+R\+OW each matrix row is sorted independently. 
\item C\+V\+\_\+\+S\+O\+R\+T\+\_\+\+E\+V\+E\+R\+Y\+\_\+\+C\+O\+L\+U\+MN each matrix column is sorted independently; this flag and the previous one are mutually exclusive. 
\item C\+V\+\_\+\+S\+O\+R\+T\+\_\+\+A\+S\+C\+E\+N\+D\+I\+NG each matrix row is sorted in the ascending order. 
\item C\+V\+\_\+\+S\+O\+R\+T\+\_\+\+D\+E\+S\+C\+E\+N\+D\+I\+NG each matrix row is sorted in the descending order; this flag and the previous one are also mutually exclusive. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#sort}{\tt org.\+opencv.\+core.\+Core.\+sort} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab80ad04c349aee7d887830ec8de84ae2}{org.\+opencv.\+core.\+Core\+::rand\+Shuffle}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a68ae6cb0aec9fde08e91a48427684a7e}{org.\+opencv.\+core.\+Core\+::sort\+Idx}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a68ae6cb0aec9fde08e91a48427684a7e}\label{classorg_1_1opencv_1_1core_1_1_core_a68ae6cb0aec9fde08e91a48427684a7e}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!sort\+Idx@{sort\+Idx}}
\index{sort\+Idx@{sort\+Idx}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{sort\+Idx()}{sortIdx()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+sort\+Idx (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Sorts each row or each column of a matrix.

The function {\ttfamily sort\+Idx} sorts each matrix row or each matrix column in the ascending or descending order. So you should pass two operation flags to get desired behaviour. Instead of reordering the elements themselves, it stores the indices of sorted elements in the output array. For example\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A = Mat.\+eye(3,3,\+C\+V\+\_\+32\+F), B;}

{\ttfamily }

{\ttfamily }

{\ttfamily sort\+Idx(A, B, C\+V\+\_\+\+S\+O\+R\+T\+\_\+\+E\+V\+E\+R\+Y\+\_\+\+R\+OW + C\+V\+\_\+\+S\+O\+R\+T\+\_\+\+A\+S\+C\+E\+N\+D\+I\+NG);}

{\ttfamily }

{\ttfamily }

{\ttfamily // B will probably contain}

{\ttfamily }

{\ttfamily }

{\ttfamily // (because of equal elements in A some permutations are possible)\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // \mbox{[}\mbox{[}1, 2, 0\mbox{]}, \mbox{[}0, 2, 1\mbox{]}, \mbox{[}0, 1, 2\mbox{]}\mbox{]}}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em src} & input single-\/channel array. \\
\hline
{\em dst} & output integer array of the same size as {\ttfamily src}. \\
\hline
{\em flags} & operation flags that could be a combination of the following values\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+S\+O\+R\+T\+\_\+\+E\+V\+E\+R\+Y\+\_\+\+R\+OW each matrix row is sorted independently. 
\item C\+V\+\_\+\+S\+O\+R\+T\+\_\+\+E\+V\+E\+R\+Y\+\_\+\+C\+O\+L\+U\+MN each matrix column is sorted independently; this flag and the previous one are mutually exclusive. 
\item C\+V\+\_\+\+S\+O\+R\+T\+\_\+\+A\+S\+C\+E\+N\+D\+I\+NG each matrix row is sorted in the ascending order. 
\item C\+V\+\_\+\+S\+O\+R\+T\+\_\+\+D\+E\+S\+C\+E\+N\+D\+I\+NG each matrix row is sorted in the descending order; his flag and the previous one are also mutually exclusive. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#sortidx}{\tt org.\+opencv.\+core.\+Core.\+sort\+Idx} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ae5b5fdaa4bafa45a5a43443016b037b6}{org.\+opencv.\+core.\+Core\+::sort}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ab80ad04c349aee7d887830ec8de84ae2}{org.\+opencv.\+core.\+Core\+::rand\+Shuffle}} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aa22f046c4f14cda50c10f5d22ffdbb26}\label{classorg_1_1opencv_1_1core_1_1_core_aa22f046c4f14cda50c10f5d22ffdbb26}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!split@{split}}
\index{split@{split}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{split()}{split()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+split (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{mv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Divides a multi-\/channel array into several single-\/channel arrays.

The functions {\ttfamily split} split a multi-\/channel array into separate single-\/channel arrays\+:

{\itshape mv \mbox{[}c\mbox{]}(I) = src(\+I)\+\_\+c}

If you need to extract a single channel or do some other sophisticated channel permutation, use \char`\"{}mix\+Channels\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em m} & a m \\
\hline
{\em mv} & output array or vector of arrays; in the first variant of the function the number of arrays must match {\ttfamily src.\+channels()}; the arrays themselves are reallocated, if needed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#split}{\tt org.\+opencv.\+core.\+Core.\+split} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af245932b4a6d1aee20be9610388bb06a}{org.\+opencv.\+core.\+Core\+::merge}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab8fb70fea379b4215a77122d698d860d}{org.\+opencv.\+imgproc.\+Imgproc\+::cvt\+Color}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a812a71941c37c615cb474bff0eacbb2e}{org.\+opencv.\+core.\+Core\+::mix\+Channels}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a5a2235761d8876294b3277876479107b}\label{classorg_1_1opencv_1_1core_1_1_core_a5a2235761d8876294b3277876479107b}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!sqrt@{sqrt}}
\index{sqrt@{sqrt}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{sqrt()}{sqrt()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+sqrt (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a square root of array elements.

The functions {\ttfamily sqrt} calculate a square root of each input array element. In case of multi-\/channel arrays, each channel is processed independently. The accuracy is approximately the same as of the built-\/in {\ttfamily std.\+sqrt}.


\begin{DoxyParams}{Parameters}
{\em src} & input floating-\/point array. \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#sqrt}{\tt org.\+opencv.\+core.\+Core.\+sqrt} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a29c20af97ae09c75246777774bc6d41b}{org.\+opencv.\+core.\+Core\+::pow}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_ac0195922fb03d6bad195054e615cb4e1}{org.\+opencv.\+core.\+Core\+::magnitude}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}\label{classorg_1_1opencv_1_1core_1_1_core_a8020349ec5e9b654d78d690654c79606}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!subtract@{subtract}}
\index{subtract@{subtract}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{subtract()}{subtract()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+subtract (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element difference between two arrays or array and a scalar.

The function {\ttfamily subtract} calculates\+:


\begin{DoxyItemize}
\item Difference between two arrays, when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between an array and a scalar, when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between a scalar and an array, when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item The reverse difference between a scalar and an array in the case of {\ttfamily Sub\+RS}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src2 -\/ src1(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 -\/ src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst -\/= src1; // equivalent to subtract(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-\/bit unsigned arrays and store the difference in a 16-\/bit signed array. Depth of the output array is determined by {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array of the same size and the same number of channels as the input array. \\
\hline
{\em mask} & optional operation mask; this is an 8-\/bit single channel array that specifies elements of the output array to be changed. \\
\hline
{\em dtype} & optional depth of the output array (see the details below).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract}{\tt org.\+opencv.\+core.\+Core.\+subtract} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aba1cd3f5a5c28b9c72daf97b95677d7a}\label{classorg_1_1opencv_1_1core_1_1_core_aba1cd3f5a5c28b9c72daf97b95677d7a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!subtract@{subtract}}
\index{subtract@{subtract}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{subtract()}{subtract()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+subtract (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element difference between two arrays or array and a scalar.

The function {\ttfamily subtract} calculates\+:


\begin{DoxyItemize}
\item Difference between two arrays, when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between an array and a scalar, when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between a scalar and an array, when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item The reverse difference between a scalar and an array in the case of {\ttfamily Sub\+RS}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src2 -\/ src1(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 -\/ src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst -\/= src1; // equivalent to subtract(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-\/bit unsigned arrays and store the difference in a 16-\/bit signed array. Depth of the output array is determined by {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array of the same size and the same number of channels as the input array. \\
\hline
{\em mask} & optional operation mask; this is an 8-\/bit single channel array that specifies elements of the output array to be changed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract}{\tt org.\+opencv.\+core.\+Core.\+subtract} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ae6f3f612d92b7907ac2daa9c2f8a2ee2}\label{classorg_1_1opencv_1_1core_1_1_core_ae6f3f612d92b7907ac2daa9c2f8a2ee2}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!subtract@{subtract}}
\index{subtract@{subtract}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{subtract()}{subtract()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+subtract (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element difference between two arrays or array and a scalar.

The function {\ttfamily subtract} calculates\+:


\begin{DoxyItemize}
\item Difference between two arrays, when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between an array and a scalar, when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between a scalar and an array, when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item The reverse difference between a scalar and an array in the case of {\ttfamily Sub\+RS}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src2 -\/ src1(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 -\/ src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst -\/= src1; // equivalent to subtract(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-\/bit unsigned arrays and store the difference in a 16-\/bit signed array. Depth of the output array is determined by {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array of the same size and the same number of channels as the input array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract}{\tt org.\+opencv.\+core.\+Core.\+subtract} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_abf10e2e2d74d5e9bc9785dcda5933ea9}\label{classorg_1_1opencv_1_1core_1_1_core_abf10e2e2d74d5e9bc9785dcda5933ea9}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!subtract@{subtract}}
\index{subtract@{subtract}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{subtract()}{subtract()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+subtract (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{int}]{dtype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element difference between two arrays or array and a scalar.

The function {\ttfamily subtract} calculates\+:


\begin{DoxyItemize}
\item Difference between two arrays, when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between an array and a scalar, when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between a scalar and an array, when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item The reverse difference between a scalar and an array in the case of {\ttfamily Sub\+RS}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src2 -\/ src1(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 -\/ src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst -\/= src1; // equivalent to subtract(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-\/bit unsigned arrays and store the difference in a 16-\/bit signed array. Depth of the output array is determined by {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array of the same size and the same number of channels as the input array. \\
\hline
{\em mask} & optional operation mask; this is an 8-\/bit single channel array that specifies elements of the output array to be changed. \\
\hline
{\em dtype} & optional depth of the output array (see the details below).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract}{\tt org.\+opencv.\+core.\+Core.\+subtract} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a5a5060e06b78859e4f22f964ee6dac4d}\label{classorg_1_1opencv_1_1core_1_1_core_a5a5060e06b78859e4f22f964ee6dac4d}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!subtract@{subtract}}
\index{subtract@{subtract}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{subtract()}{subtract()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+subtract (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element difference between two arrays or array and a scalar.

The function {\ttfamily subtract} calculates\+:


\begin{DoxyItemize}
\item Difference between two arrays, when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between an array and a scalar, when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between a scalar and an array, when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item The reverse difference between a scalar and an array in the case of {\ttfamily Sub\+RS}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src2 -\/ src1(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 -\/ src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst -\/= src1; // equivalent to subtract(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-\/bit unsigned arrays and store the difference in a 16-\/bit signed array. Depth of the output array is determined by {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array of the same size and the same number of channels as the input array. \\
\hline
{\em mask} & optional operation mask; this is an 8-\/bit single channel array that specifies elements of the output array to be changed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract}{\tt org.\+opencv.\+core.\+Core.\+subtract} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a51ebf388c0fd37fdaf07cd30cd54c8ea}\label{classorg_1_1opencv_1_1core_1_1_core_a51ebf388c0fd37fdaf07cd30cd54c8ea}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!subtract@{subtract}}
\index{subtract@{subtract}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{subtract()}{subtract()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+subtract (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the per-\/element difference between two arrays or array and a scalar.

The function {\ttfamily subtract} calculates\+:


\begin{DoxyItemize}
\item Difference between two arrays, when both input arrays have the same size and the same number of channels\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between an array and a scalar, when {\ttfamily src2} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src1.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1(\+I) -\/ src2) if mask(\+I) != 0}


\begin{DoxyItemize}
\item Difference between a scalar and an array, when {\ttfamily src1} is constructed from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}} or has the same number of elements as {\ttfamily src2.\+channels()}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src1 -\/ src2(\+I)) if mask(\+I) != 0}


\begin{DoxyItemize}
\item The reverse difference between a scalar and an array in the case of {\ttfamily Sub\+RS}\+: 
\end{DoxyItemize}

{\itshape dst(\+I) = saturate(src2 -\/ src1(\+I)) if mask(\+I) != 0}

where {\ttfamily I} is a multi-\/dimensional index of array elements. In case of multi-\/channel arrays, each channel is processed independently. The first function in the list above can be replaced with matrix expressions\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily dst = src1 -\/ src2;}

{\ttfamily }

{\ttfamily }

{\ttfamily dst -\/= src1; // equivalent to subtract(dst, src1, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-\/bit unsigned arrays and store the difference in a 16-\/bit signed array. Depth of the output array is determined by {\ttfamily dtype} parameter. In the second and third cases above, as well as in the first case, when {\ttfamily src1.\+depth() == src2.\+depth()}, {\ttfamily dtype} can be set to the default {\ttfamily -\/1}. In this case the output array will have the same depth as the input array, be it {\ttfamily src1}, {\ttfamily src2} or both. }

Note\+: Saturation is not applied when the output array has the depth {\ttfamily C\+V\+\_\+32S}. You may even get result of an incorrect sign in the case of overflow.


\begin{DoxyParams}{Parameters}
{\em src1} & first input array or a scalar. \\
\hline
{\em src2} & second input array or a scalar. \\
\hline
{\em dst} & output array of the same size and the same number of channels as the input array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#subtract}{\tt org.\+opencv.\+core.\+Core.\+subtract} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_add4de9ffbc90262f78aa239a0907c73f}{org.\+opencv.\+core.\+Core\+::add\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4407c6151f3d144759c44ec6515ac643}{org.\+opencv.\+core.\+Core\+::add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a5053d6e5d48e8df91d540032cbc5ed6c}{org.\+opencv.\+core.\+Core\+::scale\+Add}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{org.\+opencv.\+core.\+Mat\+::convert\+To}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a3c40c8e48917ad9a27fa45674bff78a3}\label{classorg_1_1opencv_1_1core_1_1_core_a3c40c8e48917ad9a27fa45674bff78a3}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!sum\+Elems@{sum\+Elems}}
\index{sum\+Elems@{sum\+Elems}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{sum\+Elems()}{sumElems()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} org.\+opencv.\+core.\+Core.\+sum\+Elems (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the sum of array elements.

The functions {\ttfamily sum} calculate and return the sum of array elements, independently for each channel.


\begin{DoxyParams}{Parameters}
{\em src} & a src\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#sum}{\tt org.\+opencv.\+core.\+Core.\+sum} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_af8d7fbb33c11fbf6115d4c242dbbb5b3}{org.\+opencv.\+core.\+Core\+::mean\+Std\+Dev}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1849fb31954ac7655a174184f2eba671}{org.\+opencv.\+core.\+Core\+::reduce}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a87987114238d2094a01395f12d6a9367}{org.\+opencv.\+core.\+Core\+::min\+Max\+Loc}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a216308f36e765f82c521087fe283e045}{org.\+opencv.\+core.\+Core\+::count\+Non\+Zero}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a282aac8c7806f10f75738bf8db3af7a8}{org.\+opencv.\+core.\+Core\+::norm}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aff700e66b1cef1a74cfd94d405369edf}{org.\+opencv.\+core.\+Core\+::mean}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a8f8ec69060789e7183c4a2a49dd729d9}\label{classorg_1_1opencv_1_1core_1_1_core_a8f8ec69060789e7183c4a2a49dd729d9}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!S\+V\+Back\+Subst@{S\+V\+Back\+Subst}}
\index{S\+V\+Back\+Subst@{S\+V\+Back\+Subst}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{S\+V\+Back\+Subst()}{SVBackSubst()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+S\+V\+Back\+Subst (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{w,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{u,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{vt,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{rhs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a8b6381c8ddf094439720386b1acdb9ce}\label{classorg_1_1opencv_1_1core_1_1_core_a8b6381c8ddf094439720386b1acdb9ce}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!S\+V\+Decomp@{S\+V\+Decomp}}
\index{S\+V\+Decomp@{S\+V\+Decomp}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{S\+V\+Decomp()}{SVDecomp()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+S\+V\+Decomp (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{w,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{u,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{vt,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aa2a097bef3c1f59efe29e6a723640851}\label{classorg_1_1opencv_1_1core_1_1_core_aa2a097bef3c1f59efe29e6a723640851}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!S\+V\+Decomp@{S\+V\+Decomp}}
\index{S\+V\+Decomp@{S\+V\+Decomp}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{S\+V\+Decomp()}{SVDecomp()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+S\+V\+Decomp (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{w,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{u,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{vt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a9c17a12158c59ea65c662cac491c28c3}\label{classorg_1_1opencv_1_1core_1_1_core_a9c17a12158c59ea65c662cac491c28c3}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!trace@{trace}}
\index{trace@{trace}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{trace()}{trace()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} org.\+opencv.\+core.\+Core.\+trace (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mtx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the trace of a matrix.

The function {\ttfamily trace} returns the sum of the diagonal elements of the matrix {\ttfamily mtx}.

{\itshape tr(mtx) = sum \+\_\+i mtx(i,i)}


\begin{DoxyParams}{Parameters}
{\em mtx} & a mtx\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#trace}{\tt org.\+opencv.\+core.\+Core.\+trace} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a221e7697d1a57961ee8a843b7aa05b75}\label{classorg_1_1opencv_1_1core_1_1_core_a221e7697d1a57961ee8a843b7aa05b75}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!transform@{transform}}
\index{transform@{transform}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{transform()}{transform()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+transform (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs the matrix transformation of every array element.

The function {\ttfamily transform} performs the matrix transformation of every element of the array {\ttfamily src} and stores the results in {\ttfamily dst} \+:

{\itshape dst(\+I) = m $\ast$ src(\+I)}

(when {\ttfamily m.\+cols=src.\+channels()}), or

{\itshape dst(\+I) = m $\ast$ \mbox{[} src(\+I); 1\mbox{]}}

(when {\ttfamily m.\+cols=src.\+channels()+1})

Every element of the {\ttfamily N} -\/channel array {\ttfamily src} is interpreted as {\ttfamily N} -\/element vector that is transformed using the {\ttfamily M x N} or {\ttfamily M x (N+1)} matrix {\ttfamily m} to {\ttfamily M}-\/element vector -\/ the corresponding element of the output array {\ttfamily dst}.

The function may be used for geometrical transformation of {\ttfamily N} -\/dimensional points, arbitrary linear color space transformation (such as various kinds of R\+GB to Y\+UV transforms), shuffling the image channels, and so forth.


\begin{DoxyParams}{Parameters}
{\em src} & input array that must have as many channels (1 to 4) as {\ttfamily m.\+cols} or {\ttfamily m.\+cols-\/1}. \\
\hline
{\em dst} & output array of the same size and depth as {\ttfamily src}; it has as many channels as {\ttfamily m.\+rows}. \\
\hline
{\em m} & transformation {\ttfamily 2x2} or {\ttfamily 2x3} floating-\/point matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#transform}{\tt org.\+opencv.\+core.\+Core.\+transform} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Affine}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1ff0eace0f00e79af5228fdae120342a}{org.\+opencv.\+core.\+Core\+::perspective\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a283e61c00d4e6ba9625264d8d7f5f8db}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Affine\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1video_1_1_video_ad9c2fbb377a485b9619be2c78eaf7cee}{org.\+opencv.\+video.\+Video\+::estimate\+Rigid\+Transform}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a4536de6a43f5dfb4d4ba1bf24735696a}\label{classorg_1_1opencv_1_1core_1_1_core_a4536de6a43f5dfb4d4ba1bf24735696a}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!transpose@{transpose}}
\index{transpose@{transpose}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{transpose()}{transpose()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+transpose (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Transposes a matrix.

The function \char`\"{}transpose\char`\"{} transposes the matrix {\ttfamily src} \+:

{\itshape dst(i,j) = src(j,i)}

Note\+: No complex conjugation is done in case of a complex matrix. It it should be done separately if needed.


\begin{DoxyParams}{Parameters}
{\em src} & input array. \\
\hline
{\em dst} & output array of the same type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/operations_on_arrays.html#transpose}{\tt org.\+opencv.\+core.\+Core.\+transpose} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a8dee19abadf7067469cd4532a2fd62fd}\label{classorg_1_1opencv_1_1core_1_1_core_a8dee19abadf7067469cd4532a2fd62fd}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!vconcat@{vconcat}}
\index{vconcat@{vconcat}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{vconcat()}{vconcat()}}
{\footnotesize\ttfamily static void org.\+opencv.\+core.\+Core.\+vconcat (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



\subsection{Member Data Documentation}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a6f74a56e173ada31969137d7d80d44b5}\label{classorg_1_1opencv_1_1core_1_1_core_a6f74a56e173ada31969137d7d80d44b5}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!N\+A\+T\+I\+V\+E\+\_\+\+L\+I\+B\+R\+A\+R\+Y\+\_\+\+N\+A\+ME@{N\+A\+T\+I\+V\+E\+\_\+\+L\+I\+B\+R\+A\+R\+Y\+\_\+\+N\+A\+ME}}
\index{N\+A\+T\+I\+V\+E\+\_\+\+L\+I\+B\+R\+A\+R\+Y\+\_\+\+N\+A\+ME@{N\+A\+T\+I\+V\+E\+\_\+\+L\+I\+B\+R\+A\+R\+Y\+\_\+\+N\+A\+ME}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{N\+A\+T\+I\+V\+E\+\_\+\+L\+I\+B\+R\+A\+R\+Y\+\_\+\+N\+A\+ME}{NATIVE\_LIBRARY\_NAME}}
{\footnotesize\ttfamily final String org.\+opencv.\+core.\+Core.\+N\+A\+T\+I\+V\+E\+\_\+\+L\+I\+B\+R\+A\+R\+Y\+\_\+\+N\+A\+ME = get\+Native\+Library\+Name()\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a0d0df5fd9960ef75c8256603419f345d}\label{classorg_1_1opencv_1_1core_1_1_core_a0d0df5fd9960ef75c8256603419f345d}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!S\+V\+D\+\_\+\+M\+O\+D\+I\+F\+Y\+\_\+A@{S\+V\+D\+\_\+\+M\+O\+D\+I\+F\+Y\+\_\+A}}
\index{S\+V\+D\+\_\+\+M\+O\+D\+I\+F\+Y\+\_\+A@{S\+V\+D\+\_\+\+M\+O\+D\+I\+F\+Y\+\_\+A}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{S\+V\+D\+\_\+\+M\+O\+D\+I\+F\+Y\+\_\+A}{SVD\_MODIFY\_A}}
{\footnotesize\ttfamily final int org.\+opencv.\+core.\+Core.\+S\+V\+D\+\_\+\+M\+O\+D\+I\+F\+Y\+\_\+A = 1\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a8b5aa972c9a65c4dc8da80aa97a9e0d6}\label{classorg_1_1opencv_1_1core_1_1_core_a8b5aa972c9a65c4dc8da80aa97a9e0d6}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!V\+E\+R\+S\+I\+ON@{V\+E\+R\+S\+I\+ON}}
\index{V\+E\+R\+S\+I\+ON@{V\+E\+R\+S\+I\+ON}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{V\+E\+R\+S\+I\+ON}{VERSION}}
{\footnotesize\ttfamily final String org.\+opencv.\+core.\+Core.\+V\+E\+R\+S\+I\+ON = get\+Version()\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_aed42db3ccc84e356b8d432c0271e9ee7}\label{classorg_1_1opencv_1_1core_1_1_core_aed42db3ccc84e356b8d432c0271e9ee7}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!V\+E\+R\+S\+I\+O\+N\+\_\+\+E\+P\+O\+CH@{V\+E\+R\+S\+I\+O\+N\+\_\+\+E\+P\+O\+CH}}
\index{V\+E\+R\+S\+I\+O\+N\+\_\+\+E\+P\+O\+CH@{V\+E\+R\+S\+I\+O\+N\+\_\+\+E\+P\+O\+CH}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{V\+E\+R\+S\+I\+O\+N\+\_\+\+E\+P\+O\+CH}{VERSION\_EPOCH}}
{\footnotesize\ttfamily final int org.\+opencv.\+core.\+Core.\+V\+E\+R\+S\+I\+O\+N\+\_\+\+E\+P\+O\+CH = get\+Version\+Epoch()\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a4c31c533f50245f45626ce220e67638d}\label{classorg_1_1opencv_1_1core_1_1_core_a4c31c533f50245f45626ce220e67638d}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+A\+J\+OR@{V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+A\+J\+OR}}
\index{V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+A\+J\+OR@{V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+A\+J\+OR}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+A\+J\+OR}{VERSION\_MAJOR}}
{\footnotesize\ttfamily final int org.\+opencv.\+core.\+Core.\+V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+A\+J\+OR = get\+Version\+Major()\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_a8c815d0d147f2ec108adc1ead0107822}\label{classorg_1_1opencv_1_1core_1_1_core_a8c815d0d147f2ec108adc1ead0107822}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+I\+N\+OR@{V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+I\+N\+OR}}
\index{V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+I\+N\+OR@{V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+I\+N\+OR}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+I\+N\+OR}{VERSION\_MINOR}}
{\footnotesize\ttfamily final int org.\+opencv.\+core.\+Core.\+V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+I\+N\+OR = get\+Version\+Minor()\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_core_ae29e5d49ffed39a7b12e44d4101ad944}\label{classorg_1_1opencv_1_1core_1_1_core_ae29e5d49ffed39a7b12e44d4101ad944}} 
\index{org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}!V\+E\+R\+S\+I\+O\+N\+\_\+\+R\+E\+V\+I\+S\+I\+ON@{V\+E\+R\+S\+I\+O\+N\+\_\+\+R\+E\+V\+I\+S\+I\+ON}}
\index{V\+E\+R\+S\+I\+O\+N\+\_\+\+R\+E\+V\+I\+S\+I\+ON@{V\+E\+R\+S\+I\+O\+N\+\_\+\+R\+E\+V\+I\+S\+I\+ON}!org\+::opencv\+::core\+::\+Core@{org\+::opencv\+::core\+::\+Core}}
\subsubsection{\texorpdfstring{V\+E\+R\+S\+I\+O\+N\+\_\+\+R\+E\+V\+I\+S\+I\+ON}{VERSION\_REVISION}}
{\footnotesize\ttfamily final int org.\+opencv.\+core.\+Core.\+V\+E\+R\+S\+I\+O\+N\+\_\+\+R\+E\+V\+I\+S\+I\+ON = get\+Version\+Revision()\hspace{0.3cm}{\ttfamily [static]}}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/\+Marcius/\+Documents/\+Git\+Hub/\+Skaitliuko-\/\+Skeneris/open\+C\+V\+Library249/src/main/java/org/opencv/core/\mbox{\hyperlink{_core_8java}{Core.\+java}}\end{DoxyCompactItemize}
