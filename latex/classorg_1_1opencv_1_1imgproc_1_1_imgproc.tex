\hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc}{}\section{org.\+opencv.\+imgproc.\+Imgproc Class Reference}
\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc}\index{org.\+opencv.\+imgproc.\+Imgproc@{org.\+opencv.\+imgproc.\+Imgproc}}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac6e36285c582511bc5afe41d9d0b0e41}{Canny}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} edges, double threshold1, double threshold2, int aperture\+Size, boolean L2gradient)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae979d995b2b91944a5db1e3be9c3835f}{Canny}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} edges, double threshold1, double threshold2)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{Gaussian\+Blur}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, double sigmaX, double sigmaY, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6550b1518d3df5dc446f27cd8f1c2285}{Gaussian\+Blur}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, double sigmaX, double sigmaY)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a38b4cc1a250ce929d1b2635675332b6a}{Gaussian\+Blur}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, double sigmaX)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0338b01497ff28dc2c68f353a300cc7a}{Hough\+Circles}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} circles, int method, double dp, double min\+Dist, double param1, double param2, int min\+Radius, int max\+Radius)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6fa86b567ca08ae92eab90cc998728d9}{Hough\+Circles}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} circles, int method, double dp, double min\+Dist)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a28db1a1f638c5882a4f1af67f081522c}{Hough\+Lines}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} lines, double rho, double theta, int \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a428d1896f05ae5e0eadbe9a1489e6368}{threshold}}, double srn, double stn)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6b72bf2114aa1ea4e834451880a5eb8b}{Hough\+Lines}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} lines, double rho, double theta, int \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a428d1896f05ae5e0eadbe9a1489e6368}{threshold}})
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abcb38549a6c9bd2ec81e601a0a76e4ba}{Hough\+LinesP}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} lines, double rho, double theta, int \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a428d1896f05ae5e0eadbe9a1489e6368}{threshold}}, double min\+Line\+Length, double max\+Line\+Gap)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af9376e12a80f1305ddc5fb8046220902}{Hough\+LinesP}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} lines, double rho, double theta, int \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a428d1896f05ae5e0eadbe9a1489e6368}{threshold}})
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a98bb53e1f35c2f318b22de3b4bc753e1}{Hu\+Moments}} (\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}} m, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} hu)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_add62d4b55bc4e7cc4faca4a77f6d3f94}{Laplacian}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, int ksize, double scale, double delta, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a0b5f6b5d9d7519bb45c57460d697e7}{Laplacian}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, int ksize, double scale, double delta)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a69fc2b48c9e0b1e656c2320ed76b808a}{Laplacian}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab8ba2ea90f6c3696be6e21a9c2da2a22}{P\+S\+NR}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c9e2fdd65ecd76ae9135e33cfb9a99}{Scharr}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, int dx, int dy, double scale, double delta, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6f27ca323b9ddb24d2b74ac4e106ea53}{Scharr}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, int dx, int dy, double scale, double delta)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac86859d311e2cb092dd9cddcfb20d900}{Scharr}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, int dx, int dy)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a85a8cac062c05efeecf99de50f3ab8d7}{Sobel}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aaec4c3ad19dcdf58835672462d7e1186}{Sobel}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, int dx, int dy, int ksize, double scale, double delta)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae4b25b52b9fa3942a6400c936cc2e683}{Sobel}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, int dx, int dy)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{accumulate}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a63cfc78fd4e08d233d1f36d4609081ce}{accumulate}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{accumulate\+Product}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa913bcb064a1079140398a6e7501df14}{accumulate\+Product}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{accumulate\+Square}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad364d805ad0822ebced2cfb163d6a095}{accumulate\+Square}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a67077201750b8f44b2a8ce7483f58883}{accumulate\+Weighted}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double alpha, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac68bfd1c13f6547a6db9d14a88c9fa53}{accumulate\+Weighted}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double alpha)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1b26a0ff327de4e9e576eb2950794d19}{adaptive\+Bilateral\+Filter}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, double sigma\+Space, double max\+Sigma\+Color, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa76bd5802e7865c91dcc13152fbd7f1a}{adaptive\+Bilateral\+Filter}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, double sigma\+Space, double max\+Sigma\+Color, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1ce86f78f836c6c711db8aaeae46bf09}{adaptive\+Bilateral\+Filter}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, double sigma\+Space)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8daf182545498116be4dabcfd9a0429e}{adaptive\+Threshold}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double max\+Value, int adaptive\+Method, int threshold\+Type, int block\+Size, double C)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af6bf03f1dd26e4ddc0a25996533d93e3}{approx\+Poly\+DP}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} curve, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} approx\+Curve, double epsilon, boolean closed)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7e92ef5f2b2d486e256ee5e813de19c6}{arc\+Length}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} curve, boolean closed)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}{bilateral\+Filter}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int d, double sigma\+Color, double sigma\+Space, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7cba1f76aed036501535e765c84a2863}{bilateral\+Filter}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int d, double sigma\+Color, double sigma\+Space)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{blur}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0fe51807c2759c41bcb5e7f1d94a7653}{blur}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad6e54f4b433f175352dedaef88474de3}{blur}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize)
\item 
static int \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0bd258d65b0db015ac1106dea7126e9d}{border\+Interpolate}} (int p, int len, int border\+Type)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_adf01c1b9e7cf458ac7ed330da5974503}{bounding\+Rect}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} points)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}{box\+Filter}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, boolean normalize, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a064f2f5351affaec5ad2c3b88c957faa}{box\+Filter}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, boolean normalize)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0e852635eaf9272b1ec800779c4cbeee}{box\+Filter}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abba70e493f86780d2850082607a94395}{calc\+Back\+Project}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ images, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}} channels, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} hist, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_float}{Mat\+Of\+Float}} ranges, double scale)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a407bd992b986d8e6d0ccf661a1058b57}{calc\+Hist}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ images, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}} channels, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} hist, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}} hist\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_float}{Mat\+Of\+Float}} ranges, boolean \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{accumulate}})
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6878eca2d6d70089c17a1c7b8125e544}{calc\+Hist}} (List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$ images, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}} channels, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} hist, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}} hist\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_float}{Mat\+Of\+Float}} ranges)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5b3dd3404f725b0d9c7a5fa249ffd855}{compare\+Hist}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} H1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} H2, int method)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0b9b82e8b2461a102788628c8b86d1a1}{contour\+Area}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} contour, boolean oriented)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9d6a5977b0691eb9736af8151e2bbc61}{contour\+Area}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} contour)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a03418d25b2a22395f42e32d869937f95}{convert\+Maps}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dstmap1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dstmap2, int dstmap1type, boolean nninterpolation)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab36cb67b988ea831009909fb126efc3d}{convert\+Maps}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dstmap1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dstmap2, int dstmap1type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aca40be72d91322b2caa2e37b5da190e6}{convex\+Hull}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}} hull, boolean clockwise)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aea7e7b3c039ba7d3c04629b3a9cd399d}{convex\+Hull}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}} hull)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a209ed56855c2b90701908839e25f773a}{convexity\+Defects}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} contour, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}} convexhull, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int4}{Mat\+Of\+Int4}} convexity\+Defects)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aeeb280b7ea42158d887ce0d82e6ea0e4}{copy\+Make\+Border}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int top, int bottom, int left, int right, int border\+Type, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} value)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9a788b12632bb2021d6fc4194c524364}{copy\+Make\+Border}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int top, int bottom, int left, int right, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa13f522ce6ccde35a54983d35640c3e1}{corner\+Eigen\+Vals\+And\+Vecs}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int block\+Size, int ksize, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2d6d62e47c79f1dea4f66b9bebbe7b35}{corner\+Eigen\+Vals\+And\+Vecs}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int block\+Size, int ksize)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aff9b8e4b52de80802161886bd074cdca}{corner\+Harris}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int block\+Size, int ksize, double k, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a86dc26104d7f6287e2f4eef9379542c4}{corner\+Harris}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int block\+Size, int ksize, double k)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9a5a2f96d413cc9f1ce919942a150a41}{corner\+Min\+Eigen\+Val}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int block\+Size, int ksize, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7a680b6cb84ba84e1a6bbc6bfc121374}{corner\+Min\+Eigen\+Val}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int block\+Size, int ksize)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa8d64df7e315470530c31aca691bf1d1}{corner\+Min\+Eigen\+Val}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int block\+Size)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a27d2a87eb126da8ffaf0ef12950a5b48}{corner\+Sub\+Pix}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} corners, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} win\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} zero\+Zone, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}} criteria)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8953a925c05f058b4b992831fea01eee}{create\+Hanning\+Window}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} win\+Size, int type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab8fb70fea379b4215a77122d698d860d}{cvt\+Color}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int code, int dst\+Cn)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac8a27791c4cc1d1739464acafa3efff6}{cvt\+Color}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int code)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7ed226f2562750987d756b129d3820b2}{dilate}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, int iterations, int border\+Type, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} border\+Value)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8f79b910d1d1066ca305b6d1fd86daf0}{dilate}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, int iterations)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a596d70c952e5431f7703dc4e17eccf94}{dilate}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2677a973693b8af87cf9c37e4e6bb55b}{distance\+Transform}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int distance\+Type, int mask\+Size)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5f09765bfd6488e72af786bedf84debb}{distance\+Transform\+With\+Labels}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} labels, int distance\+Type, int mask\+Size, int label\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac25a59a395516fc78f9f578605a29c1a}{distance\+Transform\+With\+Labels}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} labels, int distance\+Type, int mask\+Size)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aaf689993f59f9920d22624e2672e9bc1}{draw\+Contours}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$ contours, int contour\+Idx, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness, int line\+Type, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} hierarchy, int max\+Level, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} offset)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a36480a8bc172c736bb663d4e906a8195}{draw\+Contours}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$ contours, int contour\+Idx, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color, int thickness)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac89674f3f896a672c8ed20be07e83e0e}{draw\+Contours}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$ contours, int contour\+Idx, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} color)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a54ffba160b6fca43023f2d5f556e9b74}{equalize\+Hist}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_addf44b4eae2f6a52e93c1018cdb07ddc}{erode}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, int iterations, int border\+Type, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} border\+Value)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3fda166b23a9211a4c6831f15851cd28}{erode}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, int iterations)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a485bdd85e47f631bd9f2e29d203b4060}{erode}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{filter2D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, double delta, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a99d049df474881b0f663137cac0e83db}{filter2D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, double delta)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a957d2e1b7b47980406f42d1290385504}{filter2D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a60284da5baddfe0b44c6553177de8bf9}{find\+Contours}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$ contours, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} hierarchy, int mode, int method, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} offset)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a007342d8043f1610bb73d105949ab86c}{find\+Contours}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$ contours, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} hierarchy, int mode, int method)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rotated_rect}{Rotated\+Rect}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa1223b61730baf7b52760332c5cdd8f5}{fit\+Ellipse}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} points)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a78923d7431756fb4cb2046359b75607f}{fit\+Line}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} line, int dist\+Type, double param, double reps, double aeps)
\item 
static int \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af2c9b324bfce19842e0a1dbc6e97caf7}{flood\+Fill}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} seed\+Point, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} new\+Val, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} rect, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} lo\+Diff, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} up\+Diff, int flags)
\item 
static int \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a86974fce952ae2763066b15290d01be9}{flood\+Fill}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} seed\+Point, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} new\+Val)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a283e61c00d4e6ba9625264d8d7f5f8db}{get\+Affine\+Transform}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} dst)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_adaa73e104d926966ba7d5666c4458e51}{get\+Default\+New\+Camera\+Matrix}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} imgsize, boolean center\+Principal\+Point)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7299c13c7cc005dcd769dbf58c349b82}{get\+Default\+New\+Camera\+Matrix}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad7100f31c477bc17ad6c868f16822f2}{get\+Deriv\+Kernels}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kx, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} ky, int dx, int dy, int ksize, boolean normalize, int ktype)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aadd8e596cd6747ac2bf7cf2936f09058}{get\+Deriv\+Kernels}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kx, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} ky, int dx, int dy, int ksize)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a878eb2f5d4a0fa92115642d5f2cfcc1a}{get\+Gabor\+Kernel}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, double sigma, double theta, double lambd, double gamma, double psi, int ktype)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6a76e5878eee9211bfca7e7d63802cc1}{get\+Gabor\+Kernel}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, double sigma, double theta, double lambd, double gamma)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7f775ca4b4dd4c420a16a65ca28cbc58}{get\+Gaussian\+Kernel}} (int ksize, double sigma, int ktype)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a60b28f1c495e346912dd0808d267ba3f}{get\+Gaussian\+Kernel}} (int ksize, double sigma)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab3727363e269af640d5254f76e14ddb6}{get\+Perspective\+Transform}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa547e4fbdf1a4806a1fd35ebbfe2a117}{get\+Rect\+Sub\+Pix}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} patch\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} center, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} patch, int patch\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3fd684028b07b7ba5327cb890cca0bbd}{get\+Rect\+Sub\+Pix}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} patch\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} center, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} patch)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac336c5ce363b2561904027535a7edab6}{get\+Rotation\+Matrix2D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} center, double angle, double scale)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a91f9695453e02aa885270c0cb3cb7207}{get\+Structuring\+Element}} (int shape, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a4e25f50f644c596500ea7cbb7d8f72cf}{get\+Structuring\+Element}} (int shape, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} ksize)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a55ca9c014b3e7fcbda05ad5d9e5e2b3e}{good\+Features\+To\+Track}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} corners, int max\+Corners, double quality\+Level, double min\+Distance, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, int block\+Size, boolean use\+Harris\+Detector, double k)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1aae3383c84a2d787691a18c05962764}{good\+Features\+To\+Track}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} corners, int max\+Corners, double quality\+Level, double min\+Distance)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afdc316be7c75db609235d7f9aa24bdfa}{grab\+Cut}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} rect, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} bgd\+Model, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} fgd\+Model, int iter\+Count, int mode)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8be3ea0718f04a8b17bed9d0a46ba7cc}{grab\+Cut}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} rect, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} bgd\+Model, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} fgd\+Model, int iter\+Count)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae7ecce50c4e0db8881a8a59a02a3fdf3}{init\+Undistort\+Rectify\+Map}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} new\+Camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} size, int m1type, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map2)
\item 
static float \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a91465eaccc847b26a082809dcd6c35bf}{init\+Wide\+Angle\+Proj\+Map}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, int dest\+Image\+Width, int m1type, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map2, int proj\+Type, double alpha)
\item 
static float \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2e0a674f9382040bad9b7f245cdb1bbd}{init\+Wide\+Angle\+Proj\+Map}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} image\+Size, int dest\+Image\+Width, int m1type, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map2)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a44841cd68ca7d5aeba8b98f886a3f8c9}{integral}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} sum, int sdepth)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af1ddaebf0a329d81acc73b949d229c14}{integral}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} sum)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9df7bb343fe42a9a1fc27e46ec4c54fe}{integral2}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} sum, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} sqsum, int sdepth)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a568b82028d35989917fbd0eefb3aaee5}{integral2}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} sum, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} sqsum)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a4e6458cea7a26ba5d93f259aa4270553}{integral3}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} sum, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} sqsum, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tilted, int sdepth)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa4e01b9d9963a4f5be66b8a71c742094}{integral3}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} sum, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} sqsum, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} tilted)
\item 
static float \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a69e8aafe58e0ea526c3efca2a41542da}{intersect\+Convex\+Convex}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \+\_\+p1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \+\_\+p2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \+\_\+p12, boolean handle\+Nested)
\item 
static float \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_acd39a01ff6e0be8c297243ee0d006ab9}{intersect\+Convex\+Convex}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \+\_\+p1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \+\_\+p2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \+\_\+p12)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aacadce25fcade314666c72930c0af3d1}{invert\+Affine\+Transform}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} M, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} iM)
\item 
static boolean \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a776c38eea614512469ac8192d57b5755}{is\+Contour\+Convex}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} contour)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a615b8e00934e682b9f0fa511996b4434}{match\+Shapes}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} contour1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} contour2, int method, double parameter)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab7f64647bb4d0400664056af42b90063}{match\+Template}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} templ, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} result, int method)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}{median\+Blur}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ksize)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rotated_rect}{Rotated\+Rect}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a36e00300ec44ed202633c9c7e466f90a}{min\+Area\+Rect}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} points)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac3ca3753976cf3f969df4b25a3f5ef78}{min\+Enclosing\+Circle}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} points, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} center, float\mbox{[}$\,$\mbox{]} radius)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6739d6b48d3c77c9a2225f0f2b8c2de0}{moments}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} array, boolean binary\+Image)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c002c128b749bd96ce843ae73165e6e}{moments}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} array)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a72708dff026d005db5a9534c9b2b4aae}{morphology\+Ex}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int op, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, int iterations, int border\+Type, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} border\+Value)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aae5c49b2ab2f81167240972412b5413c}{morphology\+Ex}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int op, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, int iterations)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1acac72fef3b7b66641f4c2e9cd5e876}{morphology\+Ex}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int op, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernel)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7b3ed66ff7c6ceb76fb1293177964dd1}{phase\+Correlate}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} window)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af0784f3b7aa341ba480c44509319440c}{phase\+Correlate}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8f62667aea7153feaf585aff643a5826}{phase\+Correlate\+Res}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} window, double\mbox{[}$\,$\mbox{]} response)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1c576a2bdd5d4adfa3131049865be50e}{phase\+Correlate\+Res}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src2, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} window)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2cb96fabb468911c8a44b175091d77cd}{point\+Polygon\+Test}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} contour, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} pt, boolean measure\+Dist)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7cd6f2951d4243689ad0915162a14541}{pre\+Corner\+Detect}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ksize, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab624f1339b2cfe8cd1fb44f202184c16}{pre\+Corner\+Detect}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ksize)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9ecbfdf7bf014c1215841957f7e7b2ca}{pyr\+Down}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dstsize, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a44e5337193173eb9738b3bf1beb8af73}{pyr\+Down}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dstsize)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a717ca1f10b089cf6ec50dc0c634cf5e7}{pyr\+Down}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1e4e4c176ebc30a3f5ab6f242c30db4e}{pyr\+Mean\+Shift\+Filtering}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double sp, double sr, int max\+Level, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}} termcrit)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac61221bc09dbc9e8bdd92a9b3f1126b2}{pyr\+Mean\+Shift\+Filtering}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double sp, double sr)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa55d915e843c305139824579332e90e9}{pyr\+Up}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dstsize, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad1f5f14fec2da659a02267cc5399ab83}{pyr\+Up}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dstsize)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abd25266f8f94c20c8112899d52de4af6}{pyr\+Up}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}{remap}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map2, int interpolation, int border\+Mode, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} border\+Value)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2abe0c60d2f4707962a472e94c0841e0}{remap}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map1, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} map2, int interpolation)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae781b575f9f20dbefb20eb2bb9966ae2}{resize}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dsize, double fx, double fy, int interpolation)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae2819900a62b48a2d701f0c5ead64922}{resize}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dsize)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{sep\+Filter2D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernelX, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernelY, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, double delta, int border\+Type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abea9b14d3e482c71996b0af7ad20b384}{sep\+Filter2D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernelX, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernelY, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} anchor, double delta)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad20d4e66d9913829813d3a22f96d8c6e}{sep\+Filter2D}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, int ddepth, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernelX, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} kernelY)
\item 
static double \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a428d1896f05ae5e0eadbe9a1489e6368}{threshold}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, double thresh, double maxval, int type)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0733bf11be8125dfc28b6ff4da746927}{undistort}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} new\+Camera\+Matrix)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5763c06b8dcd1822d88a806d485ad0c7}{undistort}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af7bbf66c0f84809e3e83482f63e628f5}{undistort\+Points}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} P)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa6556f1cfb24b79075a9ab96d06a1fd2}{undistort\+Points}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} camera\+Matrix, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dist\+Coeffs)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}{warp\+Affine}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} M, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dsize, int flags, int border\+Mode, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} border\+Value)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a261169d40fb66824c5cb3e5f86df0799}{warp\+Affine}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} M, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dsize, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0fdebc53734476460d5fe9b2cb3b5154}{warp\+Affine}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} M, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dsize)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{warp\+Perspective}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} M, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dsize, int flags, int border\+Mode, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} border\+Value)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3608b9b4fab7fe199ebcfeed938d59f5}{warp\+Perspective}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} M, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dsize, int flags)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1c33b5777145642c0670124ea3a35b01}{warp\+Perspective}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} src, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} dst, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} M, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} dsize)
\item 
static void \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3d24a06a891561fbcf918cefee4f1977}{watershed}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} image, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} markers)
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static final int \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abf7d30bf7b45f87ff811c486d74a6e66}{C\+V\+\_\+\+B\+L\+U\+R\+\_\+\+N\+O\+\_\+\+S\+C\+A\+LE}} = 0
\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!accumulate@{accumulate}}
\index{accumulate@{accumulate}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{accumulate()}{accumulate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+accumulate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Adds an image to the accumulator.

The function adds {\ttfamily src} or some of its elements to {\ttfamily dst} \+:

{\itshape dst(x,y) $<$-\/ dst(x,y) + src(x,y) if mask(x,y) != 0}

The function supports multi-\/channel images. Each channel is processed independently.

The functions {\ttfamily accumulate$\ast$} can be used, for example, to collect statistics of a scene background viewed by a still camera and for the further foreground-\/background segmentation.


\begin{DoxyParams}{Parameters}
{\em src} & Input image as 1-\/ or 3-\/channel, 8-\/bit or 32-\/bit floating point. \\
\hline
{\em dst} & Accumulator image with the same number of channels as input image, 32-\/bit or 64-\/bit floating-\/point. \\
\hline
{\em mask} & Optional operation mask.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulate}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+accumulate} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a67077201750b8f44b2a8ce7483f58883}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a63cfc78fd4e08d233d1f36d4609081ce}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a63cfc78fd4e08d233d1f36d4609081ce}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!accumulate@{accumulate}}
\index{accumulate@{accumulate}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{accumulate()}{accumulate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+accumulate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Adds an image to the accumulator.

The function adds {\ttfamily src} or some of its elements to {\ttfamily dst} \+:

{\itshape dst(x,y) $<$-\/ dst(x,y) + src(x,y) if mask(x,y) != 0}

The function supports multi-\/channel images. Each channel is processed independently.

The functions {\ttfamily accumulate$\ast$} can be used, for example, to collect statistics of a scene background viewed by a still camera and for the further foreground-\/background segmentation.


\begin{DoxyParams}{Parameters}
{\em src} & Input image as 1-\/ or 3-\/channel, 8-\/bit or 32-\/bit floating point. \\
\hline
{\em dst} & Accumulator image with the same number of channels as input image, 32-\/bit or 64-\/bit floating-\/point.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulate}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+accumulate} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a67077201750b8f44b2a8ce7483f58883}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!accumulate\+Product@{accumulate\+Product}}
\index{accumulate\+Product@{accumulate\+Product}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{accumulate\+Product()}{accumulateProduct()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Product (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Adds the per-\/element product of two input images to the accumulator.

The function adds the product of two images or their selected regions to the accumulator {\ttfamily dst} \+:

{\itshape dst(x,y) $<$-\/ dst(x,y) + src1(x,y) $\ast$ src2(x,y) if mask(x,y) != 0}

The function supports multi-\/channel images. Each channel is processed independently.


\begin{DoxyParams}{Parameters}
{\em src1} & First input image, 1-\/ or 3-\/channel, 8-\/bit or 32-\/bit floating point. \\
\hline
{\em src2} & Second input image of the same type and the same size as {\ttfamily src1}. \\
\hline
{\em dst} & Accumulator with the same number of channels as input images, 32-\/bit or 64-\/bit floating-\/point. \\
\hline
{\em mask} & Optional operation mask.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulateproduct}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Product} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a67077201750b8f44b2a8ce7483f58883}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa913bcb064a1079140398a6e7501df14}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa913bcb064a1079140398a6e7501df14}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!accumulate\+Product@{accumulate\+Product}}
\index{accumulate\+Product@{accumulate\+Product}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{accumulate\+Product()}{accumulateProduct()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Product (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Adds the per-\/element product of two input images to the accumulator.

The function adds the product of two images or their selected regions to the accumulator {\ttfamily dst} \+:

{\itshape dst(x,y) $<$-\/ dst(x,y) + src1(x,y) $\ast$ src2(x,y) if mask(x,y) != 0}

The function supports multi-\/channel images. Each channel is processed independently.


\begin{DoxyParams}{Parameters}
{\em src1} & First input image, 1-\/ or 3-\/channel, 8-\/bit or 32-\/bit floating point. \\
\hline
{\em src2} & Second input image of the same type and the same size as {\ttfamily src1}. \\
\hline
{\em dst} & Accumulator with the same number of channels as input images, 32-\/bit or 64-\/bit floating-\/point.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulateproduct}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Product} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a67077201750b8f44b2a8ce7483f58883}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!accumulate\+Square@{accumulate\+Square}}
\index{accumulate\+Square@{accumulate\+Square}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{accumulate\+Square()}{accumulateSquare()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Square (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Adds the square of a source image to the accumulator.

The function adds the input image {\ttfamily src} or its selected region, raised to a power of 2, to the accumulator {\ttfamily dst} \+:

{\itshape dst(x,y) $<$-\/ dst(x,y) + src(x,y)$^\wedge$2 if mask(x,y) != 0}

The function supports multi-\/channel images. Each channel is processed independently.


\begin{DoxyParams}{Parameters}
{\em src} & Input image as 1-\/ or 3-\/channel, 8-\/bit or 32-\/bit floating point. \\
\hline
{\em dst} & Accumulator image with the same number of channels as input image, 32-\/bit or 64-\/bit floating-\/point. \\
\hline
{\em mask} & Optional operation mask.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulatesquare}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Square} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a67077201750b8f44b2a8ce7483f58883}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad364d805ad0822ebced2cfb163d6a095}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad364d805ad0822ebced2cfb163d6a095}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!accumulate\+Square@{accumulate\+Square}}
\index{accumulate\+Square@{accumulate\+Square}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{accumulate\+Square()}{accumulateSquare()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Square (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Adds the square of a source image to the accumulator.

The function adds the input image {\ttfamily src} or its selected region, raised to a power of 2, to the accumulator {\ttfamily dst} \+:

{\itshape dst(x,y) $<$-\/ dst(x,y) + src(x,y)$^\wedge$2 if mask(x,y) != 0}

The function supports multi-\/channel images. Each channel is processed independently.


\begin{DoxyParams}{Parameters}
{\em src} & Input image as 1-\/ or 3-\/channel, 8-\/bit or 32-\/bit floating point. \\
\hline
{\em dst} & Accumulator image with the same number of channels as input image, 32-\/bit or 64-\/bit floating-\/point.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulatesquare}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Square} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a67077201750b8f44b2a8ce7483f58883}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Weighted}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a67077201750b8f44b2a8ce7483f58883}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a67077201750b8f44b2a8ce7483f58883}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!accumulate\+Weighted@{accumulate\+Weighted}}
\index{accumulate\+Weighted@{accumulate\+Weighted}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{accumulate\+Weighted()}{accumulateWeighted()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Weighted (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{alpha,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Updates a running average.

The function calculates the weighted sum of the input image {\ttfamily src} and the accumulator {\ttfamily dst} so that {\ttfamily dst} becomes a running average of a frame sequence\+:

{\itshape dst(x,y) $<$-\/ (1-\/ alpha) $\ast$ dst(x,y) + alpha $\ast$ src(x,y) if mask(x,y) != 0}

That is, {\ttfamily alpha} regulates the update speed (how fast the accumulator \char`\"{}forgets\char`\"{} about earlier images). The function supports multi-\/channel images. Each channel is processed independently.


\begin{DoxyParams}{Parameters}
{\em src} & Input image as 1-\/ or 3-\/channel, 8-\/bit or 32-\/bit floating point. \\
\hline
{\em dst} & Accumulator image with the same number of channels as input image, 32-\/bit or 64-\/bit floating-\/point. \\
\hline
{\em alpha} & Weight of the input image. \\
\hline
{\em mask} & Optional operation mask.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulateweighted}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Weighted} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac68bfd1c13f6547a6db9d14a88c9fa53}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac68bfd1c13f6547a6db9d14a88c9fa53}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!accumulate\+Weighted@{accumulate\+Weighted}}
\index{accumulate\+Weighted@{accumulate\+Weighted}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{accumulate\+Weighted()}{accumulateWeighted()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Weighted (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{alpha }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Updates a running average.

The function calculates the weighted sum of the input image {\ttfamily src} and the accumulator {\ttfamily dst} so that {\ttfamily dst} becomes a running average of a frame sequence\+:

{\itshape dst(x,y) $<$-\/ (1-\/ alpha) $\ast$ dst(x,y) + alpha $\ast$ src(x,y) if mask(x,y) != 0}

That is, {\ttfamily alpha} regulates the update speed (how fast the accumulator \char`\"{}forgets\char`\"{} about earlier images). The function supports multi-\/channel images. Each channel is processed independently.


\begin{DoxyParams}{Parameters}
{\em src} & Input image as 1-\/ or 3-\/channel, 8-\/bit or 32-\/bit floating point. \\
\hline
{\em dst} & Accumulator image with the same number of channels as input image, 32-\/bit or 64-\/bit floating-\/point. \\
\hline
{\em alpha} & Weight of the input image.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#accumulateweighted}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+accumulate\+Weighted} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9258592f2447fc25785020eee8cc78f7}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1be426770d204691d4f181c5ed663f7a}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Product}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5de5a552dbd44bbc411de004bc11337b}{org.\+opencv.\+imgproc.\+Imgproc\+::accumulate\+Square}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1b26a0ff327de4e9e576eb2950794d19}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1b26a0ff327de4e9e576eb2950794d19}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!adaptive\+Bilateral\+Filter@{adaptive\+Bilateral\+Filter}}
\index{adaptive\+Bilateral\+Filter@{adaptive\+Bilateral\+Filter}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{adaptive\+Bilateral\+Filter()}{adaptiveBilateralFilter()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+adaptive\+Bilateral\+Filter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{double}]{sigma\+Space,  }\item[{double}]{max\+Sigma\+Color,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies the adaptive bilateral filter to an image.

A main part of our strategy will be to load each raw pixel once, and reuse it to calculate all pixels in the output (filtered) image that need this pixel value. The math of the filter is that of the usual bilateral filter, except that the sigma color is calculated in the neighborhood, and clamped by the optional input value.


\begin{DoxyParams}{Parameters}
{\em src} & The source image \\
\hline
{\em dst} & The destination image; will have the same size and the same type as src \\
\hline
{\em ksize} & The kernel size. This is the neighborhood where the local variance will be calculated, and where pixels will contribute (in a weighted manner). \\
\hline
{\em sigma\+Space} & Filter sigma in the coordinate space. Larger value of the parameter means that farther pixels will influence each other (as long as their colors are close enough; see sigma\+Color). Then d$>$0, it specifies the neighborhood size regardless of sigma\+Space, otherwise d is proportional to sigma\+Space. \\
\hline
{\em max\+Sigma\+Color} & Maximum allowed sigma color (will clamp the value calculated in the ksize neighborhood. Larger value of the parameter means that more dissimilar pixels will influence each other (as long as their colors are close enough; see sigma\+Color). Then d$>$0, it specifies the neighborhood size regardless of sigma\+Space, otherwise d is proportional to sigma\+Space. \\
\hline
{\em anchor} & a anchor \\
\hline
{\em border\+Type} & Pixel extrapolation method.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#adaptivebilateralfilter}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+adaptive\+Bilateral\+Filter} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa76bd5802e7865c91dcc13152fbd7f1a}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa76bd5802e7865c91dcc13152fbd7f1a}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!adaptive\+Bilateral\+Filter@{adaptive\+Bilateral\+Filter}}
\index{adaptive\+Bilateral\+Filter@{adaptive\+Bilateral\+Filter}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{adaptive\+Bilateral\+Filter()}{adaptiveBilateralFilter()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+adaptive\+Bilateral\+Filter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{double}]{sigma\+Space,  }\item[{double}]{max\+Sigma\+Color,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies the adaptive bilateral filter to an image.

A main part of our strategy will be to load each raw pixel once, and reuse it to calculate all pixels in the output (filtered) image that need this pixel value. The math of the filter is that of the usual bilateral filter, except that the sigma color is calculated in the neighborhood, and clamped by the optional input value.


\begin{DoxyParams}{Parameters}
{\em src} & The source image \\
\hline
{\em dst} & The destination image; will have the same size and the same type as src \\
\hline
{\em ksize} & The kernel size. This is the neighborhood where the local variance will be calculated, and where pixels will contribute (in a weighted manner). \\
\hline
{\em sigma\+Space} & Filter sigma in the coordinate space. Larger value of the parameter means that farther pixels will influence each other (as long as their colors are close enough; see sigma\+Color). Then d$>$0, it specifies the neighborhood size regardless of sigma\+Space, otherwise d is proportional to sigma\+Space. \\
\hline
{\em max\+Sigma\+Color} & Maximum allowed sigma color (will clamp the value calculated in the ksize neighborhood. Larger value of the parameter means that more dissimilar pixels will influence each other (as long as their colors are close enough; see sigma\+Color). Then d$>$0, it specifies the neighborhood size regardless of sigma\+Space, otherwise d is proportional to sigma\+Space. \\
\hline
{\em anchor} & a anchor\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#adaptivebilateralfilter}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+adaptive\+Bilateral\+Filter} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1ce86f78f836c6c711db8aaeae46bf09}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1ce86f78f836c6c711db8aaeae46bf09}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!adaptive\+Bilateral\+Filter@{adaptive\+Bilateral\+Filter}}
\index{adaptive\+Bilateral\+Filter@{adaptive\+Bilateral\+Filter}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{adaptive\+Bilateral\+Filter()}{adaptiveBilateralFilter()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+adaptive\+Bilateral\+Filter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{double}]{sigma\+Space }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies the adaptive bilateral filter to an image.

A main part of our strategy will be to load each raw pixel once, and reuse it to calculate all pixels in the output (filtered) image that need this pixel value. The math of the filter is that of the usual bilateral filter, except that the sigma color is calculated in the neighborhood, and clamped by the optional input value.


\begin{DoxyParams}{Parameters}
{\em src} & The source image \\
\hline
{\em dst} & The destination image; will have the same size and the same type as src \\
\hline
{\em ksize} & The kernel size. This is the neighborhood where the local variance will be calculated, and where pixels will contribute (in a weighted manner). \\
\hline
{\em sigma\+Space} & Filter sigma in the coordinate space. Larger value of the parameter means that farther pixels will influence each other (as long as their colors are close enough; see sigma\+Color). Then d$>$0, it specifies the neighborhood size regardless of sigma\+Space, otherwise d is proportional to sigma\+Space.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#adaptivebilateralfilter}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+adaptive\+Bilateral\+Filter} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8daf182545498116be4dabcfd9a0429e}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8daf182545498116be4dabcfd9a0429e}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!adaptive\+Threshold@{adaptive\+Threshold}}
\index{adaptive\+Threshold@{adaptive\+Threshold}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{adaptive\+Threshold()}{adaptiveThreshold()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+adaptive\+Threshold (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{max\+Value,  }\item[{int}]{adaptive\+Method,  }\item[{int}]{threshold\+Type,  }\item[{int}]{block\+Size,  }\item[{double}]{C }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies an adaptive threshold to an array.

The function transforms a grayscale image to a binary image according to the formulae\+:


\begin{DoxyItemize}
\item T\+H\+R\+E\+S\+H\+\_\+\+B\+I\+N\+A\+RY 
\end{DoxyItemize}

{\itshape dst(x,y) = max\+Value if src(x,y) \&gt T(x,y); 0 otherwise}


\begin{DoxyItemize}
\item T\+H\+R\+E\+S\+H\+\_\+\+B\+I\+N\+A\+R\+Y\+\_\+\+I\+NV 
\end{DoxyItemize}

{\itshape dst(x,y) = 0 if src(x,y) \&gt T(x,y); max\+Value otherwise}

where {\itshape T(x,y)} is a threshold calculated individually for each pixel.


\begin{DoxyItemize}
\item For the method {\ttfamily A\+D\+A\+P\+T\+I\+V\+E\+\_\+\+T\+H\+R\+E\+S\+H\+\_\+\+M\+E\+A\+N\+\_\+C}, the threshold value {\itshape T(x,y)} is a mean of the {\itshape block\+Size x block\+Size} neighborhood of {\itshape (x, y)} minus {\ttfamily C}. 
\item For the method {\ttfamily A\+D\+A\+P\+T\+I\+V\+E\+\_\+\+T\+H\+R\+E\+S\+H\+\_\+\+G\+A\+U\+S\+S\+I\+A\+N\+\_\+C}, the threshold value {\itshape T(x, y)} is a weighted sum (cross-\/correlation with a Gaussian window) of the {\itshape block\+Size x block\+Size} neighborhood of {\itshape (x, y)} minus {\ttfamily C}. The default sigma (standard deviation) is used for the specified {\ttfamily block\+Size}. See \char`\"{}get\+Gaussian\+Kernel\char`\"{}. 
\end{DoxyItemize}

The function can process the image in-\/place.


\begin{DoxyParams}{Parameters}
{\em src} & Source 8-\/bit single-\/channel image. \\
\hline
{\em dst} & Destination image of the same size and the same type as {\ttfamily src}. \\
\hline
{\em max\+Value} & Non-\/zero value assigned to the pixels for which the condition is satisfied. See the details below. \\
\hline
{\em adaptive\+Method} & Adaptive thresholding algorithm to use, {\ttfamily A\+D\+A\+P\+T\+I\+V\+E\+\_\+\+T\+H\+R\+E\+S\+H\+\_\+\+M\+E\+A\+N\+\_\+C} or {\ttfamily A\+D\+A\+P\+T\+I\+V\+E\+\_\+\+T\+H\+R\+E\+S\+H\+\_\+\+G\+A\+U\+S\+S\+I\+A\+N\+\_\+C}. See the details below. \\
\hline
{\em threshold\+Type} & Thresholding type that must be either {\ttfamily T\+H\+R\+E\+S\+H\+\_\+\+B\+I\+N\+A\+RY} or {\ttfamily T\+H\+R\+E\+S\+H\+\_\+\+B\+I\+N\+A\+R\+Y\+\_\+\+I\+NV}. \\
\hline
{\em block\+Size} & Size of a pixel neighborhood that is used to calculate a threshold value for the pixel\+: 3, 5, 7, and so on. \\
\hline
{\em C} & Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#adaptivethreshold}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+adaptive\+Threshold} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a428d1896f05ae5e0eadbe9a1489e6368}{org.\+opencv.\+imgproc.\+Imgproc\+::threshold}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{org.\+opencv.\+imgproc.\+Imgproc\+::blur}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af6bf03f1dd26e4ddc0a25996533d93e3}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af6bf03f1dd26e4ddc0a25996533d93e3}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!approx\+Poly\+DP@{approx\+Poly\+DP}}
\index{approx\+Poly\+DP@{approx\+Poly\+DP}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{approx\+Poly\+D\+P()}{approxPolyDP()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+approx\+Poly\+DP (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{curve,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{approx\+Curve,  }\item[{double}]{epsilon,  }\item[{boolean}]{closed }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Approximates a polygonal curve(s) with the specified precision.

The functions {\ttfamily approx\+Poly\+DP} approximate a curve or a polygon with another curve/polygon with less vertices so that the distance between them is less or equal to the specified precision. It uses the Douglas-\/\+Peucker algorithm \href{http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Ramer-\/\+Douglas-\/\+Peucker\+\_\+algorithm}

See \href{https://github.com/Itseez/opencv/tree/master/samples/cpp/contours2.cpp}{\tt https\+://github.\+com/\+Itseez/opencv/tree/master/samples/cpp/contours2.\+cpp} for the function usage model.


\begin{DoxyParams}{Parameters}
{\em curve} & Input vector of a 2D point stored in\+: 
\begin{DoxyItemize}
\item {\ttfamily std.\+vector} or {\ttfamily Mat} (C++ interface) 
\item {\ttfamily Nx2} numpy array (Python interface) 
\item {\ttfamily Cv\+Seq} or {\ttfamily  }Cv\+Mat" (C interface) 
\end{DoxyItemize}\\
\hline
{\em approx\+Curve} & Result of the approximation. The type should match the type of the input curve. In case of C interface the approximated curve is stored in the memory storage and pointer to it is returned. \\
\hline
{\em epsilon} & Parameter specifying the approximation accuracy. This is the maximum distance between the original curve and its approximation. \\
\hline
{\em closed} & If true, the approximated curve is closed (its first and last vertices are connected). Otherwise, it is not closed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#approxpolydp}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+approx\+Poly\+DP} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7e92ef5f2b2d486e256ee5e813de19c6}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7e92ef5f2b2d486e256ee5e813de19c6}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!arc\+Length@{arc\+Length}}
\index{arc\+Length@{arc\+Length}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{arc\+Length()}{arcLength()}}
{\footnotesize\ttfamily static double org.\+opencv.\+imgproc.\+Imgproc.\+arc\+Length (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{curve,  }\item[{boolean}]{closed }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a contour perimeter or a curve length.

The function computes a curve length or a closed contour perimeter.


\begin{DoxyParams}{Parameters}
{\em curve} & Input vector of 2D points, stored in {\ttfamily std.\+vector} or {\ttfamily Mat}. \\
\hline
{\em closed} & Flag indicating whether the curve is closed or not.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#arclength}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+arc\+Length} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!bilateral\+Filter@{bilateral\+Filter}}
\index{bilateral\+Filter@{bilateral\+Filter}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{bilateral\+Filter()}{bilateralFilter()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+bilateral\+Filter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{d,  }\item[{double}]{sigma\+Color,  }\item[{double}]{sigma\+Space,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies the bilateral filter to an image.

The function applies bilateral filtering to the input image, as described in \href{http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html}{\tt http\+://www.\+dai.\+ed.\+ac.\+uk/\+C\+Vonline/\+L\+O\+C\+A\+L\+\_\+\+C\+O\+P\+I\+E\+S/\+M\+A\+N\+D\+U\+C\+H\+I1/\+Bilateral\+\_\+\+Filtering.\+html} {\ttfamily bilateral\+Filter} can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters.


\begin{DoxyItemize}
\item Sigma values$\ast$\+: For simplicity, you can set the 2 sigma values to be the same. If they are small ($<$ 10), the filter will not have much effect, whereas if they are large ($>$ 150), they will have a very strong effect, making the image look \char`\"{}cartoonish\char`\"{}. 
\item Filter size$\ast$\+: Large filters (d $>$ 5) are very slow, so it is recommended to use d=5 for real-\/time applications, and perhaps d=9 for offline applications that need heavy noise filtering. 
\end{DoxyItemize}

This filter does not work inplace.


\begin{DoxyParams}{Parameters}
{\em src} & Source 8-\/bit or floating-\/point, 1-\/channel or 3-\/channel image. \\
\hline
{\em dst} & Destination image of the same size and type as {\ttfamily src}. \\
\hline
{\em d} & Diameter of each pixel neighborhood that is used during filtering. If it is non-\/positive, it is computed from {\ttfamily sigma\+Space}. \\
\hline
{\em sigma\+Color} & Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see {\ttfamily sigma\+Space}) will be mixed together, resulting in larger areas of semi-\/equal color. \\
\hline
{\em sigma\+Space} & Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see {\ttfamily sigma\+Color}). When {\ttfamily d$>$0}, it specifies the neighborhood size regardless of {\ttfamily sigma\+Space}. Otherwise, {\ttfamily d} is proportional to {\ttfamily sigma\+Space}. \\
\hline
{\em border\+Type} & a border\+Type\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#bilateralfilter}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+bilateral\+Filter} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7cba1f76aed036501535e765c84a2863}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7cba1f76aed036501535e765c84a2863}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!bilateral\+Filter@{bilateral\+Filter}}
\index{bilateral\+Filter@{bilateral\+Filter}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{bilateral\+Filter()}{bilateralFilter()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+bilateral\+Filter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{d,  }\item[{double}]{sigma\+Color,  }\item[{double}]{sigma\+Space }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies the bilateral filter to an image.

The function applies bilateral filtering to the input image, as described in \href{http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html}{\tt http\+://www.\+dai.\+ed.\+ac.\+uk/\+C\+Vonline/\+L\+O\+C\+A\+L\+\_\+\+C\+O\+P\+I\+E\+S/\+M\+A\+N\+D\+U\+C\+H\+I1/\+Bilateral\+\_\+\+Filtering.\+html} {\ttfamily bilateral\+Filter} can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters.


\begin{DoxyItemize}
\item Sigma values$\ast$\+: For simplicity, you can set the 2 sigma values to be the same. If they are small ($<$ 10), the filter will not have much effect, whereas if they are large ($>$ 150), they will have a very strong effect, making the image look \char`\"{}cartoonish\char`\"{}. 
\item Filter size$\ast$\+: Large filters (d $>$ 5) are very slow, so it is recommended to use d=5 for real-\/time applications, and perhaps d=9 for offline applications that need heavy noise filtering. 
\end{DoxyItemize}

This filter does not work inplace.


\begin{DoxyParams}{Parameters}
{\em src} & Source 8-\/bit or floating-\/point, 1-\/channel or 3-\/channel image. \\
\hline
{\em dst} & Destination image of the same size and type as {\ttfamily src}. \\
\hline
{\em d} & Diameter of each pixel neighborhood that is used during filtering. If it is non-\/positive, it is computed from {\ttfamily sigma\+Space}. \\
\hline
{\em sigma\+Color} & Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see {\ttfamily sigma\+Space}) will be mixed together, resulting in larger areas of semi-\/equal color. \\
\hline
{\em sigma\+Space} & Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see {\ttfamily sigma\+Color}). When {\ttfamily d$>$0}, it specifies the neighborhood size regardless of {\ttfamily sigma\+Space}. Otherwise, {\ttfamily d} is proportional to {\ttfamily sigma\+Space}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#bilateralfilter}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+bilateral\+Filter} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!blur@{blur}}
\index{blur@{blur}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{blur()}{blur()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+blur (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image using the normalized box filter.

The function smoothes an image using the kernel\+:

{\itshape K = 1/(ksize.\+width$\ast$ksize.height) 1 1 1 $\ast$s 1 1 1 1 1 $\ast$s 1 1.................. 1 1 1 $\ast$s 1 1 }

The call {\ttfamily blur(src, dst, ksize, anchor, border\+Type)} is equivalent to {\ttfamily box\+Filter(src, dst, src.\+type(), anchor, true, border\+Type)}.


\begin{DoxyParams}{Parameters}
{\em src} & input image; it can have any number of channels, which are processed independently, but the depth should be {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F} or {\ttfamily C\+V\+\_\+64F}. \\
\hline
{\em dst} & output image of the same size and type as {\ttfamily src}. \\
\hline
{\em ksize} & blurring kernel size. \\
\hline
{\em anchor} & anchor point; default value {\ttfamily Point(-\/1,-\/1)} means that the anchor is at the kernel center. \\
\hline
{\em border\+Type} & border mode used to extrapolate pixels outside of the image.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#blur}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+blur} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}{org.\+opencv.\+imgproc.\+Imgproc\+::box\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}{org.\+opencv.\+imgproc.\+Imgproc\+::bilateral\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}{org.\+opencv.\+imgproc.\+Imgproc\+::median\+Blur}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0fe51807c2759c41bcb5e7f1d94a7653}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0fe51807c2759c41bcb5e7f1d94a7653}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!blur@{blur}}
\index{blur@{blur}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{blur()}{blur()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+blur (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image using the normalized box filter.

The function smoothes an image using the kernel\+:

{\itshape K = 1/(ksize.\+width$\ast$ksize.height) 1 1 1 $\ast$s 1 1 1 1 1 $\ast$s 1 1.................. 1 1 1 $\ast$s 1 1 }

The call {\ttfamily blur(src, dst, ksize, anchor, border\+Type)} is equivalent to {\ttfamily box\+Filter(src, dst, src.\+type(), anchor, true, border\+Type)}.


\begin{DoxyParams}{Parameters}
{\em src} & input image; it can have any number of channels, which are processed independently, but the depth should be {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F} or {\ttfamily C\+V\+\_\+64F}. \\
\hline
{\em dst} & output image of the same size and type as {\ttfamily src}. \\
\hline
{\em ksize} & blurring kernel size. \\
\hline
{\em anchor} & anchor point; default value {\ttfamily Point(-\/1,-\/1)} means that the anchor is at the kernel center.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#blur}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+blur} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}{org.\+opencv.\+imgproc.\+Imgproc\+::box\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}{org.\+opencv.\+imgproc.\+Imgproc\+::bilateral\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}{org.\+opencv.\+imgproc.\+Imgproc\+::median\+Blur}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad6e54f4b433f175352dedaef88474de3}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad6e54f4b433f175352dedaef88474de3}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!blur@{blur}}
\index{blur@{blur}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{blur()}{blur()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+blur (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image using the normalized box filter.

The function smoothes an image using the kernel\+:

{\itshape K = 1/(ksize.\+width$\ast$ksize.height) 1 1 1 $\ast$s 1 1 1 1 1 $\ast$s 1 1.................. 1 1 1 $\ast$s 1 1 }

The call {\ttfamily blur(src, dst, ksize, anchor, border\+Type)} is equivalent to {\ttfamily box\+Filter(src, dst, src.\+type(), anchor, true, border\+Type)}.


\begin{DoxyParams}{Parameters}
{\em src} & input image; it can have any number of channels, which are processed independently, but the depth should be {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F} or {\ttfamily C\+V\+\_\+64F}. \\
\hline
{\em dst} & output image of the same size and type as {\ttfamily src}. \\
\hline
{\em ksize} & blurring kernel size.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#blur}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+blur} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}{org.\+opencv.\+imgproc.\+Imgproc\+::box\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}{org.\+opencv.\+imgproc.\+Imgproc\+::bilateral\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}{org.\+opencv.\+imgproc.\+Imgproc\+::median\+Blur}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0bd258d65b0db015ac1106dea7126e9d}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0bd258d65b0db015ac1106dea7126e9d}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!border\+Interpolate@{border\+Interpolate}}
\index{border\+Interpolate@{border\+Interpolate}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{border\+Interpolate()}{borderInterpolate()}}
{\footnotesize\ttfamily static int org.\+opencv.\+imgproc.\+Imgproc.\+border\+Interpolate (\begin{DoxyParamCaption}\item[{int}]{p,  }\item[{int}]{len,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes the source location of an extrapolated pixel.

The function computes and returns the coordinate of a donor pixel corresponding to the specified extrapolated pixel when using the specified extrapolation border mode. For example, if you use {\ttfamily B\+O\+R\+D\+E\+R\+\_\+\+W\+R\+AP} mode in the horizontal direction, {\ttfamily B\+O\+R\+D\+E\+R\+\_\+\+R\+E\+F\+L\+E\+C\+T\+\_\+101} in the vertical direction and want to compute value of the \char`\"{}virtual\char`\"{} pixel {\ttfamily Point(-\/5, 100)} in a floating-\/point image {\ttfamily img}, it looks like\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily float val = img.\+at$<$float$>$(border\+Interpolate(100, img.\+rows, B\+O\+R\+D\+E\+R\+\_\+\+R\+E\+F\+L\+E\+C\+T\+\_\+101),}

{\ttfamily }

{\ttfamily }

{\ttfamily border\+Interpolate(-\/5, img.\+cols, B\+O\+R\+D\+E\+R\+\_\+\+W\+R\+AP));}

{\ttfamily }

{\ttfamily }

{\ttfamily Normally, the function is not called directly. It is used inside }

\char`\"{}\+Filter\+Engine\char`\"{} and \char`\"{}copy\+Make\+Border\char`\"{} to compute tables for quick extrapolation.


\begin{DoxyParams}{Parameters}
{\em p} & 0-\/based coordinate of the extrapolated pixel along one of the axes, likely $<$0 or $>$= {\ttfamily len}. \\
\hline
{\em len} & Length of the array along the corresponding axis. \\
\hline
{\em border\+Type} & Border type, one of the {\ttfamily B\+O\+R\+D\+E\+R\+\_\+$\ast$}, except for {\ttfamily B\+O\+R\+D\+E\+R\+\_\+\+T\+R\+A\+N\+S\+P\+A\+R\+E\+NT} and {\ttfamily B\+O\+R\+D\+E\+R\+\_\+\+I\+S\+O\+L\+A\+T\+ED}. When {\ttfamily border\+Type==B\+O\+R\+D\+E\+R\+\_\+\+C\+O\+N\+S\+T\+A\+NT}, the function always returns -\/1, regardless of {\ttfamily p} and {\ttfamily len}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#borderinterpolate}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+border\+Interpolate} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aeeb280b7ea42158d887ce0d82e6ea0e4}{org.\+opencv.\+imgproc.\+Imgproc\+::copy\+Make\+Border}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_adf01c1b9e7cf458ac7ed330da5974503}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_adf01c1b9e7cf458ac7ed330da5974503}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!bounding\+Rect@{bounding\+Rect}}
\index{bounding\+Rect@{bounding\+Rect}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{bounding\+Rect()}{boundingRect()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} org.\+opencv.\+imgproc.\+Imgproc.\+bounding\+Rect (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}}}]{points }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the up-\/right bounding rectangle of a point set.

The function calculates and returns the minimal up-\/right bounding rectangle for the specified point set.


\begin{DoxyParams}{Parameters}
{\em points} & Input 2D point set, stored in {\ttfamily std.\+vector} or {\ttfamily Mat}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#boundingrect}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+bounding\+Rect} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!box\+Filter@{box\+Filter}}
\index{box\+Filter@{box\+Filter}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{box\+Filter()}{boxFilter()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+box\+Filter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{boolean}]{normalize,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image using the box filter.

The function smoothes an image using the kernel\+:

{\itshape K = alpha 1 1 1 $\ast$s 1 1 1 1 1 $\ast$s 1 1.................. 1 1 1 $\ast$s 1 1 }

where

{\itshape alpha = 1/(ksize.\+width$\ast$ksize.height) when normalize=true; 1 otherwise}

Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-\/size windows, use \char`\"{}integral\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and type as {\ttfamily src}. \\
\hline
{\em ddepth} & the output image depth (-\/1 to use {\ttfamily src.\+depth()}). \\
\hline
{\em ksize} & blurring kernel size. \\
\hline
{\em anchor} & anchor point; default value {\ttfamily Point(-\/1,-\/1)} means that the anchor is at the kernel center. \\
\hline
{\em normalize} & flag, specifying whether the kernel is normalized by its area or not. \\
\hline
{\em border\+Type} & border mode used to extrapolate pixels outside of the image.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#boxfilter}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+box\+Filter} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}{org.\+opencv.\+imgproc.\+Imgproc\+::median\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a44841cd68ca7d5aeba8b98f886a3f8c9}{org.\+opencv.\+imgproc.\+Imgproc\+::integral}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}{org.\+opencv.\+imgproc.\+Imgproc\+::bilateral\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{org.\+opencv.\+imgproc.\+Imgproc\+::blur}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a064f2f5351affaec5ad2c3b88c957faa}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a064f2f5351affaec5ad2c3b88c957faa}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!box\+Filter@{box\+Filter}}
\index{box\+Filter@{box\+Filter}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{box\+Filter()}{boxFilter()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+box\+Filter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{boolean}]{normalize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image using the box filter.

The function smoothes an image using the kernel\+:

{\itshape K = alpha 1 1 1 $\ast$s 1 1 1 1 1 $\ast$s 1 1.................. 1 1 1 $\ast$s 1 1 }

where

{\itshape alpha = 1/(ksize.\+width$\ast$ksize.height) when normalize=true; 1 otherwise}

Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-\/size windows, use \char`\"{}integral\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and type as {\ttfamily src}. \\
\hline
{\em ddepth} & the output image depth (-\/1 to use {\ttfamily src.\+depth()}). \\
\hline
{\em ksize} & blurring kernel size. \\
\hline
{\em anchor} & anchor point; default value {\ttfamily Point(-\/1,-\/1)} means that the anchor is at the kernel center. \\
\hline
{\em normalize} & flag, specifying whether the kernel is normalized by its area or not.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#boxfilter}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+box\+Filter} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}{org.\+opencv.\+imgproc.\+Imgproc\+::median\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a44841cd68ca7d5aeba8b98f886a3f8c9}{org.\+opencv.\+imgproc.\+Imgproc\+::integral}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}{org.\+opencv.\+imgproc.\+Imgproc\+::bilateral\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{org.\+opencv.\+imgproc.\+Imgproc\+::blur}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0e852635eaf9272b1ec800779c4cbeee}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0e852635eaf9272b1ec800779c4cbeee}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!box\+Filter@{box\+Filter}}
\index{box\+Filter@{box\+Filter}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{box\+Filter()}{boxFilter()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+box\+Filter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image using the box filter.

The function smoothes an image using the kernel\+:

{\itshape K = alpha 1 1 1 $\ast$s 1 1 1 1 1 $\ast$s 1 1.................. 1 1 1 $\ast$s 1 1 }

where

{\itshape alpha = 1/(ksize.\+width$\ast$ksize.height) when normalize=true; 1 otherwise}

Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-\/size windows, use \char`\"{}integral\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and type as {\ttfamily src}. \\
\hline
{\em ddepth} & the output image depth (-\/1 to use {\ttfamily src.\+depth()}). \\
\hline
{\em ksize} & blurring kernel size.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#boxfilter}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+box\+Filter} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}{org.\+opencv.\+imgproc.\+Imgproc\+::median\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a44841cd68ca7d5aeba8b98f886a3f8c9}{org.\+opencv.\+imgproc.\+Imgproc\+::integral}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}{org.\+opencv.\+imgproc.\+Imgproc\+::bilateral\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{org.\+opencv.\+imgproc.\+Imgproc\+::blur}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abba70e493f86780d2850082607a94395}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abba70e493f86780d2850082607a94395}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!calc\+Back\+Project@{calc\+Back\+Project}}
\index{calc\+Back\+Project@{calc\+Back\+Project}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{calc\+Back\+Project()}{calcBackProject()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+calc\+Back\+Project (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{images,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}}}]{channels,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{hist,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_float}{Mat\+Of\+Float}}}]{ranges,  }\item[{double}]{scale }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the back projection of a histogram.

The functions {\ttfamily calc\+Back\+Project} calculate the back project of the histogram. That is, similarly to {\ttfamily calc\+Hist}, at each location {\ttfamily (x, y)} the function collects the values from the selected channels in the input images and finds the corresponding histogram bin. But instead of incrementing it, the function reads the bin value, scales it by {\ttfamily scale}, and stores in {\ttfamily back\+Project(x,y)}. In terms of statistics, the function computes probability of each element value in respect with the empirical probability distribution represented by the histogram. See how, for example, you can find and track a bright-\/colored object in a scene\+:


\begin{DoxyItemize}
\item Before tracking, show the object to the camera so that it covers almost the whole frame. Calculate a hue histogram. The histogram may have strong maximums, corresponding to the dominant colors in the object. 
\item When tracking, calculate a back projection of a hue plane of each input video frame using that pre-\/computed histogram. Threshold the back projection to suppress weak colors. It may also make sense to suppress pixels with non-\/sufficient color saturation and too dark or too bright pixels. 
\item Find connected components in the resulting picture and choose, for example, the largest component. 
\end{DoxyItemize}

This is an approximate algorithm of the \char`\"{}\+Cam\+Shift\char`\"{} color object tracker.


\begin{DoxyParams}{Parameters}
{\em images} & Source arrays. They all should have the same depth, {\ttfamily C\+V\+\_\+8U} or {\ttfamily C\+V\+\_\+32F}, and the same size. Each of them can have an arbitrary number of channels. \\
\hline
{\em channels} & The list of channels used to compute the back projection. The number of channels must match the histogram dimensionality. The first array channels are numerated from 0 to {\ttfamily images\mbox{[}0\mbox{]}.channels()-\/1}, the second array channels are counted from {\ttfamily images\mbox{[}0\mbox{]}.channels()} to {\ttfamily images\mbox{[}0\mbox{]}.channels() + images\mbox{[}1\mbox{]}.channels()-\/1}, and so on. \\
\hline
{\em hist} & Input histogram that can be dense or sparse. \\
\hline
{\em dst} & a dst \\
\hline
{\em ranges} & Array of arrays of the histogram bin boundaries in each dimension. See \char`\"{}calc\+Hist\char`\"{}. \\
\hline
{\em scale} & Optional scale factor for the output back projection.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/histograms.html#calcbackproject}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+calc\+Back\+Project} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a407bd992b986d8e6d0ccf661a1058b57}{org.\+opencv.\+imgproc.\+Imgproc\+::calc\+Hist}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a407bd992b986d8e6d0ccf661a1058b57}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a407bd992b986d8e6d0ccf661a1058b57}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!calc\+Hist@{calc\+Hist}}
\index{calc\+Hist@{calc\+Hist}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{calc\+Hist()}{calcHist()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+calc\+Hist (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{images,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}}}]{channels,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{hist,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}}}]{hist\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_float}{Mat\+Of\+Float}}}]{ranges,  }\item[{boolean}]{accumulate }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a histogram of a set of arrays.

The functions {\ttfamily calc\+Hist} calculate the histogram of one or more arrays. The elements of a tuple used to increment a histogram bin are taken from the correspondinginput arrays at the same location. The sample below shows how to compute a 2D Hue-\/\+Saturation histogram for a color image. {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$cv.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$highgui.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily using namespace cv;}

{\ttfamily }

{\ttfamily }

{\ttfamily int main(int argc, char argv)}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat src, hsv;}

{\ttfamily }

{\ttfamily }

{\ttfamily if(argc != 2 $\vert$$\vert$ !(src=imread(argv\mbox{[}1\mbox{]}, 1)).data)}

{\ttfamily }

{\ttfamily }

{\ttfamily return -\/1;}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(src, hsv, C\+V\+\_\+\+B\+G\+R2\+H\+S\+V);}

{\ttfamily }

{\ttfamily }

{\ttfamily // Quantize the hue to 30 levels}

{\ttfamily }

{\ttfamily }

{\ttfamily // and the saturation to 32 levels}

{\ttfamily }

{\ttfamily }

{\ttfamily int hbins = 30, sbins = 32;}

{\ttfamily }

{\ttfamily }

{\ttfamily int hist\+Size\mbox{[}\mbox{]} = \{hbins, sbins\};}

{\ttfamily }

{\ttfamily }

{\ttfamily // hue varies from 0 to 179, see cvt\+Color}

{\ttfamily }

{\ttfamily }

{\ttfamily float hranges\mbox{[}\mbox{]} = \{ 0, 180 \};}

{\ttfamily }

{\ttfamily }

{\ttfamily // saturation varies from 0 (black-\/gray-\/white) to}

{\ttfamily }

{\ttfamily }

{\ttfamily // 255 (pure spectrum color)}

{\ttfamily }

{\ttfamily }

{\ttfamily float sranges\mbox{[}\mbox{]} = \{ 0, 256 \};}

{\ttfamily }

{\ttfamily }

{\ttfamily const float$\ast$ ranges\mbox{[}\mbox{]} = \{ hranges, sranges \};}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat\+ND hist;}

{\ttfamily }

{\ttfamily }

{\ttfamily // we compute the histogram from the 0-\/th and 1-\/st channels}

{\ttfamily }

{\ttfamily }

{\ttfamily int channels\mbox{[}\mbox{]} = \{0, 1\};}

{\ttfamily }

{\ttfamily }

{\ttfamily calc\+Hist(\&hsv, 1, channels, Mat(), // do not use mask}

{\ttfamily }

{\ttfamily }

{\ttfamily hist, 2, hist\+Size, ranges,}

{\ttfamily }

{\ttfamily }

{\ttfamily true, // the histogram is uniform}

{\ttfamily }

{\ttfamily }

{\ttfamily false);}

{\ttfamily }

{\ttfamily }

{\ttfamily double max\+Val=0;}

{\ttfamily }

{\ttfamily }

{\ttfamily min\+Max\+Loc(hist, 0, \&max\+Val, 0, 0);}

{\ttfamily }

{\ttfamily }

{\ttfamily int scale = 10;}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat hist\+Img = Mat.\+zeros(sbins$\ast$scale, hbins$\ast$10, C\+V\+\_\+8\+U\+C3);}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int h = 0; h $<$ hbins; h++)}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int s = 0; s $<$ sbins; s++)}

{\ttfamily }

{\ttfamily }

{\ttfamily float bin\+Val = hist.\+at$<$float$>$(h, s);}

{\ttfamily }

{\ttfamily }

{\ttfamily int intensity = cv\+Round(bin\+Val$\ast$255/max\+Val);}

{\ttfamily }

{\ttfamily }

{\ttfamily rectangle(hist\+Img, Point(h$\ast$scale, s$\ast$scale),}

{\ttfamily }

{\ttfamily }

{\ttfamily Point((h+1)$\ast$scale -\/ 1, (s+1)$\ast$scale -\/ 1),}

{\ttfamily }

{\ttfamily }

{\ttfamily Scalar.\+all(intensity),}

{\ttfamily }

{\ttfamily }

{\ttfamily C\+V\+\_\+\+F\+I\+L\+L\+ED);}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Source\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Source\char`\"{}, src);}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+H-\/\+S Histogram\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+H-\/\+S Histogram\char`\"{}, hist\+Img);}

{\ttfamily }

{\ttfamily }

{\ttfamily wait\+Key();}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: }


\begin{DoxyItemize}
\item An example for creating histograms of an image can be found at opencv\+\_\+source\+\_\+code/samples/cpp/demhist.\+cpp 
\item (Python) An example for creating color histograms can be found at opencv\+\_\+source/samples/python2/color\+\_\+histogram.\+py 
\item (Python) An example illustrating R\+GB and grayscale histogram plotting can be found at opencv\+\_\+source/samples/python2/hist.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em images} & Source arrays. They all should have the same depth, {\ttfamily C\+V\+\_\+8U} or {\ttfamily C\+V\+\_\+32F}, and the same size. Each of them can have an arbitrary number of channels. \\
\hline
{\em channels} & List of the {\ttfamily dims} channels used to compute the histogram. The first array channels are numerated from 0 to {\ttfamily images\mbox{[}0\mbox{]}.channels()-\/1}, the second array channels are counted from {\ttfamily images\mbox{[}0\mbox{]}.channels()} to {\ttfamily images\mbox{[}0\mbox{]}.channels() + images\mbox{[}1\mbox{]}.channels()-\/1}, and so on. \\
\hline
{\em mask} & Optional mask. If the matrix is not empty, it must be an 8-\/bit array of the same size as {\ttfamily images\mbox{[}i\mbox{]}}. The non-\/zero mask elements mark the array elements counted in the histogram. \\
\hline
{\em hist} & Output histogram, which is a dense or sparse {\ttfamily dims} -\/dimensional array. \\
\hline
{\em hist\+Size} & Array of histogram sizes in each dimension. \\
\hline
{\em ranges} & Array of the {\ttfamily dims} arrays of the histogram bin boundaries in each dimension. When the histogram is uniform ({\ttfamily uniform} =true), then for each dimension {\ttfamily i} it is enough to specify the lower (inclusive) boundary {\itshape L\+\_\+0} of the 0-\/th histogram bin and the upper (exclusive) boundary {\itshape U\+\_\+(hist\+Size\mbox{[}i\mbox{]}-\/1)} for the last histogram bin {\ttfamily hist\+Size\mbox{[}i\mbox{]}-\/1}. That is, in case of a uniform histogram each of {\ttfamily ranges\mbox{[}i\mbox{]}} is an array of 2 elements. When the histogram is not uniform ({\ttfamily uniform=false}), then each of {\ttfamily ranges\mbox{[}i\mbox{]}} contains {\ttfamily hist\+Size\mbox{[}i\mbox{]}+1} elements\+: {\itshape L\+\_\+0, U\+\_\+0=L\+\_\+1, U\+\_\+1=L\+\_\+2,..., U\+\_\+(hist\+Size\mbox{[}i\mbox{]}-\/2)=L\+\_\+(hist\+Size\mbox{[}i\mbox{]}-\/1), U\+\_\+(hist\+Size\mbox{[}i\mbox{]}-\/1)}. The array elements, that are not between {\itshape L\+\_\+0} and {\itshape U\+\_\+(hist\+Size\mbox{[}i\mbox{]}-\/1)}, are not counted in the histogram. \\
\hline
{\em accumulate} & Accumulation flag. If it is set, the histogram is not cleared in the beginning when it is allocated. This feature enables you to compute a single histogram from several sets of arrays, or to update the histogram in time.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/histograms.html#calchist}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+calc\+Hist} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6878eca2d6d70089c17a1c7b8125e544}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6878eca2d6d70089c17a1c7b8125e544}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!calc\+Hist@{calc\+Hist}}
\index{calc\+Hist@{calc\+Hist}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{calc\+Hist()}{calcHist()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+calc\+Hist (\begin{DoxyParamCaption}\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} $>$}]{images,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}}}]{channels,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{hist,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}}}]{hist\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_float}{Mat\+Of\+Float}}}]{ranges }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a histogram of a set of arrays.

The functions {\ttfamily calc\+Hist} calculate the histogram of one or more arrays. The elements of a tuple used to increment a histogram bin are taken from the correspondinginput arrays at the same location. The sample below shows how to compute a 2D Hue-\/\+Saturation histogram for a color image. {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$cv.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$highgui.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily using namespace cv;}

{\ttfamily }

{\ttfamily }

{\ttfamily int main(int argc, char argv)}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat src, hsv;}

{\ttfamily }

{\ttfamily }

{\ttfamily if(argc != 2 $\vert$$\vert$ !(src=imread(argv\mbox{[}1\mbox{]}, 1)).data)}

{\ttfamily }

{\ttfamily }

{\ttfamily return -\/1;}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(src, hsv, C\+V\+\_\+\+B\+G\+R2\+H\+S\+V);}

{\ttfamily }

{\ttfamily }

{\ttfamily // Quantize the hue to 30 levels}

{\ttfamily }

{\ttfamily }

{\ttfamily // and the saturation to 32 levels}

{\ttfamily }

{\ttfamily }

{\ttfamily int hbins = 30, sbins = 32;}

{\ttfamily }

{\ttfamily }

{\ttfamily int hist\+Size\mbox{[}\mbox{]} = \{hbins, sbins\};}

{\ttfamily }

{\ttfamily }

{\ttfamily // hue varies from 0 to 179, see cvt\+Color}

{\ttfamily }

{\ttfamily }

{\ttfamily float hranges\mbox{[}\mbox{]} = \{ 0, 180 \};}

{\ttfamily }

{\ttfamily }

{\ttfamily // saturation varies from 0 (black-\/gray-\/white) to}

{\ttfamily }

{\ttfamily }

{\ttfamily // 255 (pure spectrum color)}

{\ttfamily }

{\ttfamily }

{\ttfamily float sranges\mbox{[}\mbox{]} = \{ 0, 256 \};}

{\ttfamily }

{\ttfamily }

{\ttfamily const float$\ast$ ranges\mbox{[}\mbox{]} = \{ hranges, sranges \};}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat\+ND hist;}

{\ttfamily }

{\ttfamily }

{\ttfamily // we compute the histogram from the 0-\/th and 1-\/st channels}

{\ttfamily }

{\ttfamily }

{\ttfamily int channels\mbox{[}\mbox{]} = \{0, 1\};}

{\ttfamily }

{\ttfamily }

{\ttfamily calc\+Hist(\&hsv, 1, channels, Mat(), // do not use mask}

{\ttfamily }

{\ttfamily }

{\ttfamily hist, 2, hist\+Size, ranges,}

{\ttfamily }

{\ttfamily }

{\ttfamily true, // the histogram is uniform}

{\ttfamily }

{\ttfamily }

{\ttfamily false);}

{\ttfamily }

{\ttfamily }

{\ttfamily double max\+Val=0;}

{\ttfamily }

{\ttfamily }

{\ttfamily min\+Max\+Loc(hist, 0, \&max\+Val, 0, 0);}

{\ttfamily }

{\ttfamily }

{\ttfamily int scale = 10;}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat hist\+Img = Mat.\+zeros(sbins$\ast$scale, hbins$\ast$10, C\+V\+\_\+8\+U\+C3);}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int h = 0; h $<$ hbins; h++)}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int s = 0; s $<$ sbins; s++)}

{\ttfamily }

{\ttfamily }

{\ttfamily float bin\+Val = hist.\+at$<$float$>$(h, s);}

{\ttfamily }

{\ttfamily }

{\ttfamily int intensity = cv\+Round(bin\+Val$\ast$255/max\+Val);}

{\ttfamily }

{\ttfamily }

{\ttfamily rectangle(hist\+Img, Point(h$\ast$scale, s$\ast$scale),}

{\ttfamily }

{\ttfamily }

{\ttfamily Point((h+1)$\ast$scale -\/ 1, (s+1)$\ast$scale -\/ 1),}

{\ttfamily }

{\ttfamily }

{\ttfamily Scalar.\+all(intensity),}

{\ttfamily }

{\ttfamily }

{\ttfamily C\+V\+\_\+\+F\+I\+L\+L\+ED);}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Source\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Source\char`\"{}, src);}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+H-\/\+S Histogram\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+H-\/\+S Histogram\char`\"{}, hist\+Img);}

{\ttfamily }

{\ttfamily }

{\ttfamily wait\+Key();}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: }


\begin{DoxyItemize}
\item An example for creating histograms of an image can be found at opencv\+\_\+source\+\_\+code/samples/cpp/demhist.\+cpp 
\item (Python) An example for creating color histograms can be found at opencv\+\_\+source/samples/python2/color\+\_\+histogram.\+py 
\item (Python) An example illustrating R\+GB and grayscale histogram plotting can be found at opencv\+\_\+source/samples/python2/hist.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em images} & Source arrays. They all should have the same depth, {\ttfamily C\+V\+\_\+8U} or {\ttfamily C\+V\+\_\+32F}, and the same size. Each of them can have an arbitrary number of channels. \\
\hline
{\em channels} & List of the {\ttfamily dims} channels used to compute the histogram. The first array channels are numerated from 0 to {\ttfamily images\mbox{[}0\mbox{]}.channels()-\/1}, the second array channels are counted from {\ttfamily images\mbox{[}0\mbox{]}.channels()} to {\ttfamily images\mbox{[}0\mbox{]}.channels() + images\mbox{[}1\mbox{]}.channels()-\/1}, and so on. \\
\hline
{\em mask} & Optional mask. If the matrix is not empty, it must be an 8-\/bit array of the same size as {\ttfamily images\mbox{[}i\mbox{]}}. The non-\/zero mask elements mark the array elements counted in the histogram. \\
\hline
{\em hist} & Output histogram, which is a dense or sparse {\ttfamily dims} -\/dimensional array. \\
\hline
{\em hist\+Size} & Array of histogram sizes in each dimension. \\
\hline
{\em ranges} & Array of the {\ttfamily dims} arrays of the histogram bin boundaries in each dimension. When the histogram is uniform ({\ttfamily uniform} =true), then for each dimension {\ttfamily i} it is enough to specify the lower (inclusive) boundary {\itshape L\+\_\+0} of the 0-\/th histogram bin and the upper (exclusive) boundary {\itshape U\+\_\+(hist\+Size\mbox{[}i\mbox{]}-\/1)} for the last histogram bin {\ttfamily hist\+Size\mbox{[}i\mbox{]}-\/1}. That is, in case of a uniform histogram each of {\ttfamily ranges\mbox{[}i\mbox{]}} is an array of 2 elements. When the histogram is not uniform ({\ttfamily uniform=false}), then each of {\ttfamily ranges\mbox{[}i\mbox{]}} contains {\ttfamily hist\+Size\mbox{[}i\mbox{]}+1} elements\+: {\itshape L\+\_\+0, U\+\_\+0=L\+\_\+1, U\+\_\+1=L\+\_\+2,..., U\+\_\+(hist\+Size\mbox{[}i\mbox{]}-\/2)=L\+\_\+(hist\+Size\mbox{[}i\mbox{]}-\/1), U\+\_\+(hist\+Size\mbox{[}i\mbox{]}-\/1)}. The array elements, that are not between {\itshape L\+\_\+0} and {\itshape U\+\_\+(hist\+Size\mbox{[}i\mbox{]}-\/1)}, are not counted in the histogram.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/histograms.html#calchist}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+calc\+Hist} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac6e36285c582511bc5afe41d9d0b0e41}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac6e36285c582511bc5afe41d9d0b0e41}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Canny@{Canny}}
\index{Canny@{Canny}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Canny()}{Canny()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Canny (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{edges,  }\item[{double}]{threshold1,  }\item[{double}]{threshold2,  }\item[{int}]{aperture\+Size,  }\item[{boolean}]{L2gradient }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds edges in an image using the \mbox{[}Canny86\mbox{]} algorithm.

The function finds edges in the input image {\ttfamily image} and marks them in the output map {\ttfamily edges} using the Canny algorithm. The smallest value between {\ttfamily threshold1} and {\ttfamily threshold2} is used for edge linking. The largest value is used to find initial segments of strong edges. See \href{http://en.wikipedia.org/wiki/Canny_edge_detector}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Canny\+\_\+edge\+\_\+detector}

Note\+:


\begin{DoxyItemize}
\item An example on using the canny edge detector can be found at opencv\+\_\+source\+\_\+code/samples/cpp/edge.\+cpp 
\item (Python) An example on using the canny edge detector can be found at opencv\+\_\+source\+\_\+code/samples/python/edge.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & single-\/channel 8-\/bit input image. \\
\hline
{\em edges} & output edge map; it has the same size and type as {\ttfamily image}. \\
\hline
{\em threshold1} & first threshold for the hysteresis procedure. \\
\hline
{\em threshold2} & second threshold for the hysteresis procedure. \\
\hline
{\em aperture\+Size} & aperture size for the \char`\"{}\+Sobel\char`\"{} operator. \\
\hline
{\em L2gradient} & a flag, indicating whether a more accurate {\itshape L\+\_\+2} norm {\itshape =sqrt((d\+I/dx)$^\wedge$2 + (d\+I/dy)$^\wedge$2)} should be used to calculate the image gradient magnitude ({\ttfamily L2gradient=true}), or whether the default {\itshape L\+\_\+1} norm {\itshape =$\vert$d\+I/dx$\vert$+$\vert$d\+I/dy$\vert$} is enough ({\ttfamily L2gradient=false}).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#canny}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Canny} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae979d995b2b91944a5db1e3be9c3835f}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae979d995b2b91944a5db1e3be9c3835f}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Canny@{Canny}}
\index{Canny@{Canny}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Canny()}{Canny()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Canny (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{edges,  }\item[{double}]{threshold1,  }\item[{double}]{threshold2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds edges in an image using the \mbox{[}Canny86\mbox{]} algorithm.

The function finds edges in the input image {\ttfamily image} and marks them in the output map {\ttfamily edges} using the Canny algorithm. The smallest value between {\ttfamily threshold1} and {\ttfamily threshold2} is used for edge linking. The largest value is used to find initial segments of strong edges. See \href{http://en.wikipedia.org/wiki/Canny_edge_detector}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Canny\+\_\+edge\+\_\+detector}

Note\+:


\begin{DoxyItemize}
\item An example on using the canny edge detector can be found at opencv\+\_\+source\+\_\+code/samples/cpp/edge.\+cpp 
\item (Python) An example on using the canny edge detector can be found at opencv\+\_\+source\+\_\+code/samples/python/edge.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & single-\/channel 8-\/bit input image. \\
\hline
{\em edges} & output edge map; it has the same size and type as {\ttfamily image}. \\
\hline
{\em threshold1} & first threshold for the hysteresis procedure. \\
\hline
{\em threshold2} & second threshold for the hysteresis procedure.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#canny}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Canny} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5b3dd3404f725b0d9c7a5fa249ffd855}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5b3dd3404f725b0d9c7a5fa249ffd855}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!compare\+Hist@{compare\+Hist}}
\index{compare\+Hist@{compare\+Hist}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{compare\+Hist()}{compareHist()}}
{\footnotesize\ttfamily static double org.\+opencv.\+imgproc.\+Imgproc.\+compare\+Hist (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{H1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{H2,  }\item[{int}]{method }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Compares two histograms.

The functions {\ttfamily compare\+Hist} compare two dense or two sparse histograms using the specified method\+:


\begin{DoxyItemize}
\item Correlation ({\ttfamily method=C\+V\+\_\+\+C\+O\+M\+P\+\_\+\+C\+O\+R\+R\+EL}) 
\end{DoxyItemize}

{\itshape d(\+H\+\_\+1,\+H\+\_\+2) = (sum\+\_\+I(H\+\_\+1(\+I) -\/ H\+\_\+1\char`\"{})(\+H\+\_\+2(\+I) -\/ H\+\_\+2\char`\"{}))/(sqrt(sum\+\_\+I(H\+\_\+1(\+I) -\/ H\+\_\+1\char`\"{})$^\wedge$2 sum\+\_\+\+I(\+H\+\_\+2(\+I) -\/ H\+\_\+2\char`\"{})$^\wedge$2))}

where

{\itshape H\+\_\+k" = 1/(N) sum \+\_\+J H\+\_\+k(\+J)}

and {\itshape N} is a total number of histogram bins.


\begin{DoxyItemize}
\item Chi-\/\+Square ({\ttfamily method=C\+V\+\_\+\+C\+O\+M\+P\+\_\+\+C\+H\+I\+S\+QR}) 
\end{DoxyItemize}

{\itshape d(\+H\+\_\+1,\+H\+\_\+2) = sum \+\_\+I((H\+\_\+1(\+I)-\/\+H\+\_\+2(I))$^\wedge$2)/(H\+\_\+1(\+I))}


\begin{DoxyItemize}
\item Intersection ({\ttfamily method=C\+V\+\_\+\+C\+O\+M\+P\+\_\+\+I\+N\+T\+E\+R\+S\+E\+CT}) 
\end{DoxyItemize}

{\itshape d(\+H\+\_\+1,\+H\+\_\+2) = sum \+\_\+I min(H\+\_\+1(\+I), H\+\_\+2(\+I))}


\begin{DoxyItemize}
\item Bhattacharyya distance ({\ttfamily method=C\+V\+\_\+\+C\+O\+M\+P\+\_\+\+B\+H\+A\+T\+T\+A\+C\+H\+A\+R\+Y\+YA} or {\ttfamily method=C\+V\+\_\+\+C\+O\+M\+P\+\_\+\+H\+E\+L\+L\+I\+N\+G\+ER}). In fact, Open\+CV computes Hellinger distance, which is related to Bhattacharyya coefficient. 
\end{DoxyItemize}

{\itshape d(\+H\+\_\+1,\+H\+\_\+2) = sqrt(1 -\/ frac(1)(sqrt(H\+\_\+1\char`\"{} H\+\_\+2\char`\"{} N$^\wedge$2)) sum\+\_\+I sqrt(H\+\_\+1(\+I) $\ast$ H\+\_\+2(\+I)))}

The function returns {\itshape d(\+H\+\_\+1, H\+\_\+2)}.

While the function works well with 1-\/, 2-\/, 3-\/dimensional dense histograms, it may not be suitable for high-\/dimensional sparse histograms. In such histograms, because of aliasing and sampling problems, the coordinates of non-\/zero histogram bins can slightly shift. To compare such histograms or more general sparse configurations of weighted points, consider using the \char`\"{}\+E\+M\+D\char`\"{} function.


\begin{DoxyParams}{Parameters}
{\em H1} & First compared histogram. \\
\hline
{\em H2} & Second compared histogram of the same size as {\ttfamily H1}. \\
\hline
{\em method} & Comparison method that could be one of the following\+: 
\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+O\+M\+P\+\_\+\+C\+O\+R\+R\+EL Correlation 
\item C\+V\+\_\+\+C\+O\+M\+P\+\_\+\+C\+H\+I\+S\+QR Chi-\/\+Square 
\item C\+V\+\_\+\+C\+O\+M\+P\+\_\+\+I\+N\+T\+E\+R\+S\+E\+CT Intersection 
\item C\+V\+\_\+\+C\+O\+M\+P\+\_\+\+B\+H\+A\+T\+T\+A\+C\+H\+A\+R\+Y\+YA Bhattacharyya distance 
\item C\+V\+\_\+\+C\+O\+M\+P\+\_\+\+H\+E\+L\+L\+I\+N\+G\+ER Synonym for {\ttfamily C\+V\+\_\+\+C\+O\+M\+P\+\_\+\+B\+H\+A\+T\+T\+A\+C\+H\+A\+R\+Y\+YA} 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/histograms.html#comparehist}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+compare\+Hist} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0b9b82e8b2461a102788628c8b86d1a1}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0b9b82e8b2461a102788628c8b86d1a1}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!contour\+Area@{contour\+Area}}
\index{contour\+Area@{contour\+Area}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{contour\+Area()}{contourArea()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static double org.\+opencv.\+imgproc.\+Imgproc.\+contour\+Area (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{contour,  }\item[{boolean}]{oriented }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a contour area.

The function computes a contour area. Similarly to \char`\"{}moments\char`\"{}, the area is computed using the Green formula. Thus, the returned area and the number of non-\/zero pixels, if you draw the contour using \char`\"{}draw\+Contours\char`\"{} or \char`\"{}fill\+Poly\char`\"{}, can be different. Also, the function will most certainly give a wrong results for contours with self-\/intersections. Example\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point$>$ contour;}

{\ttfamily }

{\ttfamily }

{\ttfamily contour.\+push\+\_\+back(\+Point2f(0, 0));}

{\ttfamily }

{\ttfamily }

{\ttfamily contour.\+push\+\_\+back(\+Point2f(10, 0));}

{\ttfamily }

{\ttfamily }

{\ttfamily contour.\+push\+\_\+back(\+Point2f(10, 10));}

{\ttfamily }

{\ttfamily }

{\ttfamily contour.\+push\+\_\+back(\+Point2f(5, 4));}

{\ttfamily }

{\ttfamily }

{\ttfamily double area0 = contour\+Area(contour);}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point$>$ approx;}

{\ttfamily }

{\ttfamily }

{\ttfamily approx\+Poly\+D\+P(contour, approx, 5, true);}

{\ttfamily }

{\ttfamily }

{\ttfamily double area1 = contour\+Area(approx);}

{\ttfamily }

{\ttfamily }

{\ttfamily cout $<$$<$ \char`\"{}area0 =\char`\"{} $<$$<$ area0 $<$$<$ endl $<$$<$}

{\ttfamily }

{\ttfamily }

{\ttfamily \char`\"{}area1 =\char`\"{} $<$$<$ area1 $<$$<$ endl $<$$<$}

{\ttfamily }

{\ttfamily }

{\ttfamily \char`\"{}approx poly vertices\char`\"{} $<$$<$ approx.\+size() $<$$<$ endl;}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em contour} & Input vector of 2D points (contour vertices), stored in {\ttfamily std.\+vector} or {\ttfamily Mat}. \\
\hline
{\em oriented} & Oriented area flag. If it is true, the function returns a signed area value, depending on the contour orientation (clockwise or counter-\/clockwise). Using this feature you can determine orientation of a contour by taking the sign of an area. By default, the parameter is {\ttfamily false}, which means that the absolute value is returned.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#contourarea}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+contour\+Area} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9d6a5977b0691eb9736af8151e2bbc61}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9d6a5977b0691eb9736af8151e2bbc61}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!contour\+Area@{contour\+Area}}
\index{contour\+Area@{contour\+Area}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{contour\+Area()}{contourArea()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static double org.\+opencv.\+imgproc.\+Imgproc.\+contour\+Area (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{contour }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a contour area.

The function computes a contour area. Similarly to \char`\"{}moments\char`\"{}, the area is computed using the Green formula. Thus, the returned area and the number of non-\/zero pixels, if you draw the contour using \char`\"{}draw\+Contours\char`\"{} or \char`\"{}fill\+Poly\char`\"{}, can be different. Also, the function will most certainly give a wrong results for contours with self-\/intersections. Example\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point$>$ contour;}

{\ttfamily }

{\ttfamily }

{\ttfamily contour.\+push\+\_\+back(\+Point2f(0, 0));}

{\ttfamily }

{\ttfamily }

{\ttfamily contour.\+push\+\_\+back(\+Point2f(10, 0));}

{\ttfamily }

{\ttfamily }

{\ttfamily contour.\+push\+\_\+back(\+Point2f(10, 10));}

{\ttfamily }

{\ttfamily }

{\ttfamily contour.\+push\+\_\+back(\+Point2f(5, 4));}

{\ttfamily }

{\ttfamily }

{\ttfamily double area0 = contour\+Area(contour);}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Point$>$ approx;}

{\ttfamily }

{\ttfamily }

{\ttfamily approx\+Poly\+D\+P(contour, approx, 5, true);}

{\ttfamily }

{\ttfamily }

{\ttfamily double area1 = contour\+Area(approx);}

{\ttfamily }

{\ttfamily }

{\ttfamily cout $<$$<$ \char`\"{}area0 =\char`\"{} $<$$<$ area0 $<$$<$ endl $<$$<$}

{\ttfamily }

{\ttfamily }

{\ttfamily \char`\"{}area1 =\char`\"{} $<$$<$ area1 $<$$<$ endl $<$$<$}

{\ttfamily }

{\ttfamily }

{\ttfamily \char`\"{}approx poly vertices\char`\"{} $<$$<$ approx.\+size() $<$$<$ endl;}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em contour} & Input vector of 2D points (contour vertices), stored in {\ttfamily std.\+vector} or {\ttfamily Mat}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#contourarea}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+contour\+Area} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a03418d25b2a22395f42e32d869937f95}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a03418d25b2a22395f42e32d869937f95}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!convert\+Maps@{convert\+Maps}}
\index{convert\+Maps@{convert\+Maps}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{convert\+Maps()}{convertMaps()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+convert\+Maps (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dstmap1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dstmap2,  }\item[{int}]{dstmap1type,  }\item[{boolean}]{nninterpolation }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Converts image transformation maps from one representation to another.

The function converts a pair of maps for \char`\"{}remap\char`\"{} from one representation to another. The following options ({\ttfamily (map1.\+type(), map2.\+type())} {\itshape -\/$>$} {\ttfamily (dstmap1.\+type(), dstmap2.\+type())}) are supported\+:


\begin{DoxyItemize}
\item {\itshape (C\+V\+\_\+32\+F\+C1, C\+V\+\_\+32\+F\+C1) -\/$>$ (C\+V\+\_\+16\+S\+C2, C\+V\+\_\+16\+U\+C1)}. This is the most frequently used conversion operation, in which the original floating-\/point maps (see \char`\"{}remap\char`\"{}) are converted to a more compact and much faster fixed-\/point representation. The first output array contains the rounded coordinates and the second array (created only when {\ttfamily nninterpolation=false}) contains indices in the interpolation tables. 
\item {\itshape (C\+V\+\_\+32\+F\+C2) -\/$>$ (C\+V\+\_\+16\+S\+C2, C\+V\+\_\+16\+U\+C1)}. The same as above but the original maps are stored in one 2-\/channel matrix. 
\item Reverse conversion. Obviously, the reconstructed floating-\/point maps will not be exactly the same as the originals. 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em map1} & The first input map of type {\ttfamily C\+V\+\_\+16\+S\+C2}, {\ttfamily C\+V\+\_\+32\+F\+C1}, or {\ttfamily C\+V\+\_\+32\+F\+C2}. \\
\hline
{\em map2} & The second input map of type {\ttfamily C\+V\+\_\+16\+U\+C1}, {\ttfamily C\+V\+\_\+32\+F\+C1}, or none (empty matrix), respectively. \\
\hline
{\em dstmap1} & The first output map that has the type {\ttfamily dstmap1type} and the same size as {\ttfamily src}. \\
\hline
{\em dstmap2} & The second output map. \\
\hline
{\em dstmap1type} & Type of the first output map that should be {\ttfamily C\+V\+\_\+16\+S\+C2}, {\ttfamily C\+V\+\_\+32\+F\+C1}, or {\ttfamily C\+V\+\_\+32\+F\+C2}. \\
\hline
{\em nninterpolation} & Flag indicating whether the fixed-\/point maps are used for the nearest-\/neighbor or for a more complex interpolation.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#convertmaps}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+convert\+Maps} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}{org.\+opencv.\+imgproc.\+Imgproc\+::remap}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae7ecce50c4e0db8881a8a59a02a3fdf3}{org.\+opencv.\+imgproc.\+Imgproc\+::init\+Undistort\+Rectify\+Map}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0733bf11be8125dfc28b6ff4da746927}{org.\+opencv.\+imgproc.\+Imgproc\+::undistort}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab36cb67b988ea831009909fb126efc3d}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab36cb67b988ea831009909fb126efc3d}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!convert\+Maps@{convert\+Maps}}
\index{convert\+Maps@{convert\+Maps}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{convert\+Maps()}{convertMaps()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+convert\+Maps (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dstmap1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dstmap2,  }\item[{int}]{dstmap1type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Converts image transformation maps from one representation to another.

The function converts a pair of maps for \char`\"{}remap\char`\"{} from one representation to another. The following options ({\ttfamily (map1.\+type(), map2.\+type())} {\itshape -\/$>$} {\ttfamily (dstmap1.\+type(), dstmap2.\+type())}) are supported\+:


\begin{DoxyItemize}
\item {\itshape (C\+V\+\_\+32\+F\+C1, C\+V\+\_\+32\+F\+C1) -\/$>$ (C\+V\+\_\+16\+S\+C2, C\+V\+\_\+16\+U\+C1)}. This is the most frequently used conversion operation, in which the original floating-\/point maps (see \char`\"{}remap\char`\"{}) are converted to a more compact and much faster fixed-\/point representation. The first output array contains the rounded coordinates and the second array (created only when {\ttfamily nninterpolation=false}) contains indices in the interpolation tables. 
\item {\itshape (C\+V\+\_\+32\+F\+C2) -\/$>$ (C\+V\+\_\+16\+S\+C2, C\+V\+\_\+16\+U\+C1)}. The same as above but the original maps are stored in one 2-\/channel matrix. 
\item Reverse conversion. Obviously, the reconstructed floating-\/point maps will not be exactly the same as the originals. 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em map1} & The first input map of type {\ttfamily C\+V\+\_\+16\+S\+C2}, {\ttfamily C\+V\+\_\+32\+F\+C1}, or {\ttfamily C\+V\+\_\+32\+F\+C2}. \\
\hline
{\em map2} & The second input map of type {\ttfamily C\+V\+\_\+16\+U\+C1}, {\ttfamily C\+V\+\_\+32\+F\+C1}, or none (empty matrix), respectively. \\
\hline
{\em dstmap1} & The first output map that has the type {\ttfamily dstmap1type} and the same size as {\ttfamily src}. \\
\hline
{\em dstmap2} & The second output map. \\
\hline
{\em dstmap1type} & Type of the first output map that should be {\ttfamily C\+V\+\_\+16\+S\+C2}, {\ttfamily C\+V\+\_\+32\+F\+C1}, or {\ttfamily C\+V\+\_\+32\+F\+C2}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#convertmaps}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+convert\+Maps} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}{org.\+opencv.\+imgproc.\+Imgproc\+::remap}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae7ecce50c4e0db8881a8a59a02a3fdf3}{org.\+opencv.\+imgproc.\+Imgproc\+::init\+Undistort\+Rectify\+Map}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0733bf11be8125dfc28b6ff4da746927}{org.\+opencv.\+imgproc.\+Imgproc\+::undistort}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aca40be72d91322b2caa2e37b5da190e6}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aca40be72d91322b2caa2e37b5da190e6}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!convex\+Hull@{convex\+Hull}}
\index{convex\+Hull@{convex\+Hull}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{convex\+Hull()}{convexHull()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+convex\+Hull (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}}}]{points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}}}]{hull,  }\item[{boolean}]{clockwise }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the convex hull of a point set.

The functions find the convex hull of a 2D point set using the Sklansky\textquotesingle{}s algorithm \mbox{[}Sklansky82\mbox{]} that has {\itshape O(\+N log\+N)} complexity in the current implementation. See the Open\+CV sample {\ttfamily convexhull.\+cpp} that demonstrates the usage of different function variants.

Note\+:


\begin{DoxyItemize}
\item An example using the convex\+Hull functionality can be found at opencv\+\_\+source\+\_\+code/samples/cpp/convexhull.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em points} & Input 2D point set, stored in {\ttfamily std.\+vector} or {\ttfamily Mat}. \\
\hline
{\em hull} & Output convex hull. It is either an integer vector of indices or vector of points. In the first case, the {\ttfamily hull} elements are 0-\/based indices of the convex hull points in the original array (since the set of convex hull points is a subset of the original point set). In the second case, {\ttfamily hull} elements are the convex hull points themselves. \\
\hline
{\em clockwise} & Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-\/clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#convexhull}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+convex\+Hull} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aea7e7b3c039ba7d3c04629b3a9cd399d}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aea7e7b3c039ba7d3c04629b3a9cd399d}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!convex\+Hull@{convex\+Hull}}
\index{convex\+Hull@{convex\+Hull}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{convex\+Hull()}{convexHull()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+convex\+Hull (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}}}]{points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}}}]{hull }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the convex hull of a point set.

The functions find the convex hull of a 2D point set using the Sklansky\textquotesingle{}s algorithm \mbox{[}Sklansky82\mbox{]} that has {\itshape O(\+N log\+N)} complexity in the current implementation. See the Open\+CV sample {\ttfamily convexhull.\+cpp} that demonstrates the usage of different function variants.

Note\+:


\begin{DoxyItemize}
\item An example using the convex\+Hull functionality can be found at opencv\+\_\+source\+\_\+code/samples/cpp/convexhull.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em points} & Input 2D point set, stored in {\ttfamily std.\+vector} or {\ttfamily Mat}. \\
\hline
{\em hull} & Output convex hull. It is either an integer vector of indices or vector of points. In the first case, the {\ttfamily hull} elements are 0-\/based indices of the convex hull points in the original array (since the set of convex hull points is a subset of the original point set). In the second case, {\ttfamily hull} elements are the convex hull points themselves.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#convexhull}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+convex\+Hull} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a209ed56855c2b90701908839e25f773a}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a209ed56855c2b90701908839e25f773a}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!convexity\+Defects@{convexity\+Defects}}
\index{convexity\+Defects@{convexity\+Defects}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{convexity\+Defects()}{convexityDefects()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+convexity\+Defects (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}}}]{contour,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int}{Mat\+Of\+Int}}}]{convexhull,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_int4}{Mat\+Of\+Int4}}}]{convexity\+Defects }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds the convexity defects of a contour.

The function finds all convexity defects of the input contour and returns a sequence of the {\ttfamily Cv\+Convexity\+Defect} structures, where {\ttfamily Cv\+Convexity\+Detect} is defined as\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily struct Cv\+Convexity\+Defect}

{\ttfamily }

{\ttfamily }

{\ttfamily Cv\+Point$\ast$ start; // point of the contour where the defect begins}

{\ttfamily }

{\ttfamily }

{\ttfamily Cv\+Point$\ast$ end; // point of the contour where the defect ends}

{\ttfamily }

{\ttfamily }

{\ttfamily Cv\+Point$\ast$ depth\+\_\+point; // the farthest from the convex hull point within the defect}

{\ttfamily }

{\ttfamily }

{\ttfamily float depth; // distance between the farthest point and the convex hull}

{\ttfamily }

{\ttfamily }

{\ttfamily \};}

{\ttfamily }

{\ttfamily }

{\ttfamily The figure below displays convexity defects of a hand contour\+: }


\begin{DoxyParams}{Parameters}
{\em contour} & Input contour. \\
\hline
{\em convexhull} & Convex hull obtained using \char`\"{}convex\+Hull\char`\"{} that should contain indices of the contour points that make the hull. \\
\hline
{\em convexity\+Defects} & The output vector of convexity defects. In C++ and the new Python/\+Java interface each convexity defect is represented as 4-\/element integer vector (a.\+k.\+a. {\ttfamily cv.\+Vec4i})\+: {\ttfamily (start\+\_\+index, end\+\_\+index, farthest\+\_\+pt\+\_\+index, fixpt\+\_\+depth)}, where indices are 0-\/based indices in the original contour of the convexity defect beginning, end and the farthest point, and {\ttfamily fixpt\+\_\+depth} is fixed-\/point approximation (with 8 fractional bits) of the distance between the farthest contour point and the hull. That is, to get the floating-\/point value of the depth will be {\ttfamily fixpt\+\_\+depth/256.\+0}. In C interface convexity defect is represented by {\ttfamily Cv\+Convexity\+Defect} structure -\/ see below.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#convexitydefects}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+convexity\+Defects} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aeeb280b7ea42158d887ce0d82e6ea0e4}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aeeb280b7ea42158d887ce0d82e6ea0e4}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!copy\+Make\+Border@{copy\+Make\+Border}}
\index{copy\+Make\+Border@{copy\+Make\+Border}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{copy\+Make\+Border()}{copyMakeBorder()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+copy\+Make\+Border (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{top,  }\item[{int}]{bottom,  }\item[{int}]{left,  }\item[{int}]{right,  }\item[{int}]{border\+Type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Forms a border around an image.

The function copies the source image into the middle of the destination image. The areas to the left, to the right, above and below the copied source image will be filled with extrapolated pixels. This is not what \char`\"{}\+Filter\+Engine\char`\"{} or filtering functions based on it do (they extrapolate pixels on-\/fly), but what other more complex functions, including your own, may do to simplify image boundary handling. The function supports the mode when {\ttfamily src} is already in the middle of {\ttfamily dst}. In this case, the function does not copy {\ttfamily src} itself but simply constructs the border, for example\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // let border be the same in all directions}

{\ttfamily }

{\ttfamily }

{\ttfamily int border=2;}

{\ttfamily }

{\ttfamily }

{\ttfamily // constructs a larger image to fit both the image and the border}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat gray\+\_\+buf(rgb.\+rows + border$\ast$2, rgb.\+cols + border$\ast$2, rgb.\+depth());}

{\ttfamily }

{\ttfamily }

{\ttfamily // select the middle part of it w/o copying data}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat gray(gray\+\_\+canvas, Rect(border, border, rgb.\+cols, rgb.\+rows));}

{\ttfamily }

{\ttfamily }

{\ttfamily // convert image from R\+GB to grayscale}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(rgb, gray, C\+V\+\_\+\+R\+G\+B2\+G\+R\+A\+Y);}

{\ttfamily }

{\ttfamily }

{\ttfamily // form a border in-\/place}

{\ttfamily }

{\ttfamily }

{\ttfamily copy\+Make\+Border(gray, gray\+\_\+buf, border, border,}

{\ttfamily }

{\ttfamily }

{\ttfamily border, border, B\+O\+R\+D\+E\+R\+\_\+\+R\+E\+P\+L\+I\+C\+A\+TE);}

{\ttfamily }

{\ttfamily }

{\ttfamily // now do some custom filtering......}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: }

When the source image is a part (R\+OI) of a bigger image, the function will try to use the pixels outside of the R\+OI to form a border. To disable this feature and always do extrapolation, as if {\ttfamily src} was not a R\+OI, use {\ttfamily border\+Type $\vert$ B\+O\+R\+D\+E\+R\+\_\+\+I\+S\+O\+L\+A\+T\+ED}.


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image of the same type as {\ttfamily src} and the size {\ttfamily Size(src.\+cols+left+right, src.\+rows+top+bottom)}. \\
\hline
{\em top} & a top \\
\hline
{\em bottom} & a bottom \\
\hline
{\em left} & a left \\
\hline
{\em right} & Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate. For example, {\ttfamily top=1, bottom=1, left=1, right=1} mean that 1 pixel-\/wide border needs to be built. \\
\hline
{\em border\+Type} & Border type. See \char`\"{}border\+Interpolate\char`\"{} for details. \\
\hline
{\em value} & Border value if {\ttfamily border\+Type==B\+O\+R\+D\+E\+R\+\_\+\+C\+O\+N\+S\+T\+A\+NT}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#copymakeborder}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+copy\+Make\+Border} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0bd258d65b0db015ac1106dea7126e9d}{org.\+opencv.\+imgproc.\+Imgproc\+::border\+Interpolate}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9a788b12632bb2021d6fc4194c524364}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9a788b12632bb2021d6fc4194c524364}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!copy\+Make\+Border@{copy\+Make\+Border}}
\index{copy\+Make\+Border@{copy\+Make\+Border}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{copy\+Make\+Border()}{copyMakeBorder()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+copy\+Make\+Border (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{top,  }\item[{int}]{bottom,  }\item[{int}]{left,  }\item[{int}]{right,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Forms a border around an image.

The function copies the source image into the middle of the destination image. The areas to the left, to the right, above and below the copied source image will be filled with extrapolated pixels. This is not what \char`\"{}\+Filter\+Engine\char`\"{} or filtering functions based on it do (they extrapolate pixels on-\/fly), but what other more complex functions, including your own, may do to simplify image boundary handling. The function supports the mode when {\ttfamily src} is already in the middle of {\ttfamily dst}. In this case, the function does not copy {\ttfamily src} itself but simply constructs the border, for example\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // let border be the same in all directions}

{\ttfamily }

{\ttfamily }

{\ttfamily int border=2;}

{\ttfamily }

{\ttfamily }

{\ttfamily // constructs a larger image to fit both the image and the border}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat gray\+\_\+buf(rgb.\+rows + border$\ast$2, rgb.\+cols + border$\ast$2, rgb.\+depth());}

{\ttfamily }

{\ttfamily }

{\ttfamily // select the middle part of it w/o copying data}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat gray(gray\+\_\+canvas, Rect(border, border, rgb.\+cols, rgb.\+rows));}

{\ttfamily }

{\ttfamily }

{\ttfamily // convert image from R\+GB to grayscale}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(rgb, gray, C\+V\+\_\+\+R\+G\+B2\+G\+R\+A\+Y);}

{\ttfamily }

{\ttfamily }

{\ttfamily // form a border in-\/place}

{\ttfamily }

{\ttfamily }

{\ttfamily copy\+Make\+Border(gray, gray\+\_\+buf, border, border,}

{\ttfamily }

{\ttfamily }

{\ttfamily border, border, B\+O\+R\+D\+E\+R\+\_\+\+R\+E\+P\+L\+I\+C\+A\+TE);}

{\ttfamily }

{\ttfamily }

{\ttfamily // now do some custom filtering......}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: }

When the source image is a part (R\+OI) of a bigger image, the function will try to use the pixels outside of the R\+OI to form a border. To disable this feature and always do extrapolation, as if {\ttfamily src} was not a R\+OI, use {\ttfamily border\+Type $\vert$ B\+O\+R\+D\+E\+R\+\_\+\+I\+S\+O\+L\+A\+T\+ED}.


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image of the same type as {\ttfamily src} and the size {\ttfamily Size(src.\+cols+left+right, src.\+rows+top+bottom)}. \\
\hline
{\em top} & a top \\
\hline
{\em bottom} & a bottom \\
\hline
{\em left} & a left \\
\hline
{\em right} & Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate. For example, {\ttfamily top=1, bottom=1, left=1, right=1} mean that 1 pixel-\/wide border needs to be built. \\
\hline
{\em border\+Type} & Border type. See \char`\"{}border\+Interpolate\char`\"{} for details.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#copymakeborder}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+copy\+Make\+Border} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0bd258d65b0db015ac1106dea7126e9d}{org.\+opencv.\+imgproc.\+Imgproc\+::border\+Interpolate}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa13f522ce6ccde35a54983d35640c3e1}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa13f522ce6ccde35a54983d35640c3e1}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!corner\+Eigen\+Vals\+And\+Vecs@{corner\+Eigen\+Vals\+And\+Vecs}}
\index{corner\+Eigen\+Vals\+And\+Vecs@{corner\+Eigen\+Vals\+And\+Vecs}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{corner\+Eigen\+Vals\+And\+Vecs()}{cornerEigenValsAndVecs()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Eigen\+Vals\+And\+Vecs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{block\+Size,  }\item[{int}]{ksize,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates eigenvalues and eigenvectors of image blocks for corner detection.

For every pixel {\itshape p}, the function {\ttfamily corner\+Eigen\+Vals\+And\+Vecs} considers a {\ttfamily block\+Size} {\itshape x} {\ttfamily block\+Size} neighborhood {\itshape S(p)}. It calculates the covariation matrix of derivatives over the neighborhood as\+:

{\itshape M = sum(by\+: S(p))(d\+I/dx)$^\wedge$2 sum(by\+: S(p))(d\+I/dx d\+I/dy)$^\wedge$2 sum(by\+: S(p))(d\+I/dx d\+I/dy)$^\wedge$2 sum(by\+: S(p))(d\+I/dy)$^\wedge$2 }

where the derivatives are computed using the \char`\"{}\+Sobel\char`\"{} operator.

After that, it finds eigenvectors and eigenvalues of {\itshape M} and stores them in the destination image as {\itshape (lambda\+\_\+1, lambda\+\_\+2, x\+\_\+1, y\+\_\+1, x\+\_\+2, y\+\_\+2)} where


\begin{DoxyItemize}
\item {\itshape lambda\+\_\+1, lambda\+\_\+2} are the non-\/sorted eigenvalues of {\itshape M} 
\item {\itshape x\+\_\+1, y\+\_\+1} are the eigenvectors corresponding to {\itshape lambda\+\_\+1} 
\item {\itshape x\+\_\+2, y\+\_\+2} are the eigenvectors corresponding to {\itshape lambda\+\_\+2} 
\end{DoxyItemize}

The output of the function can be used for robust edge or corner detection.

Note\+:


\begin{DoxyItemize}
\item (Python) An example on how to use eigenvectors and eigenvalues to estimate image texture flow direction can be found at opencv\+\_\+source\+\_\+code/samples/python2/texture\+\_\+flow.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & Input single-\/channel 8-\/bit or floating-\/point image. \\
\hline
{\em dst} & Image to store the results. It has the same size as {\ttfamily src} and the type {\ttfamily C\+V\+\_\+32\+F\+C(6)}. \\
\hline
{\em block\+Size} & Neighborhood size (see details below). \\
\hline
{\em ksize} & Aperture parameter for the \char`\"{}\+Sobel\char`\"{} operator. \\
\hline
{\em border\+Type} & Pixel extrapolation method. See \char`\"{}border\+Interpolate\char`\"{}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornereigenvalsandvecs}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Eigen\+Vals\+And\+Vecs} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aff9b8e4b52de80802161886bd074cdca}{org.\+opencv.\+imgproc.\+Imgproc\+::corner\+Harris}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9a5a2f96d413cc9f1ce919942a150a41}{org.\+opencv.\+imgproc.\+Imgproc\+::corner\+Min\+Eigen\+Val}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7cd6f2951d4243689ad0915162a14541}{org.\+opencv.\+imgproc.\+Imgproc\+::pre\+Corner\+Detect}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2d6d62e47c79f1dea4f66b9bebbe7b35}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2d6d62e47c79f1dea4f66b9bebbe7b35}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!corner\+Eigen\+Vals\+And\+Vecs@{corner\+Eigen\+Vals\+And\+Vecs}}
\index{corner\+Eigen\+Vals\+And\+Vecs@{corner\+Eigen\+Vals\+And\+Vecs}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{corner\+Eigen\+Vals\+And\+Vecs()}{cornerEigenValsAndVecs()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Eigen\+Vals\+And\+Vecs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{block\+Size,  }\item[{int}]{ksize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates eigenvalues and eigenvectors of image blocks for corner detection.

For every pixel {\itshape p}, the function {\ttfamily corner\+Eigen\+Vals\+And\+Vecs} considers a {\ttfamily block\+Size} {\itshape x} {\ttfamily block\+Size} neighborhood {\itshape S(p)}. It calculates the covariation matrix of derivatives over the neighborhood as\+:

{\itshape M = sum(by\+: S(p))(d\+I/dx)$^\wedge$2 sum(by\+: S(p))(d\+I/dx d\+I/dy)$^\wedge$2 sum(by\+: S(p))(d\+I/dx d\+I/dy)$^\wedge$2 sum(by\+: S(p))(d\+I/dy)$^\wedge$2 }

where the derivatives are computed using the \char`\"{}\+Sobel\char`\"{} operator.

After that, it finds eigenvectors and eigenvalues of {\itshape M} and stores them in the destination image as {\itshape (lambda\+\_\+1, lambda\+\_\+2, x\+\_\+1, y\+\_\+1, x\+\_\+2, y\+\_\+2)} where


\begin{DoxyItemize}
\item {\itshape lambda\+\_\+1, lambda\+\_\+2} are the non-\/sorted eigenvalues of {\itshape M} 
\item {\itshape x\+\_\+1, y\+\_\+1} are the eigenvectors corresponding to {\itshape lambda\+\_\+1} 
\item {\itshape x\+\_\+2, y\+\_\+2} are the eigenvectors corresponding to {\itshape lambda\+\_\+2} 
\end{DoxyItemize}

The output of the function can be used for robust edge or corner detection.

Note\+:


\begin{DoxyItemize}
\item (Python) An example on how to use eigenvectors and eigenvalues to estimate image texture flow direction can be found at opencv\+\_\+source\+\_\+code/samples/python2/texture\+\_\+flow.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & Input single-\/channel 8-\/bit or floating-\/point image. \\
\hline
{\em dst} & Image to store the results. It has the same size as {\ttfamily src} and the type {\ttfamily C\+V\+\_\+32\+F\+C(6)}. \\
\hline
{\em block\+Size} & Neighborhood size (see details below). \\
\hline
{\em ksize} & Aperture parameter for the \char`\"{}\+Sobel\char`\"{} operator.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornereigenvalsandvecs}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Eigen\+Vals\+And\+Vecs} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aff9b8e4b52de80802161886bd074cdca}{org.\+opencv.\+imgproc.\+Imgproc\+::corner\+Harris}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9a5a2f96d413cc9f1ce919942a150a41}{org.\+opencv.\+imgproc.\+Imgproc\+::corner\+Min\+Eigen\+Val}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7cd6f2951d4243689ad0915162a14541}{org.\+opencv.\+imgproc.\+Imgproc\+::pre\+Corner\+Detect}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aff9b8e4b52de80802161886bd074cdca}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aff9b8e4b52de80802161886bd074cdca}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!corner\+Harris@{corner\+Harris}}
\index{corner\+Harris@{corner\+Harris}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{corner\+Harris()}{cornerHarris()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Harris (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{block\+Size,  }\item[{int}]{ksize,  }\item[{double}]{k,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Harris edge detector.

The function runs the Harris edge detector on the image. Similarly to \char`\"{}corner\+Min\+Eigen\+Val\char`\"{} and \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{}, for each pixel {\itshape (x, y)} it calculates a {\itshape 2x2} gradient covariance matrix {\itshape M$^\wedge$((x,y))} over a {\itshape block\+Size x block\+Size} neighborhood. Then, it computes the following characteristic\+:

{\itshape dst(x,y) = det M$^\wedge$((x,y)) -\/ k $\ast$ (tr M$^\wedge$((x,y)))$^\wedge$2}

Corners in the image can be found as the local maxima of this response map.


\begin{DoxyParams}{Parameters}
{\em src} & Input single-\/channel 8-\/bit or floating-\/point image. \\
\hline
{\em dst} & Image to store the Harris detector responses. It has the type {\ttfamily C\+V\+\_\+32\+F\+C1} and the same size as {\ttfamily src}. \\
\hline
{\em block\+Size} & Neighborhood size (see the details on \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{}). \\
\hline
{\em ksize} & Aperture parameter for the \char`\"{}\+Sobel\char`\"{} operator. \\
\hline
{\em k} & Harris detector free parameter. See the formula below. \\
\hline
{\em border\+Type} & Pixel extrapolation method. See \char`\"{}border\+Interpolate\char`\"{}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornerharris}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Harris} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a86dc26104d7f6287e2f4eef9379542c4}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a86dc26104d7f6287e2f4eef9379542c4}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!corner\+Harris@{corner\+Harris}}
\index{corner\+Harris@{corner\+Harris}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{corner\+Harris()}{cornerHarris()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Harris (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{block\+Size,  }\item[{int}]{ksize,  }\item[{double}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Harris edge detector.

The function runs the Harris edge detector on the image. Similarly to \char`\"{}corner\+Min\+Eigen\+Val\char`\"{} and \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{}, for each pixel {\itshape (x, y)} it calculates a {\itshape 2x2} gradient covariance matrix {\itshape M$^\wedge$((x,y))} over a {\itshape block\+Size x block\+Size} neighborhood. Then, it computes the following characteristic\+:

{\itshape dst(x,y) = det M$^\wedge$((x,y)) -\/ k $\ast$ (tr M$^\wedge$((x,y)))$^\wedge$2}

Corners in the image can be found as the local maxima of this response map.


\begin{DoxyParams}{Parameters}
{\em src} & Input single-\/channel 8-\/bit or floating-\/point image. \\
\hline
{\em dst} & Image to store the Harris detector responses. It has the type {\ttfamily C\+V\+\_\+32\+F\+C1} and the same size as {\ttfamily src}. \\
\hline
{\em block\+Size} & Neighborhood size (see the details on \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{}). \\
\hline
{\em ksize} & Aperture parameter for the \char`\"{}\+Sobel\char`\"{} operator. \\
\hline
{\em k} & Harris detector free parameter. See the formula below.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornerharris}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Harris} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9a5a2f96d413cc9f1ce919942a150a41}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9a5a2f96d413cc9f1ce919942a150a41}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!corner\+Min\+Eigen\+Val@{corner\+Min\+Eigen\+Val}}
\index{corner\+Min\+Eigen\+Val@{corner\+Min\+Eigen\+Val}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{corner\+Min\+Eigen\+Val()}{cornerMinEigenVal()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Min\+Eigen\+Val (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{block\+Size,  }\item[{int}]{ksize,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the minimal eigenvalue of gradient matrices for corner detection.

The function is similar to \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{} but it calculates and stores only the minimal eigenvalue of the covariance matrix of derivatives, that is, {\itshape min(lambda\+\_\+1, lambda\+\_\+2)} in terms of the formulae in the \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{} description.


\begin{DoxyParams}{Parameters}
{\em src} & Input single-\/channel 8-\/bit or floating-\/point image. \\
\hline
{\em dst} & Image to store the minimal eigenvalues. It has the type {\ttfamily C\+V\+\_\+32\+F\+C1} and the same size as {\ttfamily src}. \\
\hline
{\em block\+Size} & Neighborhood size (see the details on \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{}). \\
\hline
{\em ksize} & Aperture parameter for the \char`\"{}\+Sobel\char`\"{} operator. \\
\hline
{\em border\+Type} & Pixel extrapolation method. See \char`\"{}border\+Interpolate\char`\"{}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornermineigenval}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Min\+Eigen\+Val} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7a680b6cb84ba84e1a6bbc6bfc121374}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7a680b6cb84ba84e1a6bbc6bfc121374}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!corner\+Min\+Eigen\+Val@{corner\+Min\+Eigen\+Val}}
\index{corner\+Min\+Eigen\+Val@{corner\+Min\+Eigen\+Val}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{corner\+Min\+Eigen\+Val()}{cornerMinEigenVal()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Min\+Eigen\+Val (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{block\+Size,  }\item[{int}]{ksize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the minimal eigenvalue of gradient matrices for corner detection.

The function is similar to \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{} but it calculates and stores only the minimal eigenvalue of the covariance matrix of derivatives, that is, {\itshape min(lambda\+\_\+1, lambda\+\_\+2)} in terms of the formulae in the \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{} description.


\begin{DoxyParams}{Parameters}
{\em src} & Input single-\/channel 8-\/bit or floating-\/point image. \\
\hline
{\em dst} & Image to store the minimal eigenvalues. It has the type {\ttfamily C\+V\+\_\+32\+F\+C1} and the same size as {\ttfamily src}. \\
\hline
{\em block\+Size} & Neighborhood size (see the details on \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{}). \\
\hline
{\em ksize} & Aperture parameter for the \char`\"{}\+Sobel\char`\"{} operator.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornermineigenval}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Min\+Eigen\+Val} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa8d64df7e315470530c31aca691bf1d1}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa8d64df7e315470530c31aca691bf1d1}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!corner\+Min\+Eigen\+Val@{corner\+Min\+Eigen\+Val}}
\index{corner\+Min\+Eigen\+Val@{corner\+Min\+Eigen\+Val}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{corner\+Min\+Eigen\+Val()}{cornerMinEigenVal()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Min\+Eigen\+Val (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{block\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the minimal eigenvalue of gradient matrices for corner detection.

The function is similar to \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{} but it calculates and stores only the minimal eigenvalue of the covariance matrix of derivatives, that is, {\itshape min(lambda\+\_\+1, lambda\+\_\+2)} in terms of the formulae in the \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{} description.


\begin{DoxyParams}{Parameters}
{\em src} & Input single-\/channel 8-\/bit or floating-\/point image. \\
\hline
{\em dst} & Image to store the minimal eigenvalues. It has the type {\ttfamily C\+V\+\_\+32\+F\+C1} and the same size as {\ttfamily src}. \\
\hline
{\em block\+Size} & Neighborhood size (see the details on \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{}).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornermineigenval}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Min\+Eigen\+Val} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a27d2a87eb126da8ffaf0ef12950a5b48}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a27d2a87eb126da8ffaf0ef12950a5b48}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!corner\+Sub\+Pix@{corner\+Sub\+Pix}}
\index{corner\+Sub\+Pix@{corner\+Sub\+Pix}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{corner\+Sub\+Pix()}{cornerSubPix()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Sub\+Pix (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{corners,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{win\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{zero\+Zone,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}}}]{criteria }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Refines the corner locations.

The function iterates to find the sub-\/pixel accurate location of corners or radial saddle points, as shown on the figure below.

Sub-\/pixel accurate corner locator is based on the observation that every vector from the center {\itshape q} to a point {\itshape p} located within a neighborhood of {\itshape q} is orthogonal to the image gradient at {\itshape p} subject to image and measurement noise. Consider the expression\+:

{\itshape epsilon {\itshape i = (DI}(p\+\_\+i))$^\wedge$T $\ast$ (q -\/ p\+\_\+i)}

where {\itshape (D\+I\+\_\+(p\+\_\+i))} is an image gradient at one of the points {\itshape p\+\_\+i} in a neighborhood of {\itshape q}. The value of {\itshape q} is to be found so that {\itshape epsilon\+\_\+i} is minimized. A system of equations may be set up with {\itshape epsilon\+\_\+i} set to zero\+:

{\itshape sum {\itshape i(DI}(p\+\_\+i) $\ast$ (D\+I\+\_\+(p\+\_\+i))$^\wedge$T) -\/ sum {\itshape i(DI}(p\+\_\+i) $\ast$ (D\+I\+\_\+(p\+\_\+i))$^\wedge$T $\ast$ p\+\_\+i)}

where the gradients are summed within a neighborhood (\char`\"{}search window\char`\"{}) of {\itshape q}. Calling the first gradient term {\itshape G} and the second gradient term {\itshape b} gives\+:

{\itshape q = G$^\wedge$(-\/1) $\ast$ b}

The algorithm sets the center of the neighborhood window at this new center {\itshape q} and then iterates until the center stays within a set threshold.


\begin{DoxyParams}{Parameters}
{\em image} & Input image. \\
\hline
{\em corners} & Initial coordinates of the input corners and refined coordinates provided for output. \\
\hline
{\em win\+Size} & Half of the side length of the search window. For example, if {\ttfamily win\+Size=Size(5,5)}, then a {\itshape 5$\ast$2+1 x 5$\ast$2+1 = 11 x 11} search window is used. \\
\hline
{\em zero\+Zone} & Half of the size of the dead region in the middle of the search zone over which the summation in the formula below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-\/1,-\/1) indicates that there is no such a size. \\
\hline
{\em criteria} & Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after {\ttfamily criteria.\+max\+Count} iterations or when the corner position moves by less than {\ttfamily criteria.\+epsilon} on some iteration.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#cornersubpix}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+corner\+Sub\+Pix} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8953a925c05f058b4b992831fea01eee}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8953a925c05f058b4b992831fea01eee}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!create\+Hanning\+Window@{create\+Hanning\+Window}}
\index{create\+Hanning\+Window@{create\+Hanning\+Window}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{create\+Hanning\+Window()}{createHanningWindow()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+create\+Hanning\+Window (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{win\+Size,  }\item[{int}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This function computes a Hanning window coefficients in two dimensions. See \href{http://en.wikipedia.org/wiki/Hann_function}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Hann\+\_\+function} and \href{http://en.wikipedia.org/wiki/Window_function}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Window\+\_\+function} for more information.

An example is shown below\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // create hanning window of size 100x100 and type C\+V\+\_\+32F}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat hann;}

{\ttfamily }

{\ttfamily }

{\ttfamily create\+Hanning\+Window(hann, Size(100, 100), C\+V\+\_\+32\+F);}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em dst} & Destination array to place Hann coefficients in \\
\hline
{\em win\+Size} & The window size specifications \\
\hline
{\em type} & Created array type\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#createhanningwindow}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+create\+Hanning\+Window} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7b3ed66ff7c6ceb76fb1293177964dd1}{org.\+opencv.\+imgproc.\+Imgproc\+::phase\+Correlate}} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab8fb70fea379b4215a77122d698d860d}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab8fb70fea379b4215a77122d698d860d}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!cvt\+Color@{cvt\+Color}}
\index{cvt\+Color@{cvt\+Color}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{cvt\+Color()}{cvtColor()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+cvt\+Color (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{code,  }\item[{int}]{dst\+Cn }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Converts an image from one color space to another.

The function converts an input image from one color space to another. In case of a transformation to-\/from R\+GB color space, the order of the channels should be specified explicitly (R\+GB or B\+GR). Note that the default color format in Open\+CV is often referred to as R\+GB but it is actually B\+GR (the bytes are reversed). So the first byte in a standard (24-\/bit) color image will be an 8-\/bit Blue component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.

The conventional ranges for \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, G, and B channel values are\+:


\begin{DoxyItemize}
\item 0 to 255 for {\ttfamily C\+V\+\_\+8U} images 
\item 0 to 65535 for {\ttfamily C\+V\+\_\+16U} images 
\item 0 to 1 for {\ttfamily C\+V\+\_\+32F} images 
\end{DoxyItemize}

In case of linear transformations, the range does not matter. But in case of a non-\/linear transformation, an input R\+GB image should be normalized to the proper value range to get the correct results, for example, for R\+GB{\itshape -\/$>$} L$\ast$u$\ast$v$\ast$ transformation. For example, if you have a 32-\/bit floating-\/point image directly converted from an 8-\/bit image without any scaling, then it will have the 0..255 value range instead of 0..1 assumed by the function. So, before calling {\ttfamily cvt\+Color}, you need first to scale the image down\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily img $\ast$= 1./255;}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(img, img, C\+V\+\_\+\+B\+G\+R2\+Luv);}

{\ttfamily }

{\ttfamily }

{\ttfamily If you use {\ttfamily cvt\+Color} with 8-\/bit images, the conversion will have some information lost. For many applications, this will not be noticeable but it is recommended to use 32-\/bit images in applications that need the full range of colors or that convert an image before an operation and then convert back. }

If conversion adds the alpha channel, its value will set to the maximum of corresponding channel range\+: 255 for {\ttfamily C\+V\+\_\+8U}, 65535 for {\ttfamily C\+V\+\_\+16U}, 1 for {\ttfamily C\+V\+\_\+32F}.

The function can do the following transformations\+:


\begin{DoxyItemize}
\item R\+GB {\itshape $<$-\/$>$} G\+R\+AY ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+G\+R\+AY, C\+V\+\_\+\+R\+G\+B2\+G\+R\+AY, C\+V\+\_\+\+G\+R\+A\+Y2\+B\+GR, C\+V\+\_\+\+G\+R\+A\+Y2\+R\+GB}) Transformations within R\+GB space like adding/removing the alpha channel, reversing the channel order, conversion to/from 16-\/bit R\+GB color (R5\+:\+G6\+:B5 or R5\+:\+G5\+:B5), as well as conversion to/from grayscale using\+: 
\end{DoxyItemize}

{\itshape R\+GB\mbox{[}A\mbox{]} to Gray\+: Y $<$-\/ 0.\+299 $\ast$ \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} + 0.\+587 $\ast$ G + 0.\+114 $\ast$ B}

and

{\itshape Gray to R\+GB\mbox{[}A\mbox{]}\+: \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} $<$-\/ Y, G $<$-\/ Y, B $<$-\/ Y, A $<$-\/ max(\+Channel\+Range)}

The conversion from a R\+GB image to gray is done with\+:

{\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(src, bwsrc, C\+V\+\_\+\+R\+G\+B2\+G\+R\+A\+Y);}

{\ttfamily }

{\ttfamily }

{\ttfamily }

More advanced channel reordering can also be done with \char`\"{}mix\+Channels\char`\"{}.


\begin{DoxyItemize}
\item R\+GB {\itshape $<$-\/$>$} C\+IE X\+Y\+Z.\+Rec 709 with D65 white point ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+X\+YZ, C\+V\+\_\+\+R\+G\+B2\+X\+YZ, C\+V\+\_\+\+X\+Y\+Z2\+B\+GR, C\+V\+\_\+\+X\+Y\+Z2\+R\+GB})\+: 
\end{DoxyItemize}

{\itshape X Z lt\+BR gt $<$-\/ 0.\+412453 0.\+357580 0.\+180423 0.\+212671 0.\+715160 0.\+072169 0.\+019334 0.\+119193 0.\+950227 lt\+BR gt $\ast$ \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} B lt\+BR gt}

{\itshape \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} B lt\+BR gt $<$-\/ 3.\+240479 -\/1.\+53715 -\/0.\+498535 -\/0.\+969256 1.\+875991 0.\+041556 0.\+055648 -\/0.\+204043 1.\+057311 lt\+BR gt $\ast$ X Z lt\+BR gt}

{\itshape X}, {\itshape Y} and {\itshape Z} cover the whole value range (in case of floating-\/point images, {\itshape Z} may exceed 1).


\begin{DoxyItemize}
\item R\+GB {\itshape $<$-\/$>$} Y\+Cr\+Cb J\+P\+EG (or Y\+CC) ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+Y\+Cr\+Cb, C\+V\+\_\+\+R\+G\+B2\+Y\+Cr\+Cb, C\+V\+\_\+\+Y\+Cr\+Cb2\+B\+GR, C\+V\+\_\+\+Y\+Cr\+Cb2\+R\+GB}) 
\end{DoxyItemize}

{\itshape Y $<$-\/ 0.\+299 $\ast$ \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} + 0.\+587 $\ast$ G + 0.\+114 $\ast$ B}

{\itshape Cr $<$-\/ (R-\/Y) $\ast$ 0.\+713 + delta}

{\itshape Cb $<$-\/ (B-\/Y) $\ast$ 0.\+564 + delta}

{\itshape \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} $<$-\/ Y + 1.\+403 $\ast$ (Cr -\/ delta)}

{\itshape G $<$-\/ Y -\/ 0.\+714 $\ast$ (Cr -\/ delta) -\/ 0.\+344 $\ast$ (Cb -\/ delta)}

{\itshape B $<$-\/ Y + 1.\+773 $\ast$ (Cb -\/ delta)}

where

{\itshape delta = $<$= ft (128 for 8-\/bit images 32768 for 16-\/bit images 0.\+5 for floating-\/point images right.}

Y, Cr, and Cb cover the whole value range.


\begin{DoxyItemize}
\item R\+GB {\itshape $<$-\/$>$} H\+SV ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+H\+SV, C\+V\+\_\+\+R\+G\+B2\+H\+SV, C\+V\+\_\+\+H\+S\+V2\+B\+GR, C\+V\+\_\+\+H\+S\+V2\+R\+GB}) In case of 8-\/bit and 16-\/bit images, \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, G, and B are converted to the floating-\/point format and scaled to fit the 0 to 1 range. 
\end{DoxyItemize}

{\itshape V $<$-\/ max(\+R,\+G,\+B)}

{\itshape S $<$-\/ (V-\/min(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B))/(V) if V != 0; 0 otherwise}

{\itshape H $<$-\/ (60(G -\/ B))/((V-\/min(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B))) if V=\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}; (120+60(B -\/ \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}))/((V-\/min(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B))) if V=G; (240+60(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} -\/ G))/((V-\/min(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B))) if V=B}

If {\itshape H\&lt0} then {\itshape H $<$-\/ H+360}. On output {\itshape 0 $<$= V $<$= 1}, {\itshape 0 $<$= S $<$= 1}, {\itshape 0 $<$= H $<$= 360}.

The values are then converted to the destination data type\+:


\begin{DoxyItemize}
\item 8-\/bit images 
\end{DoxyItemize}

{\itshape V $<$-\/ 255 V, S $<$-\/ 255 S, H $<$-\/ H/2(to fit to 0 to 255)}


\begin{DoxyItemize}
\item 16-\/bit images (currently not supported) 
\end{DoxyItemize}

{\itshape V \&lt-\/ 65535 V, S \&lt-\/ 65535 S, H \&lt-\/ H}


\begin{DoxyItemize}
\item 32-\/bit images H, S, and V are left as is 
\item R\+GB {\itshape $<$-\/$>$} H\+LS ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+H\+LS, C\+V\+\_\+\+R\+G\+B2\+H\+LS, C\+V\+\_\+\+H\+L\+S2\+B\+GR, C\+V\+\_\+\+H\+L\+S2\+R\+GB}). 
\end{DoxyItemize}

In case of 8-\/bit and 16-\/bit images, \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, G, and B are converted to the floating-\/point format and scaled to fit the 0 to 1 range.

{\itshape V\+\_\+(max) $<$-\/ (max)(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B)}

{\itshape V\+\_\+(min) $<$-\/ (min)(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B)}

{\itshape L $<$-\/ (V\+\_\+(max) + V\+\_\+(min))/2}

{\itshape S $<$-\/ fork ((V\+\_\+(max) -\/ V\+\_\+(min))/(V\+\_\+(max) + V\+\_\+(min)))(if L \&lt 0.\+5)\&lt\+BR\&gt((V\+\_\+(max) -\/ V\+\_\+(min))/(2 -\/ (V\+\_\+(max) + V\+\_\+(min))))(if L $>$= 0.\+5)}

{\itshape H $<$-\/ forkthree ((60(G -\/ B))/(S))(if V\+\_\+(max)=\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}})\&lt\+BR\&gt((120+60(B -\/ \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}))/(S))(if V\+\_\+(max)=G)\&lt\+BR\&gt((240+60(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} -\/ G))/(S))(if V\+\_\+(max)=B)}

If {\itshape H\&lt0} then {\itshape H $<$-\/ H+360}. On output {\itshape 0 $<$= L $<$= 1}, {\itshape 0 $<$= S $<$= 1}, {\itshape 0 $<$= H $<$= 360}.

The values are then converted to the destination data type\+:


\begin{DoxyItemize}
\item 8-\/bit images 
\end{DoxyItemize}

{\itshape V $<$-\/ 255 $\ast$ V, S $<$-\/ 255 $\ast$ S, H $<$-\/ H/2(to fit to 0 to 255)}


\begin{DoxyItemize}
\item 16-\/bit images (currently not supported) 
\end{DoxyItemize}

{\itshape V \&lt-\/ 65535 $\ast$ V, S \&lt-\/ 65535 $\ast$ S, H \&lt-\/ H}


\begin{DoxyItemize}
\item 32-\/bit images H, S, V are left as is 
\item R\+GB {\itshape $<$-\/$>$} C\+IE L$\ast$a$\ast$b$\ast$ ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+Lab, C\+V\+\_\+\+R\+G\+B2\+Lab, C\+V\+\_\+\+Lab2\+B\+GR, C\+V\+\_\+\+Lab2\+R\+GB}). 
\end{DoxyItemize}

In case of 8-\/bit and 16-\/bit images, \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, G, and B are converted to the floating-\/point format and scaled to fit the 0 to 1 range.

{\itshape \mbox{[}X Y Z\mbox{]} $<$-\/ $\vert$0.412453 0.\+357580 0.\+180423$\vert$ $\vert$0.212671 0.\+715160 0.\+072169$\vert$ $\vert$0.019334 0.\+119193 0.\+950227$\vert$}

{\itshape  
\begin{DoxyItemize}
\item \mbox{[}\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} G B\mbox{]}


\end{DoxyItemize}}

{\itshape }

{\itshape {\itshape X $<$-\/ X/\+X\+\_\+n, where X\+\_\+n = 0.\+950456}}

{\itshape }

{\itshape }

{\itshape {\itshape Z $<$-\/ Z/\+Z\+\_\+n, where Z\+\_\+n = 1.\+088754}}

{\itshape }

{\itshape }

{\itshape {\itshape L $<$-\/ 116$\ast$\+Y$^\wedge$(1/3)-\/16 for Y\&gt0.\+008856; 903.\+3$\ast$Y for Y $<$= 0.\+008856}}

{\itshape }

{\itshape }

{\itshape {\itshape a $<$-\/ 500(f(\+X)-\/f(Y)) + delta}}

{\itshape }

{\itshape }

{\itshape {\itshape b $<$-\/ 200(f(\+Y)-\/f(Z)) + delta}}

{\itshape }

{\itshape }

{\itshape where}

{\itshape }

{\itshape }

{\itshape {\itshape f(t)= t$^\wedge$(1/3) for t\&gt0.\+008856; 7.\+787 t+16/116 for t $<$= 0.\+008856}}

{\itshape }

{\itshape }

{\itshape and}

{\itshape }

{\itshape }

{\itshape {\itshape delta = 128 for 8-\/bit images; 0 for floating-\/point images}}

{\itshape }

{\itshape }

{\itshape This outputs {\itshape 0 $<$= L $<$= 100}, {\itshape -\/127 $<$= a $<$= 127}, {\itshape -\/127 $<$= b $<$= 127}. The values are then converted to the destination data type\+:}

{\itshape  
\begin{DoxyItemize}
\item 8-\/bit images 
\end{DoxyItemize}}

{\itshape }

{\itshape {\itshape L $<$-\/ L$\ast$255/100, a $<$-\/ a + 128, b $<$-\/ b + 128}}

{\itshape }

{\itshape 
\begin{DoxyItemize}
\item 16-\/bit images (currently not supported) 
\item 32-\/bit images L, a, and b are left as is 
\item R\+GB {\itshape $<$-\/$>$} C\+IE L$\ast$u$\ast$v$\ast$ ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+Luv, C\+V\+\_\+\+R\+G\+B2\+Luv, C\+V\+\_\+\+Luv2\+B\+GR, C\+V\+\_\+\+Luv2\+R\+GB}). 
\end{DoxyItemize}}

{\itshape In case of 8-\/bit and 16-\/bit images, \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, G, and B are converted to the floating-\/point format and scaled to fit 0 to 1 range.}

{\itshape }

{\itshape }

{\itshape {\itshape \mbox{[}X Y Z\mbox{]} $<$-\/ $\vert$0.412453 0.\+357580 0.\+180423$\vert$ $\vert$0.212671 0.\+715160 0.\+072169$\vert$ $\vert$0.019334 0.\+119193 0.\+950227$\vert$}}

{\itshape {\itshape  
\begin{DoxyItemize}
\item \mbox{[}\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} G B\mbox{]}


\end{DoxyItemize}}}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape L $<$-\/ 116 Y$^\wedge$(1/3) for Y\&gt0.\+008856; 903.\+3 Y for Y $<$= 0.\+008856}}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape u\textquotesingle{} $<$-\/ 4$\ast$\+X/(X + 15$\ast$Y + 3 Z)}}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape v\textquotesingle{} $<$-\/ 9$\ast$\+Y/(X + 15$\ast$Y + 3 Z)}}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape u $<$-\/ 13$\ast$\+L$\ast$(u\textquotesingle{} -\/ u\+\_\+n) where u\+\_\+n=0.\+19793943}}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape v $<$-\/ 13$\ast$\+L$\ast$(v\textquotesingle{} -\/ v\+\_\+n) where v\+\_\+n=0.\+46831096}}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape This outputs {\itshape 0 $<$= L $<$= 100}, {\itshape -\/134 $<$= u $<$= 220}, {\itshape -\/140 $<$= v $<$= 122}.}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape The values are then converted to the destination data type\+:}}

{\itshape {\itshape  
\begin{DoxyItemize}
\item 8-\/bit images 
\end{DoxyItemize}}}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape L $<$-\/ 255/100 L, u $<$-\/ 255/354(u + 134), v $<$-\/ 255/256(v + 140)}}}

{\itshape {\itshape }}

{\itshape {\itshape 
\begin{DoxyItemize}
\item 16-\/bit images (currently not supported) 
\item 32-\/bit images L, u, and v are left as is 
\end{DoxyItemize}}}

{\itshape {\itshape }}

{\itshape {\itshape The above formulae for converting R\+GB to/from various color spaces have been taken from multiple sources on the web, primarily from the Charles Poynton site \href{http://www.poynton.com/ColorFAQ.html}{\tt http\+://www.\+poynton.\+com/\+Color\+F\+A\+Q.\+html}}}

{\itshape {\itshape  
\begin{DoxyItemize}
\item Bayer {\itshape -\/$>$} R\+GB ({\ttfamily C\+V\+\_\+\+Bayer\+B\+G2\+B\+GR, C\+V\+\_\+\+Bayer\+G\+B2\+B\+GR, C\+V\+\_\+\+Bayer\+R\+G2\+B\+GR, C\+V\+\_\+\+Bayer\+G\+R2\+B\+GR, C\+V\+\_\+\+Bayer\+B\+G2\+R\+GB, C\+V\+\_\+\+Bayer\+G\+B2\+R\+GB, C\+V\+\_\+\+Bayer\+R\+G2\+R\+GB, C\+V\+\_\+\+Bayer\+G\+R2\+R\+GB}). The Bayer pattern is widely used in C\+CD and C\+M\+OS cameras. It enables you to get color pictures from a single plane where \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G, and B pixels (sensors of a particular component) are interleaved as follows\+: The output R\+GB components of a pixel are interpolated from 1, 2, or {\ttfamily  }
\end{DoxyItemize}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily // C++ code\+:}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily 4 neighbors of the pixel having the same color. There are several}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily modifications of the above pattern that can be achieved by shifting}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily the pattern one pixel left and/or one pixel up. The two letters}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily {\itshape C\+\_\+1} and}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily {\itshape C\+\_\+2} in the conversion constants {\ttfamily C\+V\+\_\+\+Bayer} {\itshape C\+\_\+1 C\+\_\+2} {\ttfamily 2\+B\+GR} and {\ttfamily C\+V\+\_\+\+Bayer} {\itshape C\+\_\+1 C\+\_\+2} {\ttfamily 2\+R\+GB} indicate the particular pattern}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily type. These are components from the second row, second and third}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily columns, respectively. For example, the above pattern has a very}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily popular \char`\"{}\+B\+G\char`\"{} type.}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily 
\begin{DoxyParams}{Parameters}
{\em src} & input image\+: 8-\/bit unsigned, 16-\/bit unsigned ({\ttfamily C\+V\+\_\+16\+UC...}), or single-\/precision floating-\/point. \\
\hline
{\em dst} & output image of the same size and depth as {\ttfamily src}. \\
\hline
{\em code} & color space conversion code (see the description below). \\
\hline
{\em dst\+Cn} & number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from {\ttfamily src} and {\ttfamily code}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#cvtcolor}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+cvt\+Color} 
\end{DoxySeeAlso}
}}}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac8a27791c4cc1d1739464acafa3efff6}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac8a27791c4cc1d1739464acafa3efff6}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!cvt\+Color@{cvt\+Color}}
\index{cvt\+Color@{cvt\+Color}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{cvt\+Color()}{cvtColor()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+cvt\+Color (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{code }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Converts an image from one color space to another.

The function converts an input image from one color space to another. In case of a transformation to-\/from R\+GB color space, the order of the channels should be specified explicitly (R\+GB or B\+GR). Note that the default color format in Open\+CV is often referred to as R\+GB but it is actually B\+GR (the bytes are reversed). So the first byte in a standard (24-\/bit) color image will be an 8-\/bit Blue component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.

The conventional ranges for \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, G, and B channel values are\+:


\begin{DoxyItemize}
\item 0 to 255 for {\ttfamily C\+V\+\_\+8U} images 
\item 0 to 65535 for {\ttfamily C\+V\+\_\+16U} images 
\item 0 to 1 for {\ttfamily C\+V\+\_\+32F} images 
\end{DoxyItemize}

In case of linear transformations, the range does not matter. But in case of a non-\/linear transformation, an input R\+GB image should be normalized to the proper value range to get the correct results, for example, for R\+GB{\itshape -\/$>$} L$\ast$u$\ast$v$\ast$ transformation. For example, if you have a 32-\/bit floating-\/point image directly converted from an 8-\/bit image without any scaling, then it will have the 0..255 value range instead of 0..1 assumed by the function. So, before calling {\ttfamily cvt\+Color}, you need first to scale the image down\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily img $\ast$= 1./255;}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(img, img, C\+V\+\_\+\+B\+G\+R2\+Luv);}

{\ttfamily }

{\ttfamily }

{\ttfamily If you use {\ttfamily cvt\+Color} with 8-\/bit images, the conversion will have some information lost. For many applications, this will not be noticeable but it is recommended to use 32-\/bit images in applications that need the full range of colors or that convert an image before an operation and then convert back. }

If conversion adds the alpha channel, its value will set to the maximum of corresponding channel range\+: 255 for {\ttfamily C\+V\+\_\+8U}, 65535 for {\ttfamily C\+V\+\_\+16U}, 1 for {\ttfamily C\+V\+\_\+32F}.

The function can do the following transformations\+:


\begin{DoxyItemize}
\item R\+GB {\itshape $<$-\/$>$} G\+R\+AY ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+G\+R\+AY, C\+V\+\_\+\+R\+G\+B2\+G\+R\+AY, C\+V\+\_\+\+G\+R\+A\+Y2\+B\+GR, C\+V\+\_\+\+G\+R\+A\+Y2\+R\+GB}) Transformations within R\+GB space like adding/removing the alpha channel, reversing the channel order, conversion to/from 16-\/bit R\+GB color (R5\+:\+G6\+:B5 or R5\+:\+G5\+:B5), as well as conversion to/from grayscale using\+: 
\end{DoxyItemize}

{\itshape R\+GB\mbox{[}A\mbox{]} to Gray\+: Y $<$-\/ 0.\+299 $\ast$ \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} + 0.\+587 $\ast$ G + 0.\+114 $\ast$ B}

and

{\itshape Gray to R\+GB\mbox{[}A\mbox{]}\+: \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} $<$-\/ Y, G $<$-\/ Y, B $<$-\/ Y, A $<$-\/ max(\+Channel\+Range)}

The conversion from a R\+GB image to gray is done with\+:

{\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(src, bwsrc, C\+V\+\_\+\+R\+G\+B2\+G\+R\+A\+Y);}

{\ttfamily }

{\ttfamily }

{\ttfamily }

More advanced channel reordering can also be done with \char`\"{}mix\+Channels\char`\"{}.


\begin{DoxyItemize}
\item R\+GB {\itshape $<$-\/$>$} C\+IE X\+Y\+Z.\+Rec 709 with D65 white point ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+X\+YZ, C\+V\+\_\+\+R\+G\+B2\+X\+YZ, C\+V\+\_\+\+X\+Y\+Z2\+B\+GR, C\+V\+\_\+\+X\+Y\+Z2\+R\+GB})\+: 
\end{DoxyItemize}

{\itshape X Z lt\+BR gt $<$-\/ 0.\+412453 0.\+357580 0.\+180423 0.\+212671 0.\+715160 0.\+072169 0.\+019334 0.\+119193 0.\+950227 lt\+BR gt $\ast$ \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} B lt\+BR gt}

{\itshape \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} B lt\+BR gt $<$-\/ 3.\+240479 -\/1.\+53715 -\/0.\+498535 -\/0.\+969256 1.\+875991 0.\+041556 0.\+055648 -\/0.\+204043 1.\+057311 lt\+BR gt $\ast$ X Z lt\+BR gt}

{\itshape X}, {\itshape Y} and {\itshape Z} cover the whole value range (in case of floating-\/point images, {\itshape Z} may exceed 1).


\begin{DoxyItemize}
\item R\+GB {\itshape $<$-\/$>$} Y\+Cr\+Cb J\+P\+EG (or Y\+CC) ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+Y\+Cr\+Cb, C\+V\+\_\+\+R\+G\+B2\+Y\+Cr\+Cb, C\+V\+\_\+\+Y\+Cr\+Cb2\+B\+GR, C\+V\+\_\+\+Y\+Cr\+Cb2\+R\+GB}) 
\end{DoxyItemize}

{\itshape Y $<$-\/ 0.\+299 $\ast$ \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} + 0.\+587 $\ast$ G + 0.\+114 $\ast$ B}

{\itshape Cr $<$-\/ (R-\/Y) $\ast$ 0.\+713 + delta}

{\itshape Cb $<$-\/ (B-\/Y) $\ast$ 0.\+564 + delta}

{\itshape \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} $<$-\/ Y + 1.\+403 $\ast$ (Cr -\/ delta)}

{\itshape G $<$-\/ Y -\/ 0.\+714 $\ast$ (Cr -\/ delta) -\/ 0.\+344 $\ast$ (Cb -\/ delta)}

{\itshape B $<$-\/ Y + 1.\+773 $\ast$ (Cb -\/ delta)}

where

{\itshape delta = $<$= ft (128 for 8-\/bit images 32768 for 16-\/bit images 0.\+5 for floating-\/point images right.}

Y, Cr, and Cb cover the whole value range.


\begin{DoxyItemize}
\item R\+GB {\itshape $<$-\/$>$} H\+SV ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+H\+SV, C\+V\+\_\+\+R\+G\+B2\+H\+SV, C\+V\+\_\+\+H\+S\+V2\+B\+GR, C\+V\+\_\+\+H\+S\+V2\+R\+GB}) In case of 8-\/bit and 16-\/bit images, \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, G, and B are converted to the floating-\/point format and scaled to fit the 0 to 1 range. 
\end{DoxyItemize}

{\itshape V $<$-\/ max(\+R,\+G,\+B)}

{\itshape S $<$-\/ (V-\/min(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B))/(V) if V != 0; 0 otherwise}

{\itshape H $<$-\/ (60(G -\/ B))/((V-\/min(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B))) if V=\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}; (120+60(B -\/ \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}))/((V-\/min(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B))) if V=G; (240+60(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} -\/ G))/((V-\/min(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B))) if V=B}

If {\itshape H\&lt0} then {\itshape H $<$-\/ H+360}. On output {\itshape 0 $<$= V $<$= 1}, {\itshape 0 $<$= S $<$= 1}, {\itshape 0 $<$= H $<$= 360}.

The values are then converted to the destination data type\+:


\begin{DoxyItemize}
\item 8-\/bit images 
\end{DoxyItemize}

{\itshape V $<$-\/ 255 V, S $<$-\/ 255 S, H $<$-\/ H/2(to fit to 0 to 255)}


\begin{DoxyItemize}
\item 16-\/bit images (currently not supported) 
\end{DoxyItemize}

{\itshape V \&lt-\/ 65535 V, S \&lt-\/ 65535 S, H \&lt-\/ H}


\begin{DoxyItemize}
\item 32-\/bit images H, S, and V are left as is 
\item R\+GB {\itshape $<$-\/$>$} H\+LS ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+H\+LS, C\+V\+\_\+\+R\+G\+B2\+H\+LS, C\+V\+\_\+\+H\+L\+S2\+B\+GR, C\+V\+\_\+\+H\+L\+S2\+R\+GB}). 
\end{DoxyItemize}

In case of 8-\/bit and 16-\/bit images, \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, G, and B are converted to the floating-\/point format and scaled to fit the 0 to 1 range.

{\itshape V\+\_\+(max) $<$-\/ (max)(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B)}

{\itshape V\+\_\+(min) $<$-\/ (min)(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B)}

{\itshape L $<$-\/ (V\+\_\+(max) + V\+\_\+(min))/2}

{\itshape S $<$-\/ fork ((V\+\_\+(max) -\/ V\+\_\+(min))/(V\+\_\+(max) + V\+\_\+(min)))(if L \&lt 0.\+5)\&lt\+BR\&gt((V\+\_\+(max) -\/ V\+\_\+(min))/(2 -\/ (V\+\_\+(max) + V\+\_\+(min))))(if L $>$= 0.\+5)}

{\itshape H $<$-\/ forkthree ((60(G -\/ B))/(S))(if V\+\_\+(max)=\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}})\&lt\+BR\&gt((120+60(B -\/ \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}))/(S))(if V\+\_\+(max)=G)\&lt\+BR\&gt((240+60(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} -\/ G))/(S))(if V\+\_\+(max)=B)}

If {\itshape H\&lt0} then {\itshape H $<$-\/ H+360}. On output {\itshape 0 $<$= L $<$= 1}, {\itshape 0 $<$= S $<$= 1}, {\itshape 0 $<$= H $<$= 360}.

The values are then converted to the destination data type\+:


\begin{DoxyItemize}
\item 8-\/bit images 
\end{DoxyItemize}

{\itshape V $<$-\/ 255 $\ast$ V, S $<$-\/ 255 $\ast$ S, H $<$-\/ H/2(to fit to 0 to 255)}


\begin{DoxyItemize}
\item 16-\/bit images (currently not supported) 
\end{DoxyItemize}

{\itshape V \&lt-\/ 65535 $\ast$ V, S \&lt-\/ 65535 $\ast$ S, H \&lt-\/ H}


\begin{DoxyItemize}
\item 32-\/bit images H, S, V are left as is 
\item R\+GB {\itshape $<$-\/$>$} C\+IE L$\ast$a$\ast$b$\ast$ ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+Lab, C\+V\+\_\+\+R\+G\+B2\+Lab, C\+V\+\_\+\+Lab2\+B\+GR, C\+V\+\_\+\+Lab2\+R\+GB}). 
\end{DoxyItemize}

In case of 8-\/bit and 16-\/bit images, \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, G, and B are converted to the floating-\/point format and scaled to fit the 0 to 1 range.

{\itshape \mbox{[}X Y Z\mbox{]} $<$-\/ $\vert$0.412453 0.\+357580 0.\+180423$\vert$ $\vert$0.212671 0.\+715160 0.\+072169$\vert$ $\vert$0.019334 0.\+119193 0.\+950227$\vert$}

{\itshape  
\begin{DoxyItemize}
\item \mbox{[}\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} G B\mbox{]}


\end{DoxyItemize}}

{\itshape }

{\itshape {\itshape X $<$-\/ X/\+X\+\_\+n, where X\+\_\+n = 0.\+950456}}

{\itshape }

{\itshape }

{\itshape {\itshape Z $<$-\/ Z/\+Z\+\_\+n, where Z\+\_\+n = 1.\+088754}}

{\itshape }

{\itshape }

{\itshape {\itshape L $<$-\/ 116$\ast$\+Y$^\wedge$(1/3)-\/16 for Y\&gt0.\+008856; 903.\+3$\ast$Y for Y $<$= 0.\+008856}}

{\itshape }

{\itshape }

{\itshape {\itshape a $<$-\/ 500(f(\+X)-\/f(Y)) + delta}}

{\itshape }

{\itshape }

{\itshape {\itshape b $<$-\/ 200(f(\+Y)-\/f(Z)) + delta}}

{\itshape }

{\itshape }

{\itshape where}

{\itshape }

{\itshape }

{\itshape {\itshape f(t)= t$^\wedge$(1/3) for t\&gt0.\+008856; 7.\+787 t+16/116 for t $<$= 0.\+008856}}

{\itshape }

{\itshape }

{\itshape and}

{\itshape }

{\itshape }

{\itshape {\itshape delta = 128 for 8-\/bit images; 0 for floating-\/point images}}

{\itshape }

{\itshape }

{\itshape This outputs {\itshape 0 $<$= L $<$= 100}, {\itshape -\/127 $<$= a $<$= 127}, {\itshape -\/127 $<$= b $<$= 127}. The values are then converted to the destination data type\+:}

{\itshape  
\begin{DoxyItemize}
\item 8-\/bit images 
\end{DoxyItemize}}

{\itshape }

{\itshape {\itshape L $<$-\/ L$\ast$255/100, a $<$-\/ a + 128, b $<$-\/ b + 128}}

{\itshape }

{\itshape 
\begin{DoxyItemize}
\item 16-\/bit images (currently not supported) 
\item 32-\/bit images L, a, and b are left as is 
\item R\+GB {\itshape $<$-\/$>$} C\+IE L$\ast$u$\ast$v$\ast$ ({\ttfamily C\+V\+\_\+\+B\+G\+R2\+Luv, C\+V\+\_\+\+R\+G\+B2\+Luv, C\+V\+\_\+\+Luv2\+B\+GR, C\+V\+\_\+\+Luv2\+R\+GB}). 
\end{DoxyItemize}}

{\itshape In case of 8-\/bit and 16-\/bit images, \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}, G, and B are converted to the floating-\/point format and scaled to fit 0 to 1 range.}

{\itshape }

{\itshape }

{\itshape {\itshape \mbox{[}X Y Z\mbox{]} $<$-\/ $\vert$0.412453 0.\+357580 0.\+180423$\vert$ $\vert$0.212671 0.\+715160 0.\+072169$\vert$ $\vert$0.019334 0.\+119193 0.\+950227$\vert$}}

{\itshape {\itshape  
\begin{DoxyItemize}
\item \mbox{[}\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} G B\mbox{]}


\end{DoxyItemize}}}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape L $<$-\/ 116 Y$^\wedge$(1/3) for Y\&gt0.\+008856; 903.\+3 Y for Y $<$= 0.\+008856}}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape u\textquotesingle{} $<$-\/ 4$\ast$\+X/(X + 15$\ast$Y + 3 Z)}}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape v\textquotesingle{} $<$-\/ 9$\ast$\+Y/(X + 15$\ast$Y + 3 Z)}}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape u $<$-\/ 13$\ast$\+L$\ast$(u\textquotesingle{} -\/ u\+\_\+n) where u\+\_\+n=0.\+19793943}}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape v $<$-\/ 13$\ast$\+L$\ast$(v\textquotesingle{} -\/ v\+\_\+n) where v\+\_\+n=0.\+46831096}}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape This outputs {\itshape 0 $<$= L $<$= 100}, {\itshape -\/134 $<$= u $<$= 220}, {\itshape -\/140 $<$= v $<$= 122}.}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape The values are then converted to the destination data type\+:}}

{\itshape {\itshape  
\begin{DoxyItemize}
\item 8-\/bit images 
\end{DoxyItemize}}}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape L $<$-\/ 255/100 L, u $<$-\/ 255/354(u + 134), v $<$-\/ 255/256(v + 140)}}}

{\itshape {\itshape }}

{\itshape {\itshape 
\begin{DoxyItemize}
\item 16-\/bit images (currently not supported) 
\item 32-\/bit images L, u, and v are left as is 
\end{DoxyItemize}}}

{\itshape {\itshape }}

{\itshape {\itshape The above formulae for converting R\+GB to/from various color spaces have been taken from multiple sources on the web, primarily from the Charles Poynton site \href{http://www.poynton.com/ColorFAQ.html}{\tt http\+://www.\+poynton.\+com/\+Color\+F\+A\+Q.\+html}}}

{\itshape {\itshape  
\begin{DoxyItemize}
\item Bayer {\itshape -\/$>$} R\+GB ({\ttfamily C\+V\+\_\+\+Bayer\+B\+G2\+B\+GR, C\+V\+\_\+\+Bayer\+G\+B2\+B\+GR, C\+V\+\_\+\+Bayer\+R\+G2\+B\+GR, C\+V\+\_\+\+Bayer\+G\+R2\+B\+GR, C\+V\+\_\+\+Bayer\+B\+G2\+R\+GB, C\+V\+\_\+\+Bayer\+G\+B2\+R\+GB, C\+V\+\_\+\+Bayer\+R\+G2\+R\+GB, C\+V\+\_\+\+Bayer\+G\+R2\+R\+GB}). The Bayer pattern is widely used in C\+CD and C\+M\+OS cameras. It enables you to get color pictures from a single plane where \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G, and B pixels (sensors of a particular component) are interleaved as follows\+: The output R\+GB components of a pixel are interpolated from 1, 2, or {\ttfamily  }
\end{DoxyItemize}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily // C++ code\+:}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily 4 neighbors of the pixel having the same color. There are several}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily modifications of the above pattern that can be achieved by shifting}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily the pattern one pixel left and/or one pixel up. The two letters}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily {\itshape C\+\_\+1} and}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily {\itshape C\+\_\+2} in the conversion constants {\ttfamily C\+V\+\_\+\+Bayer} {\itshape C\+\_\+1 C\+\_\+2} {\ttfamily 2\+B\+GR} and {\ttfamily C\+V\+\_\+\+Bayer} {\itshape C\+\_\+1 C\+\_\+2} {\ttfamily 2\+R\+GB} indicate the particular pattern}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily type. These are components from the second row, second and third}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily columns, respectively. For example, the above pattern has a very}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily popular \char`\"{}\+B\+G\char`\"{} type.}}}

{\itshape {\itshape {\ttfamily }}}

{\itshape {\itshape {\ttfamily 
\begin{DoxyParams}{Parameters}
{\em src} & input image\+: 8-\/bit unsigned, 16-\/bit unsigned ({\ttfamily C\+V\+\_\+16\+UC...}), or single-\/precision floating-\/point. \\
\hline
{\em dst} & output image of the same size and depth as {\ttfamily src}. \\
\hline
{\em code} & color space conversion code (see the description below).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#cvtcolor}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+cvt\+Color} 
\end{DoxySeeAlso}
}}}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7ed226f2562750987d756b129d3820b2}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7ed226f2562750987d756b129d3820b2}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!dilate@{dilate}}
\index{dilate@{dilate}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{dilate()}{dilate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+dilate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{int}]{iterations,  }\item[{int}]{border\+Type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{border\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Dilates an image by using a specific structuring element.

The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken\+:

{\itshape dst(x,y) = max \+\_\+((x\textquotesingle{},y\textquotesingle{})\+: element(x\textquotesingle{},y\textquotesingle{}) != 0) src(x+x\textquotesingle{},y+y\textquotesingle{})}

The function supports the in-\/place mode. Dilation can be applied several ({\ttfamily iterations}) times. In case of multi-\/channel images, each channel is processed independently.

Note\+:


\begin{DoxyItemize}
\item An example using the morphological dilate operation can be found at opencv\+\_\+source\+\_\+code/samples/cpp/morphology2.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input image; the number of channels can be arbitrary, but the depth should be one of {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F\char`\"{} or $<$/code$>$\+C\+V\+\_\+64\+F\char`\"{}. }\\
\hline
{\em dst} & {\ttfamily output image of the same size and type as {\ttfamily src}. }\\
\hline
{\em kernel} & {\ttfamily a kernel }\\
\hline
{\em anchor} & {\ttfamily position of the anchor within the element; default value {\ttfamily (-\/1, -\/1)} means that the anchor is at the element center. }\\
\hline
{\em iterations} & {\ttfamily number of times dilation is applied. }\\
\hline
{\em border\+Type} & {\ttfamily pixel extrapolation method (see \char`\"{}border\+Interpolate\char`\"{} for details). }\\
\hline
{\em border\+Value} & {\ttfamily border value in case of a constant border (see \char`\"{}create\+Morphology\+Filter\char`\"{} for details).}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
{\ttfamily  \href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#dilate}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+dilate} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_addf44b4eae2f6a52e93c1018cdb07ddc}{org.\+opencv.\+imgproc.\+Imgproc\+::erode}} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a72708dff026d005db5a9534c9b2b4aae}{org.\+opencv.\+imgproc.\+Imgproc\+::morphology\+Ex}} }
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8f79b910d1d1066ca305b6d1fd86daf0}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8f79b910d1d1066ca305b6d1fd86daf0}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!dilate@{dilate}}
\index{dilate@{dilate}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{dilate()}{dilate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+dilate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{int}]{iterations }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Dilates an image by using a specific structuring element.

The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken\+:

{\itshape dst(x,y) = max \+\_\+((x\textquotesingle{},y\textquotesingle{})\+: element(x\textquotesingle{},y\textquotesingle{}) != 0) src(x+x\textquotesingle{},y+y\textquotesingle{})}

The function supports the in-\/place mode. Dilation can be applied several ({\ttfamily iterations}) times. In case of multi-\/channel images, each channel is processed independently.

Note\+:


\begin{DoxyItemize}
\item An example using the morphological dilate operation can be found at opencv\+\_\+source\+\_\+code/samples/cpp/morphology2.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input image; the number of channels can be arbitrary, but the depth should be one of {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F\char`\"{} or $<$/code$>$\+C\+V\+\_\+64\+F\char`\"{}. }\\
\hline
{\em dst} & {\ttfamily output image of the same size and type as {\ttfamily src}. }\\
\hline
{\em kernel} & {\ttfamily a kernel }\\
\hline
{\em anchor} & {\ttfamily position of the anchor within the element; default value {\ttfamily (-\/1, -\/1)} means that the anchor is at the element center. }\\
\hline
{\em iterations} & {\ttfamily number of times dilation is applied.}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
{\ttfamily  \href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#dilate}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+dilate} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_addf44b4eae2f6a52e93c1018cdb07ddc}{org.\+opencv.\+imgproc.\+Imgproc\+::erode}} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a72708dff026d005db5a9534c9b2b4aae}{org.\+opencv.\+imgproc.\+Imgproc\+::morphology\+Ex}} }
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a596d70c952e5431f7703dc4e17eccf94}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a596d70c952e5431f7703dc4e17eccf94}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!dilate@{dilate}}
\index{dilate@{dilate}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{dilate()}{dilate()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+dilate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Dilates an image by using a specific structuring element.

The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken\+:

{\itshape dst(x,y) = max \+\_\+((x\textquotesingle{},y\textquotesingle{})\+: element(x\textquotesingle{},y\textquotesingle{}) != 0) src(x+x\textquotesingle{},y+y\textquotesingle{})}

The function supports the in-\/place mode. Dilation can be applied several ({\ttfamily iterations}) times. In case of multi-\/channel images, each channel is processed independently.

Note\+:


\begin{DoxyItemize}
\item An example using the morphological dilate operation can be found at opencv\+\_\+source\+\_\+code/samples/cpp/morphology2.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input image; the number of channels can be arbitrary, but the depth should be one of {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F\char`\"{} or $<$/code$>$\+C\+V\+\_\+64\+F\char`\"{}. }\\
\hline
{\em dst} & {\ttfamily output image of the same size and type as {\ttfamily src}. }\\
\hline
{\em kernel} & {\ttfamily a kernel}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
{\ttfamily  \href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#dilate}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+dilate} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_addf44b4eae2f6a52e93c1018cdb07ddc}{org.\+opencv.\+imgproc.\+Imgproc\+::erode}} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a72708dff026d005db5a9534c9b2b4aae}{org.\+opencv.\+imgproc.\+Imgproc\+::morphology\+Ex}} }
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2677a973693b8af87cf9c37e4e6bb55b}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2677a973693b8af87cf9c37e4e6bb55b}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!distance\+Transform@{distance\+Transform}}
\index{distance\+Transform@{distance\+Transform}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{distance\+Transform()}{distanceTransform()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+distance\+Transform (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{distance\+Type,  }\item[{int}]{mask\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the distance to the closest zero pixel for each pixel of the source image.

The functions {\ttfamily distance\+Transform} calculate the approximate or precise distance from every binary image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.

When {\ttfamily mask\+Size == C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+M\+A\+S\+K\+\_\+\+P\+R\+E\+C\+I\+SE} and {\ttfamily distance\+Type == C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, the function runs the algorithm described in \mbox{[}Felzenszwalb04\mbox{]}. This algorithm is parallelized with the T\+BB library.

In other cases, the algorithm \mbox{[}Borgefors86\mbox{]} is used. This means that for a pixel the function finds the shortest path to the nearest zero pixel consisting of basic shifts\+: horizontal, vertical, diagonal, or knight\textquotesingle{}s move (the latest is available for a {\itshape 5x 5} mask). The overall distance is calculated as a sum of these basic distances. Since the distance function should be symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as {\ttfamily a}), all the diagonal shifts must have the same cost (denoted as {\ttfamily b}), and all knight\textquotesingle{}s moves must have the same cost (denoted as {\ttfamily c}). For the {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C} and {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1} types, the distance is calculated precisely, whereas for {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2} (Euclidean distance) the distance can be calculated only with a relative error (a {\itshape 5x 5} mask gives more accurate results). For {\ttfamily a},{\ttfamily b}, and {\ttfamily c}, Open\+CV uses the values suggested in the original paper\+:

============== =================== ====================== {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C} {\itshape (3x 3)} a = 1, b = 1 \textbackslash{} ============== =================== ====================== {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1} {\itshape (3x 3)} a = 1, b = 2 \textbackslash{} {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2} {\itshape (3x 3)} a=0.\+955, b=1.\+3693 \textbackslash{} {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2} {\itshape (5x 5)} a=1, b=1.\+4, c=2.\+1969 \textbackslash{} ============== =================== ======================

Typically, for a fast, coarse distance estimation {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, a {\itshape 3x 3} mask is used. For a more accurate distance estimation {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, a {\itshape 5x 5} mask or the precise algorithm is used. Note that both the precise and the approximate algorithms are linear on the number of pixels.

The second variant of the function does not only compute the minimum distance for each pixel {\itshape (x, y)} but also identifies the nearest connected component consisting of zero pixels ({\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+C\+C\+O\+MP}) or the nearest zero pixel ({\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+P\+I\+X\+EL}). Index of the component/pixel is stored in {\itshape labels(x, y)}. When {\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+C\+C\+O\+MP}, the function automatically finds connected components of zero pixels in the input image and marks them with distinct labels. When {\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+C\+C\+O\+MP}, the function scans through the input image and marks all the zero pixels with distinct labels.

In this mode, the complexity is still linear. That is, the function provides a very fast way to compute the Voronoi diagram for a binary image. Currently, the second variant can use only the approximate distance transform algorithm, i.\+e. {\ttfamily mask\+Size=C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+M\+A\+S\+K\+\_\+\+P\+R\+E\+C\+I\+SE} is not supported yet.

Note\+:


\begin{DoxyItemize}
\item An example on using the distance transform can be found at opencv\+\_\+source\+\_\+code/samples/cpp/distrans.\+cpp 
\item (Python) An example on using the distance transform can be found at opencv\+\_\+source/samples/python2/distrans.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & 8-\/bit, single-\/channel (binary) source image. \\
\hline
{\em dst} & Output image with calculated distances. It is a 32-\/bit floating-\/point, single-\/channel image of the same size as {\ttfamily src}. \\
\hline
{\em distance\+Type} & Type of distance. It can be {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1, C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, or {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C}. \\
\hline
{\em mask\+Size} & Size of the distance transform mask. It can be 3, 5, or {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+M\+A\+S\+K\+\_\+\+P\+R\+E\+C\+I\+SE} (the latter option is only supported by the first function). In case of the {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1} or {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C} distance type, the parameter is forced to 3 because a {\itshape 3x 3} mask gives the same result as {\itshape 5x 5} or any larger aperture.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#distancetransform}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+distance\+Transform} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5f09765bfd6488e72af786bedf84debb}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5f09765bfd6488e72af786bedf84debb}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!distance\+Transform\+With\+Labels@{distance\+Transform\+With\+Labels}}
\index{distance\+Transform\+With\+Labels@{distance\+Transform\+With\+Labels}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{distance\+Transform\+With\+Labels()}{distanceTransformWithLabels()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+distance\+Transform\+With\+Labels (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{labels,  }\item[{int}]{distance\+Type,  }\item[{int}]{mask\+Size,  }\item[{int}]{label\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the distance to the closest zero pixel for each pixel of the source image.

The functions {\ttfamily distance\+Transform} calculate the approximate or precise distance from every binary image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.

When {\ttfamily mask\+Size == C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+M\+A\+S\+K\+\_\+\+P\+R\+E\+C\+I\+SE} and {\ttfamily distance\+Type == C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, the function runs the algorithm described in \mbox{[}Felzenszwalb04\mbox{]}. This algorithm is parallelized with the T\+BB library.

In other cases, the algorithm \mbox{[}Borgefors86\mbox{]} is used. This means that for a pixel the function finds the shortest path to the nearest zero pixel consisting of basic shifts\+: horizontal, vertical, diagonal, or knight\textquotesingle{}s move (the latest is available for a {\itshape 5x 5} mask). The overall distance is calculated as a sum of these basic distances. Since the distance function should be symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as {\ttfamily a}), all the diagonal shifts must have the same cost (denoted as {\ttfamily b}), and all knight\textquotesingle{}s moves must have the same cost (denoted as {\ttfamily c}). For the {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C} and {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1} types, the distance is calculated precisely, whereas for {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2} (Euclidean distance) the distance can be calculated only with a relative error (a {\itshape 5x 5} mask gives more accurate results). For {\ttfamily a},{\ttfamily b}, and {\ttfamily c}, Open\+CV uses the values suggested in the original paper\+:

============== =================== ====================== {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C} {\itshape (3x 3)} a = 1, b = 1 \textbackslash{} ============== =================== ====================== {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1} {\itshape (3x 3)} a = 1, b = 2 \textbackslash{} {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2} {\itshape (3x 3)} a=0.\+955, b=1.\+3693 \textbackslash{} {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2} {\itshape (5x 5)} a=1, b=1.\+4, c=2.\+1969 \textbackslash{} ============== =================== ======================

Typically, for a fast, coarse distance estimation {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, a {\itshape 3x 3} mask is used. For a more accurate distance estimation {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, a {\itshape 5x 5} mask or the precise algorithm is used. Note that both the precise and the approximate algorithms are linear on the number of pixels.

The second variant of the function does not only compute the minimum distance for each pixel {\itshape (x, y)} but also identifies the nearest connected component consisting of zero pixels ({\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+C\+C\+O\+MP}) or the nearest zero pixel ({\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+P\+I\+X\+EL}). Index of the component/pixel is stored in {\itshape labels(x, y)}. When {\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+C\+C\+O\+MP}, the function automatically finds connected components of zero pixels in the input image and marks them with distinct labels. When {\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+C\+C\+O\+MP}, the function scans through the input image and marks all the zero pixels with distinct labels.

In this mode, the complexity is still linear. That is, the function provides a very fast way to compute the Voronoi diagram for a binary image. Currently, the second variant can use only the approximate distance transform algorithm, i.\+e. {\ttfamily mask\+Size=C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+M\+A\+S\+K\+\_\+\+P\+R\+E\+C\+I\+SE} is not supported yet.

Note\+:


\begin{DoxyItemize}
\item An example on using the distance transform can be found at opencv\+\_\+source\+\_\+code/samples/cpp/distrans.\+cpp 
\item (Python) An example on using the distance transform can be found at opencv\+\_\+source/samples/python2/distrans.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & 8-\/bit, single-\/channel (binary) source image. \\
\hline
{\em dst} & Output image with calculated distances. It is a 32-\/bit floating-\/point, single-\/channel image of the same size as {\ttfamily src}. \\
\hline
{\em labels} & Optional output 2D array of labels (the discrete Voronoi diagram). It has the type {\ttfamily C\+V\+\_\+32\+S\+C1} and the same size as {\ttfamily src}. See the details below. \\
\hline
{\em distance\+Type} & Type of distance. It can be {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1, C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, or {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C}. \\
\hline
{\em mask\+Size} & Size of the distance transform mask. It can be 3, 5, or {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+M\+A\+S\+K\+\_\+\+P\+R\+E\+C\+I\+SE} (the latter option is only supported by the first function). In case of the {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1} or {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C} distance type, the parameter is forced to 3 because a {\itshape 3x 3} mask gives the same result as {\itshape 5x 5} or any larger aperture. \\
\hline
{\em label\+Type} & Type of the label array to build. If {\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+C\+C\+O\+MP} then each connected component of zeros in {\ttfamily src} (as well as all the non-\/zero pixels closest to the connected component) will be assigned the same label. If {\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+P\+I\+X\+EL} then each zero pixel (and all the non-\/zero pixels closest to it) gets its own label.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#distancetransform}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+distance\+Transform} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac25a59a395516fc78f9f578605a29c1a}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac25a59a395516fc78f9f578605a29c1a}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!distance\+Transform\+With\+Labels@{distance\+Transform\+With\+Labels}}
\index{distance\+Transform\+With\+Labels@{distance\+Transform\+With\+Labels}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{distance\+Transform\+With\+Labels()}{distanceTransformWithLabels()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+distance\+Transform\+With\+Labels (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{labels,  }\item[{int}]{distance\+Type,  }\item[{int}]{mask\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the distance to the closest zero pixel for each pixel of the source image.

The functions {\ttfamily distance\+Transform} calculate the approximate or precise distance from every binary image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.

When {\ttfamily mask\+Size == C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+M\+A\+S\+K\+\_\+\+P\+R\+E\+C\+I\+SE} and {\ttfamily distance\+Type == C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, the function runs the algorithm described in \mbox{[}Felzenszwalb04\mbox{]}. This algorithm is parallelized with the T\+BB library.

In other cases, the algorithm \mbox{[}Borgefors86\mbox{]} is used. This means that for a pixel the function finds the shortest path to the nearest zero pixel consisting of basic shifts\+: horizontal, vertical, diagonal, or knight\textquotesingle{}s move (the latest is available for a {\itshape 5x 5} mask). The overall distance is calculated as a sum of these basic distances. Since the distance function should be symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as {\ttfamily a}), all the diagonal shifts must have the same cost (denoted as {\ttfamily b}), and all knight\textquotesingle{}s moves must have the same cost (denoted as {\ttfamily c}). For the {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C} and {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1} types, the distance is calculated precisely, whereas for {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2} (Euclidean distance) the distance can be calculated only with a relative error (a {\itshape 5x 5} mask gives more accurate results). For {\ttfamily a},{\ttfamily b}, and {\ttfamily c}, Open\+CV uses the values suggested in the original paper\+:

============== =================== ====================== {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C} {\itshape (3x 3)} a = 1, b = 1 \textbackslash{} ============== =================== ====================== {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1} {\itshape (3x 3)} a = 1, b = 2 \textbackslash{} {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2} {\itshape (3x 3)} a=0.\+955, b=1.\+3693 \textbackslash{} {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2} {\itshape (5x 5)} a=1, b=1.\+4, c=2.\+1969 \textbackslash{} ============== =================== ======================

Typically, for a fast, coarse distance estimation {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, a {\itshape 3x 3} mask is used. For a more accurate distance estimation {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, a {\itshape 5x 5} mask or the precise algorithm is used. Note that both the precise and the approximate algorithms are linear on the number of pixels.

The second variant of the function does not only compute the minimum distance for each pixel {\itshape (x, y)} but also identifies the nearest connected component consisting of zero pixels ({\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+C\+C\+O\+MP}) or the nearest zero pixel ({\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+P\+I\+X\+EL}). Index of the component/pixel is stored in {\itshape labels(x, y)}. When {\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+C\+C\+O\+MP}, the function automatically finds connected components of zero pixels in the input image and marks them with distinct labels. When {\ttfamily label\+Type==D\+I\+S\+T\+\_\+\+L\+A\+B\+E\+L\+\_\+\+C\+C\+O\+MP}, the function scans through the input image and marks all the zero pixels with distinct labels.

In this mode, the complexity is still linear. That is, the function provides a very fast way to compute the Voronoi diagram for a binary image. Currently, the second variant can use only the approximate distance transform algorithm, i.\+e. {\ttfamily mask\+Size=C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+M\+A\+S\+K\+\_\+\+P\+R\+E\+C\+I\+SE} is not supported yet.

Note\+:


\begin{DoxyItemize}
\item An example on using the distance transform can be found at opencv\+\_\+source\+\_\+code/samples/cpp/distrans.\+cpp 
\item (Python) An example on using the distance transform can be found at opencv\+\_\+source/samples/python2/distrans.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & 8-\/bit, single-\/channel (binary) source image. \\
\hline
{\em dst} & Output image with calculated distances. It is a 32-\/bit floating-\/point, single-\/channel image of the same size as {\ttfamily src}. \\
\hline
{\em labels} & Optional output 2D array of labels (the discrete Voronoi diagram). It has the type {\ttfamily C\+V\+\_\+32\+S\+C1} and the same size as {\ttfamily src}. See the details below. \\
\hline
{\em distance\+Type} & Type of distance. It can be {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1, C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2}, or {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C}. \\
\hline
{\em mask\+Size} & Size of the distance transform mask. It can be 3, 5, or {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+M\+A\+S\+K\+\_\+\+P\+R\+E\+C\+I\+SE} (the latter option is only supported by the first function). In case of the {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1} or {\ttfamily C\+V\+\_\+\+D\+I\+S\+T\+\_\+C} distance type, the parameter is forced to 3 because a {\itshape 3x 3} mask gives the same result as {\itshape 5x 5} or any larger aperture.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#distancetransform}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+distance\+Transform} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aaf689993f59f9920d22624e2672e9bc1}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aaf689993f59f9920d22624e2672e9bc1}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!draw\+Contours@{draw\+Contours}}
\index{draw\+Contours@{draw\+Contours}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{draw\+Contours()}{drawContours()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+draw\+Contours (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$}]{contours,  }\item[{int}]{contour\+Idx,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness,  }\item[{int}]{line\+Type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{hierarchy,  }\item[{int}]{max\+Level,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{offset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws contours outlines or filled contours.

The function draws contour outlines in the image if {\itshape thickness $>$= 0} or fills the area bounded by the contours if{\itshape thickness\&lt0}. The example below shows how to retrieve connected components from the binary image and label them\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include \char`\"{}cv.\+h\char`\"{}}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include \char`\"{}highgui.\+h\char`\"{}}

{\ttfamily }

{\ttfamily }

{\ttfamily using namespace cv;}

{\ttfamily }

{\ttfamily }

{\ttfamily int main(int argc, char argv)}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat src;}

{\ttfamily }

{\ttfamily }

{\ttfamily // the first command-\/line parameter must be a filename of the binary}

{\ttfamily }

{\ttfamily }

{\ttfamily // (black-\/n-\/white) image}

{\ttfamily }

{\ttfamily }

{\ttfamily if(argc != 2 $\vert$$\vert$ !(src=imread(argv\mbox{[}1\mbox{]}, 0)).data)}

{\ttfamily }

{\ttfamily }

{\ttfamily return -\/1;}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat dst = \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aff41070138369b96f792b19f01ab00d9}{Mat.\+zeros}}(src.\+rows, src.\+cols, C\+V\+\_\+8\+U\+C3);}

{\ttfamily }

{\ttfamily }

{\ttfamily src = src $>$ 1;}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Source\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Source\char`\"{}, src);}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$vector$<$\+Point$>$ $>$ contours;}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Vec4i$>$ hierarchy;}

{\ttfamily }

{\ttfamily }

{\ttfamily find\+Contours(src, contours, hierarchy,}

{\ttfamily }

{\ttfamily }

{\ttfamily C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+C\+C\+O\+MP, C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+S\+I\+M\+P\+LE);}

{\ttfamily }

{\ttfamily }

{\ttfamily // iterate through all the top-\/level contours,}

{\ttfamily }

{\ttfamily }

{\ttfamily // draw each connected component with its own random color}

{\ttfamily }

{\ttfamily }

{\ttfamily int idx = 0;}

{\ttfamily }

{\ttfamily }

{\ttfamily for(; idx $>$= 0; idx = hierarchy\mbox{[}idx\mbox{]}\mbox{[}0\mbox{]})}

{\ttfamily }

{\ttfamily }

{\ttfamily Scalar color(rand()\&255, rand()\&255, rand()\&255);}

{\ttfamily }

{\ttfamily }

{\ttfamily draw\+Contours(dst, contours, idx, color, C\+V\+\_\+\+F\+I\+L\+L\+E\+D, 8, hierarchy);}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Components\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Components\char`\"{}, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily wait\+Key(0);}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: }


\begin{DoxyItemize}
\item An example using the draw\+Contour functionality can be found at opencv\+\_\+source\+\_\+code/samples/cpp/contours2.\+cpp 
\item An example using draw\+Contours to clean up a background segmentation result at opencv\+\_\+source\+\_\+code/samples/cpp/segment\+\_\+objects.\+cpp 
\item (Python) An example using the draw\+Contour functionality can be found at opencv\+\_\+source/samples/python2/contours.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & Destination image. \\
\hline
{\em contours} & All the input contours. Each contour is stored as a point vector. \\
\hline
{\em contour\+Idx} & Parameter indicating a contour to draw. If it is negative, all the contours are drawn. \\
\hline
{\em color} & Color of the contours. \\
\hline
{\em thickness} & Thickness of lines the contours are drawn with. If it is negative (for example, {\ttfamily thickness=C\+V\+\_\+\+F\+I\+L\+L\+ED}), the contour interiors are drawn. \\
\hline
{\em line\+Type} & Line connectivity. See \char`\"{}line\char`\"{} for details. \\
\hline
{\em hierarchy} & Optional information about hierarchy. It is only needed if you want to draw only some of the contours (see {\ttfamily max\+Level}). \\
\hline
{\em max\+Level} & Maximal level for drawn contours. If it is 0, only the specified contour is drawn. If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-\/to-\/nested contours, and so on. This parameter is only taken into account when there is {\ttfamily hierarchy} available. \\
\hline
{\em offset} & Optional contour shift parameter. Shift all the drawn contours by the specified {\itshape offset=(dx,dy)}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#drawcontours}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+draw\+Contours} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a36480a8bc172c736bb663d4e906a8195}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a36480a8bc172c736bb663d4e906a8195}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!draw\+Contours@{draw\+Contours}}
\index{draw\+Contours@{draw\+Contours}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{draw\+Contours()}{drawContours()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+draw\+Contours (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$}]{contours,  }\item[{int}]{contour\+Idx,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color,  }\item[{int}]{thickness }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws contours outlines or filled contours.

The function draws contour outlines in the image if {\itshape thickness $>$= 0} or fills the area bounded by the contours if{\itshape thickness\&lt0}. The example below shows how to retrieve connected components from the binary image and label them\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include \char`\"{}cv.\+h\char`\"{}}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include \char`\"{}highgui.\+h\char`\"{}}

{\ttfamily }

{\ttfamily }

{\ttfamily using namespace cv;}

{\ttfamily }

{\ttfamily }

{\ttfamily int main(int argc, char argv)}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat src;}

{\ttfamily }

{\ttfamily }

{\ttfamily // the first command-\/line parameter must be a filename of the binary}

{\ttfamily }

{\ttfamily }

{\ttfamily // (black-\/n-\/white) image}

{\ttfamily }

{\ttfamily }

{\ttfamily if(argc != 2 $\vert$$\vert$ !(src=imread(argv\mbox{[}1\mbox{]}, 0)).data)}

{\ttfamily }

{\ttfamily }

{\ttfamily return -\/1;}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat dst = \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aff41070138369b96f792b19f01ab00d9}{Mat.\+zeros}}(src.\+rows, src.\+cols, C\+V\+\_\+8\+U\+C3);}

{\ttfamily }

{\ttfamily }

{\ttfamily src = src $>$ 1;}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Source\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Source\char`\"{}, src);}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$vector$<$\+Point$>$ $>$ contours;}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Vec4i$>$ hierarchy;}

{\ttfamily }

{\ttfamily }

{\ttfamily find\+Contours(src, contours, hierarchy,}

{\ttfamily }

{\ttfamily }

{\ttfamily C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+C\+C\+O\+MP, C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+S\+I\+M\+P\+LE);}

{\ttfamily }

{\ttfamily }

{\ttfamily // iterate through all the top-\/level contours,}

{\ttfamily }

{\ttfamily }

{\ttfamily // draw each connected component with its own random color}

{\ttfamily }

{\ttfamily }

{\ttfamily int idx = 0;}

{\ttfamily }

{\ttfamily }

{\ttfamily for(; idx $>$= 0; idx = hierarchy\mbox{[}idx\mbox{]}\mbox{[}0\mbox{]})}

{\ttfamily }

{\ttfamily }

{\ttfamily Scalar color(rand()\&255, rand()\&255, rand()\&255);}

{\ttfamily }

{\ttfamily }

{\ttfamily draw\+Contours(dst, contours, idx, color, C\+V\+\_\+\+F\+I\+L\+L\+E\+D, 8, hierarchy);}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Components\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Components\char`\"{}, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily wait\+Key(0);}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: }


\begin{DoxyItemize}
\item An example using the draw\+Contour functionality can be found at opencv\+\_\+source\+\_\+code/samples/cpp/contours2.\+cpp 
\item An example using draw\+Contours to clean up a background segmentation result at opencv\+\_\+source\+\_\+code/samples/cpp/segment\+\_\+objects.\+cpp 
\item (Python) An example using the draw\+Contour functionality can be found at opencv\+\_\+source/samples/python2/contours.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & Destination image. \\
\hline
{\em contours} & All the input contours. Each contour is stored as a point vector. \\
\hline
{\em contour\+Idx} & Parameter indicating a contour to draw. If it is negative, all the contours are drawn. \\
\hline
{\em color} & Color of the contours. \\
\hline
{\em thickness} & Thickness of lines the contours are drawn with. If it is negative (for example, {\ttfamily thickness=C\+V\+\_\+\+F\+I\+L\+L\+ED}), the contour interiors are drawn.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#drawcontours}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+draw\+Contours} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac89674f3f896a672c8ed20be07e83e0e}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac89674f3f896a672c8ed20be07e83e0e}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!draw\+Contours@{draw\+Contours}}
\index{draw\+Contours@{draw\+Contours}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{draw\+Contours()}{drawContours()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+draw\+Contours (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$}]{contours,  }\item[{int}]{contour\+Idx,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{color }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Draws contours outlines or filled contours.

The function draws contour outlines in the image if {\itshape thickness $>$= 0} or fills the area bounded by the contours if{\itshape thickness\&lt0}. The example below shows how to retrieve connected components from the binary image and label them\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include \char`\"{}cv.\+h\char`\"{}}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include \char`\"{}highgui.\+h\char`\"{}}

{\ttfamily }

{\ttfamily }

{\ttfamily using namespace cv;}

{\ttfamily }

{\ttfamily }

{\ttfamily int main(int argc, char argv)}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat src;}

{\ttfamily }

{\ttfamily }

{\ttfamily // the first command-\/line parameter must be a filename of the binary}

{\ttfamily }

{\ttfamily }

{\ttfamily // (black-\/n-\/white) image}

{\ttfamily }

{\ttfamily }

{\ttfamily if(argc != 2 $\vert$$\vert$ !(src=imread(argv\mbox{[}1\mbox{]}, 0)).data)}

{\ttfamily }

{\ttfamily }

{\ttfamily return -\/1;}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat dst = \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aff41070138369b96f792b19f01ab00d9}{Mat.\+zeros}}(src.\+rows, src.\+cols, C\+V\+\_\+8\+U\+C3);}

{\ttfamily }

{\ttfamily }

{\ttfamily src = src $>$ 1;}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Source\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Source\char`\"{}, src);}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$vector$<$\+Point$>$ $>$ contours;}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Vec4i$>$ hierarchy;}

{\ttfamily }

{\ttfamily }

{\ttfamily find\+Contours(src, contours, hierarchy,}

{\ttfamily }

{\ttfamily }

{\ttfamily C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+C\+C\+O\+MP, C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+S\+I\+M\+P\+LE);}

{\ttfamily }

{\ttfamily }

{\ttfamily // iterate through all the top-\/level contours,}

{\ttfamily }

{\ttfamily }

{\ttfamily // draw each connected component with its own random color}

{\ttfamily }

{\ttfamily }

{\ttfamily int idx = 0;}

{\ttfamily }

{\ttfamily }

{\ttfamily for(; idx $>$= 0; idx = hierarchy\mbox{[}idx\mbox{]}\mbox{[}0\mbox{]})}

{\ttfamily }

{\ttfamily }

{\ttfamily Scalar color(rand()\&255, rand()\&255, rand()\&255);}

{\ttfamily }

{\ttfamily }

{\ttfamily draw\+Contours(dst, contours, idx, color, C\+V\+\_\+\+F\+I\+L\+L\+E\+D, 8, hierarchy);}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Components\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Components\char`\"{}, dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily wait\+Key(0);}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: }


\begin{DoxyItemize}
\item An example using the draw\+Contour functionality can be found at opencv\+\_\+source\+\_\+code/samples/cpp/contours2.\+cpp 
\item An example using draw\+Contours to clean up a background segmentation result at opencv\+\_\+source\+\_\+code/samples/cpp/segment\+\_\+objects.\+cpp 
\item (Python) An example using the draw\+Contour functionality can be found at opencv\+\_\+source/samples/python2/contours.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & Destination image. \\
\hline
{\em contours} & All the input contours. Each contour is stored as a point vector. \\
\hline
{\em contour\+Idx} & Parameter indicating a contour to draw. If it is negative, all the contours are drawn. \\
\hline
{\em color} & Color of the contours.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#drawcontours}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+draw\+Contours} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a54ffba160b6fca43023f2d5f556e9b74}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a54ffba160b6fca43023f2d5f556e9b74}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!equalize\+Hist@{equalize\+Hist}}
\index{equalize\+Hist@{equalize\+Hist}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{equalize\+Hist()}{equalizeHist()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+equalize\+Hist (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Equalizes the histogram of a grayscale image.

The function equalizes the histogram of the input image using the following algorithm\+:


\begin{DoxyItemize}
\item Calculate the histogram {\itshape H} for {\ttfamily src}. 
\item Normalize the histogram so that the sum of histogram bins is 255. 
\item Compute the integral of the histogram\+: 
\end{DoxyItemize}

{\itshape H\textquotesingle{}\+\_\+i = sum(by\+: 0 $<$= j \&lt i) H(j)}


\begin{DoxyItemize}
\item 
\end{DoxyItemize}

Transform the image using {\itshape H\textquotesingle{}} as a look-\/up table\+: {\itshape dst(x,y) = H\textquotesingle{}(src(x,y))}

The algorithm normalizes the brightness and increases the contrast of the image.


\begin{DoxyParams}{Parameters}
{\em src} & Source 8-\/bit single channel image. \\
\hline
{\em dst} & Destination image of the same size and type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/histograms.html#equalizehist}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+equalize\+Hist} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_addf44b4eae2f6a52e93c1018cdb07ddc}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_addf44b4eae2f6a52e93c1018cdb07ddc}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!erode@{erode}}
\index{erode@{erode}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{erode()}{erode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+erode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{int}]{iterations,  }\item[{int}]{border\+Type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{border\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Erodes an image by using a specific structuring element.

The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken\+:

{\itshape dst(x,y) = min \+\_\+((x\textquotesingle{},y\textquotesingle{})\+: element(x\textquotesingle{},y\textquotesingle{}) != 0) src(x+x\textquotesingle{},y+y\textquotesingle{})}

The function supports the in-\/place mode. Erosion can be applied several ({\ttfamily iterations}) times. In case of multi-\/channel images, each channel is processed independently.

Note\+:


\begin{DoxyItemize}
\item An example using the morphological erode operation can be found at opencv\+\_\+source\+\_\+code/samples/cpp/morphology2.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input image; the number of channels can be arbitrary, but the depth should be one of {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F\char`\"{} or $<$/code$>$\+C\+V\+\_\+64\+F\char`\"{}. }\\
\hline
{\em dst} & {\ttfamily output image of the same size and type as {\ttfamily src}. }\\
\hline
{\em kernel} & {\ttfamily a kernel }\\
\hline
{\em anchor} & {\ttfamily position of the anchor within the element; default value {\ttfamily (-\/1, -\/1)} means that the anchor is at the element center. }\\
\hline
{\em iterations} & {\ttfamily number of times erosion is applied. }\\
\hline
{\em border\+Type} & {\ttfamily pixel extrapolation method (see \char`\"{}border\+Interpolate\char`\"{} for details). }\\
\hline
{\em border\+Value} & {\ttfamily border value in case of a constant border (see \char`\"{}create\+Morphology\+Filter\char`\"{} for details).}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
{\ttfamily  \href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#erode}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+erode} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a72708dff026d005db5a9534c9b2b4aae}{org.\+opencv.\+imgproc.\+Imgproc\+::morphology\+Ex}} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7ed226f2562750987d756b129d3820b2}{org.\+opencv.\+imgproc.\+Imgproc\+::dilate}} }
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3fda166b23a9211a4c6831f15851cd28}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3fda166b23a9211a4c6831f15851cd28}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!erode@{erode}}
\index{erode@{erode}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{erode()}{erode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+erode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{int}]{iterations }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Erodes an image by using a specific structuring element.

The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken\+:

{\itshape dst(x,y) = min \+\_\+((x\textquotesingle{},y\textquotesingle{})\+: element(x\textquotesingle{},y\textquotesingle{}) != 0) src(x+x\textquotesingle{},y+y\textquotesingle{})}

The function supports the in-\/place mode. Erosion can be applied several ({\ttfamily iterations}) times. In case of multi-\/channel images, each channel is processed independently.

Note\+:


\begin{DoxyItemize}
\item An example using the morphological erode operation can be found at opencv\+\_\+source\+\_\+code/samples/cpp/morphology2.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input image; the number of channels can be arbitrary, but the depth should be one of {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F\char`\"{} or $<$/code$>$\+C\+V\+\_\+64\+F\char`\"{}. }\\
\hline
{\em dst} & {\ttfamily output image of the same size and type as {\ttfamily src}. }\\
\hline
{\em kernel} & {\ttfamily a kernel }\\
\hline
{\em anchor} & {\ttfamily position of the anchor within the element; default value {\ttfamily (-\/1, -\/1)} means that the anchor is at the element center. }\\
\hline
{\em iterations} & {\ttfamily number of times erosion is applied.}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
{\ttfamily  \href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#erode}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+erode} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a72708dff026d005db5a9534c9b2b4aae}{org.\+opencv.\+imgproc.\+Imgproc\+::morphology\+Ex}} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7ed226f2562750987d756b129d3820b2}{org.\+opencv.\+imgproc.\+Imgproc\+::dilate}} }
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a485bdd85e47f631bd9f2e29d203b4060}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a485bdd85e47f631bd9f2e29d203b4060}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!erode@{erode}}
\index{erode@{erode}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{erode()}{erode()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+erode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Erodes an image by using a specific structuring element.

The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken\+:

{\itshape dst(x,y) = min \+\_\+((x\textquotesingle{},y\textquotesingle{})\+: element(x\textquotesingle{},y\textquotesingle{}) != 0) src(x+x\textquotesingle{},y+y\textquotesingle{})}

The function supports the in-\/place mode. Erosion can be applied several ({\ttfamily iterations}) times. In case of multi-\/channel images, each channel is processed independently.

Note\+:


\begin{DoxyItemize}
\item An example using the morphological erode operation can be found at opencv\+\_\+source\+\_\+code/samples/cpp/morphology2.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input image; the number of channels can be arbitrary, but the depth should be one of {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F\char`\"{} or $<$/code$>$\+C\+V\+\_\+64\+F\char`\"{}. }\\
\hline
{\em dst} & {\ttfamily output image of the same size and type as {\ttfamily src}. }\\
\hline
{\em kernel} & {\ttfamily a kernel}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
{\ttfamily  \href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#erode}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+erode} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a72708dff026d005db5a9534c9b2b4aae}{org.\+opencv.\+imgproc.\+Imgproc\+::morphology\+Ex}} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7ed226f2562750987d756b129d3820b2}{org.\+opencv.\+imgproc.\+Imgproc\+::dilate}} }
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!filter2D@{filter2D}}
\index{filter2D@{filter2D}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{filter2\+D()}{filter2D()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+filter2D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{double}]{delta,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Convolves an image with the kernel.

The function applies an arbitrary linear filter to an image. In-\/place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode.

The function does actually compute correlation, not the convolution\+:

{\itshape dst(x,y) = sum(by\+: 0 $<$= x\textquotesingle{} \&lt kernel.\+cols, 0 $<$= y\textquotesingle{} \&lt kernel.\+rows) kernel(x\textquotesingle{},y\textquotesingle{})$\ast$ src(x+x\textquotesingle{}-\/ anchor.\+x,y+y\textquotesingle{}-\/ anchor.\+y)}

That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using \char`\"{}flip\char`\"{} and set the new anchor to {\ttfamily (kernel.\+cols -\/ anchor.\+x -\/ 1, kernel.\+rows -\/ anchor.\+y -\/ 1)}.

The function uses the D\+F\+T-\/based algorithm in case of sufficiently large kernels ($\sim${\ttfamily 11 x 11} or larger) and the direct algorithm (that uses the engine retrieved by \char`\"{}create\+Linear\+Filter\char`\"{}) for small kernels.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & desired depth of the destination image; if it is negative, it will be the same as {\ttfamily src.\+depth()}; the following combinations of {\ttfamily src.\+depth()} and {\ttfamily ddepth} are supported\+: 
\begin{DoxyItemize}
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+8U}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+16S}/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+16U}/{\ttfamily C\+V\+\_\+16S}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+32F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+64F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+64F} 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


when {\ttfamily ddepth=-\/1}, the output image will have the same depth as the source.


\begin{DoxyParams}{Parameters}
{\em kernel} & convolution kernel (or rather a correlation kernel), a single-\/channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using \char`\"{}split\char`\"{} and process them individually. \\
\hline
{\em anchor} & anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-\/1,-\/1) means that the anchor is at the kernel center. \\
\hline
{\em delta} & optional value added to the filtered pixels before storing them in {\ttfamily dst}. \\
\hline
{\em border\+Type} & pixel extrapolation method (see \char`\"{}border\+Interpolate\char`\"{} for details).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#filter2d}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+filter2D} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab7f64647bb4d0400664056af42b90063}{org.\+opencv.\+imgproc.\+Imgproc\+::match\+Template}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{org.\+opencv.\+imgproc.\+Imgproc\+::sep\+Filter2D}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a99d049df474881b0f663137cac0e83db}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a99d049df474881b0f663137cac0e83db}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!filter2D@{filter2D}}
\index{filter2D@{filter2D}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{filter2\+D()}{filter2D()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+filter2D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{double}]{delta }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Convolves an image with the kernel.

The function applies an arbitrary linear filter to an image. In-\/place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode.

The function does actually compute correlation, not the convolution\+:

{\itshape dst(x,y) = sum(by\+: 0 $<$= x\textquotesingle{} \&lt kernel.\+cols, 0 $<$= y\textquotesingle{} \&lt kernel.\+rows) kernel(x\textquotesingle{},y\textquotesingle{})$\ast$ src(x+x\textquotesingle{}-\/ anchor.\+x,y+y\textquotesingle{}-\/ anchor.\+y)}

That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using \char`\"{}flip\char`\"{} and set the new anchor to {\ttfamily (kernel.\+cols -\/ anchor.\+x -\/ 1, kernel.\+rows -\/ anchor.\+y -\/ 1)}.

The function uses the D\+F\+T-\/based algorithm in case of sufficiently large kernels ($\sim${\ttfamily 11 x 11} or larger) and the direct algorithm (that uses the engine retrieved by \char`\"{}create\+Linear\+Filter\char`\"{}) for small kernels.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & desired depth of the destination image; if it is negative, it will be the same as {\ttfamily src.\+depth()}; the following combinations of {\ttfamily src.\+depth()} and {\ttfamily ddepth} are supported\+: 
\begin{DoxyItemize}
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+8U}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+16S}/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+16U}/{\ttfamily C\+V\+\_\+16S}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+32F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+64F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+64F} 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


when {\ttfamily ddepth=-\/1}, the output image will have the same depth as the source.


\begin{DoxyParams}{Parameters}
{\em kernel} & convolution kernel (or rather a correlation kernel), a single-\/channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using \char`\"{}split\char`\"{} and process them individually. \\
\hline
{\em anchor} & anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-\/1,-\/1) means that the anchor is at the kernel center. \\
\hline
{\em delta} & optional value added to the filtered pixels before storing them in {\ttfamily dst}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#filter2d}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+filter2D} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab7f64647bb4d0400664056af42b90063}{org.\+opencv.\+imgproc.\+Imgproc\+::match\+Template}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{org.\+opencv.\+imgproc.\+Imgproc\+::sep\+Filter2D}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a957d2e1b7b47980406f42d1290385504}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a957d2e1b7b47980406f42d1290385504}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!filter2D@{filter2D}}
\index{filter2D@{filter2D}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{filter2\+D()}{filter2D()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+filter2D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Convolves an image with the kernel.

The function applies an arbitrary linear filter to an image. In-\/place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode.

The function does actually compute correlation, not the convolution\+:

{\itshape dst(x,y) = sum(by\+: 0 $<$= x\textquotesingle{} \&lt kernel.\+cols, 0 $<$= y\textquotesingle{} \&lt kernel.\+rows) kernel(x\textquotesingle{},y\textquotesingle{})$\ast$ src(x+x\textquotesingle{}-\/ anchor.\+x,y+y\textquotesingle{}-\/ anchor.\+y)}

That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using \char`\"{}flip\char`\"{} and set the new anchor to {\ttfamily (kernel.\+cols -\/ anchor.\+x -\/ 1, kernel.\+rows -\/ anchor.\+y -\/ 1)}.

The function uses the D\+F\+T-\/based algorithm in case of sufficiently large kernels ($\sim${\ttfamily 11 x 11} or larger) and the direct algorithm (that uses the engine retrieved by \char`\"{}create\+Linear\+Filter\char`\"{}) for small kernels.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & desired depth of the destination image; if it is negative, it will be the same as {\ttfamily src.\+depth()}; the following combinations of {\ttfamily src.\+depth()} and {\ttfamily ddepth} are supported\+: 
\begin{DoxyItemize}
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+8U}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+16S}/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+16U}/{\ttfamily C\+V\+\_\+16S}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+32F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+64F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+64F} 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


when {\ttfamily ddepth=-\/1}, the output image will have the same depth as the source.


\begin{DoxyParams}{Parameters}
{\em kernel} & convolution kernel (or rather a correlation kernel), a single-\/channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using \char`\"{}split\char`\"{} and process them individually.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#filter2d}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+filter2D} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab7f64647bb4d0400664056af42b90063}{org.\+opencv.\+imgproc.\+Imgproc\+::match\+Template}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{org.\+opencv.\+imgproc.\+Imgproc\+::sep\+Filter2D}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a60284da5baddfe0b44c6553177de8bf9}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a60284da5baddfe0b44c6553177de8bf9}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!find\+Contours@{find\+Contours}}
\index{find\+Contours@{find\+Contours}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{find\+Contours()}{findContours()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+find\+Contours (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$}]{contours,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{hierarchy,  }\item[{int}]{mode,  }\item[{int}]{method,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{offset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds contours in a binary image.

The function retrieves contours from the binary image using the algorithm \mbox{[}Suzuki85\mbox{]}. The contours are a useful tool for shape analysis and object detection and recognition. See {\ttfamily squares.\+c} in the Open\+CV sample directory.

Note\+: Source {\ttfamily image} is modified by this function. Also, the function does not take into account 1-\/pixel border of the image (it\textquotesingle{}s filled with 0\textquotesingle{}s and used for neighbor analysis in the algorithm), therefore the contours touching the image border will be clipped.

Note\+: If you use the new Python interface then the {\ttfamily C\+V\+\_\+} prefix has to be omitted in contour retrieval mode and contour approximation method parameters (for example, use {\ttfamily cv2.\+R\+E\+T\+R\+\_\+\+L\+I\+ST} and {\ttfamily cv2.\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE} parameters). If you use the old Python interface then these parameters have the {\ttfamily C\+V\+\_\+} prefix (for example, use {\ttfamily cv.\+C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+L\+I\+ST} and {\ttfamily cv.\+C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE}).

Note\+:


\begin{DoxyItemize}
\item An example using the find\+Contour functionality can be found at opencv\+\_\+source\+\_\+code/samples/cpp/contours2.\+cpp 
\item An example using find\+Contours to clean up a background segmentation result at opencv\+\_\+source\+\_\+code/samples/cpp/segment\+\_\+objects.\+cpp 
\item (Python) An example using the find\+Contour functionality can be found at opencv\+\_\+source/samples/python2/contours.\+py 
\item (Python) An example of detecting squares in an image can be found at opencv\+\_\+source/samples/python2/squares.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & Source, an 8-\/bit single-\/channel image. Non-\/zero pixels are treated as 1\textquotesingle{}s. Zero pixels remain 0\textquotesingle{}s, so the image is treated as {\ttfamily binary}. You can use \char`\"{}compare\char`\"{}, \char`\"{}in\+Range\char`\"{}, \char`\"{}threshold\char`\"{}, \char`\"{}adaptive\+Threshold\char`\"{}, \char`\"{}\+Canny\char`\"{}, and others to create a binary image out of a grayscale or color one. The function modifies the {\ttfamily image} while extracting the contours. \\
\hline
{\em contours} & Detected contours. Each contour is stored as a vector of points. \\
\hline
{\em hierarchy} & Optional output vector, containing information about the image topology. It has as many elements as the number of contours. For each i-\/th contour {\ttfamily contours\mbox{[}i\mbox{]}}, the elements {\ttfamily hierarchy\mbox{[}i\mbox{]}\mbox{[}0\mbox{]}}, {\ttfamily hiearchy\mbox{[}i\mbox{]}\mbox{[}1\mbox{]}}, {\ttfamily hiearchy\mbox{[}i\mbox{]}\mbox{[}2\mbox{]}}, and {\ttfamily hiearchy\mbox{[}i\mbox{]}\mbox{[}3\mbox{]}} are set to 0-\/based indices in {\ttfamily contours} of the next and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. If for the contour {\ttfamily i} there are no next, previous, parent, or nested contours, the corresponding elements of {\ttfamily hierarchy\mbox{[}i\mbox{]}} will be negative. \\
\hline
{\em mode} & Contour retrieval mode (if you use Python see also a note below). 
\begin{DoxyItemize}
\item C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+E\+X\+T\+E\+R\+N\+AL retrieves only the extreme outer contours. It sets {\ttfamily hierarchy\mbox{[}i\mbox{]}\mbox{[}2\mbox{]}=hierarchy\mbox{[}i\mbox{]}\mbox{[}3\mbox{]}=-\/1} for all the contours. 
\item C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+L\+I\+ST retrieves all of the contours without establishing any hierarchical relationships. 
\item C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+C\+C\+O\+MP retrieves all of the contours and organizes them into a two-\/level hierarchy. At the top level, there are external boundaries of the components. At the second level, there are boundaries of the holes. If there is another contour inside a hole of a connected component, it is still put at the top level. 
\item C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+T\+R\+EE retrieves all of the contours and reconstructs a full hierarchy of nested contours. This full hierarchy is built and shown in the Open\+CV {\ttfamily contours.\+c} demo. 
\end{DoxyItemize}\\
\hline
{\em method} & Contour approximation method (if you use Python see also a note below). 
\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE stores absolutely all the contour points. That is, any 2 subsequent points {\ttfamily (x1,y1)} and {\ttfamily (x2,y2)} of the contour will be either horizontal, vertical or diagonal neighbors, that is, {\ttfamily max(abs(x1-\/x2),abs(y2-\/y1))==1}. 
\item C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+S\+I\+M\+P\+LE compresses horizontal, vertical, and diagonal segments and leaves only their end points. For example, an up-\/right rectangular contour is encoded with 4 points. 
\item C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+T\+C89\+\_\+\+L1,C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+T\+C89\+\_\+\+K\+C\+OS applies one of the flavors of the Teh-\/\+Chin chain approximation algorithm. See \mbox{[}Teh\+Chin89\mbox{]} for details. 
\end{DoxyItemize}\\
\hline
{\em offset} & Optional offset by which every contour point is shifted. This is useful if the contours are extracted from the image R\+OI and then they should be analyzed in the whole image context.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#findcontours}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+find\+Contours} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a007342d8043f1610bb73d105949ab86c}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a007342d8043f1610bb73d105949ab86c}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!find\+Contours@{find\+Contours}}
\index{find\+Contours@{find\+Contours}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{find\+Contours()}{findContours()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+find\+Contours (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{List$<$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}} $>$}]{contours,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{hierarchy,  }\item[{int}]{mode,  }\item[{int}]{method }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds contours in a binary image.

The function retrieves contours from the binary image using the algorithm \mbox{[}Suzuki85\mbox{]}. The contours are a useful tool for shape analysis and object detection and recognition. See {\ttfamily squares.\+c} in the Open\+CV sample directory.

Note\+: Source {\ttfamily image} is modified by this function. Also, the function does not take into account 1-\/pixel border of the image (it\textquotesingle{}s filled with 0\textquotesingle{}s and used for neighbor analysis in the algorithm), therefore the contours touching the image border will be clipped.

Note\+: If you use the new Python interface then the {\ttfamily C\+V\+\_\+} prefix has to be omitted in contour retrieval mode and contour approximation method parameters (for example, use {\ttfamily cv2.\+R\+E\+T\+R\+\_\+\+L\+I\+ST} and {\ttfamily cv2.\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE} parameters). If you use the old Python interface then these parameters have the {\ttfamily C\+V\+\_\+} prefix (for example, use {\ttfamily cv.\+C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+L\+I\+ST} and {\ttfamily cv.\+C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE}).

Note\+:


\begin{DoxyItemize}
\item An example using the find\+Contour functionality can be found at opencv\+\_\+source\+\_\+code/samples/cpp/contours2.\+cpp 
\item An example using find\+Contours to clean up a background segmentation result at opencv\+\_\+source\+\_\+code/samples/cpp/segment\+\_\+objects.\+cpp 
\item (Python) An example using the find\+Contour functionality can be found at opencv\+\_\+source/samples/python2/contours.\+py 
\item (Python) An example of detecting squares in an image can be found at opencv\+\_\+source/samples/python2/squares.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & Source, an 8-\/bit single-\/channel image. Non-\/zero pixels are treated as 1\textquotesingle{}s. Zero pixels remain 0\textquotesingle{}s, so the image is treated as {\ttfamily binary}. You can use \char`\"{}compare\char`\"{}, \char`\"{}in\+Range\char`\"{}, \char`\"{}threshold\char`\"{}, \char`\"{}adaptive\+Threshold\char`\"{}, \char`\"{}\+Canny\char`\"{}, and others to create a binary image out of a grayscale or color one. The function modifies the {\ttfamily image} while extracting the contours. \\
\hline
{\em contours} & Detected contours. Each contour is stored as a vector of points. \\
\hline
{\em hierarchy} & Optional output vector, containing information about the image topology. It has as many elements as the number of contours. For each i-\/th contour {\ttfamily contours\mbox{[}i\mbox{]}}, the elements {\ttfamily hierarchy\mbox{[}i\mbox{]}\mbox{[}0\mbox{]}}, {\ttfamily hiearchy\mbox{[}i\mbox{]}\mbox{[}1\mbox{]}}, {\ttfamily hiearchy\mbox{[}i\mbox{]}\mbox{[}2\mbox{]}}, and {\ttfamily hiearchy\mbox{[}i\mbox{]}\mbox{[}3\mbox{]}} are set to 0-\/based indices in {\ttfamily contours} of the next and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. If for the contour {\ttfamily i} there are no next, previous, parent, or nested contours, the corresponding elements of {\ttfamily hierarchy\mbox{[}i\mbox{]}} will be negative. \\
\hline
{\em mode} & Contour retrieval mode (if you use Python see also a note below). 
\begin{DoxyItemize}
\item C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+E\+X\+T\+E\+R\+N\+AL retrieves only the extreme outer contours. It sets {\ttfamily hierarchy\mbox{[}i\mbox{]}\mbox{[}2\mbox{]}=hierarchy\mbox{[}i\mbox{]}\mbox{[}3\mbox{]}=-\/1} for all the contours. 
\item C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+L\+I\+ST retrieves all of the contours without establishing any hierarchical relationships. 
\item C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+C\+C\+O\+MP retrieves all of the contours and organizes them into a two-\/level hierarchy. At the top level, there are external boundaries of the components. At the second level, there are boundaries of the holes. If there is another contour inside a hole of a connected component, it is still put at the top level. 
\item C\+V\+\_\+\+R\+E\+T\+R\+\_\+\+T\+R\+EE retrieves all of the contours and reconstructs a full hierarchy of nested contours. This full hierarchy is built and shown in the Open\+CV {\ttfamily contours.\+c} demo. 
\end{DoxyItemize}\\
\hline
{\em method} & Contour approximation method (if you use Python see also a note below). 
\begin{DoxyItemize}
\item C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE stores absolutely all the contour points. That is, any 2 subsequent points {\ttfamily (x1,y1)} and {\ttfamily (x2,y2)} of the contour will be either horizontal, vertical or diagonal neighbors, that is, {\ttfamily max(abs(x1-\/x2),abs(y2-\/y1))==1}. 
\item C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+S\+I\+M\+P\+LE compresses horizontal, vertical, and diagonal segments and leaves only their end points. For example, an up-\/right rectangular contour is encoded with 4 points. 
\item C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+T\+C89\+\_\+\+L1,C\+V\+\_\+\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+T\+C89\+\_\+\+K\+C\+OS applies one of the flavors of the Teh-\/\+Chin chain approximation algorithm. See \mbox{[}Teh\+Chin89\mbox{]} for details. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#findcontours}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+find\+Contours} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa1223b61730baf7b52760332c5cdd8f5}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa1223b61730baf7b52760332c5cdd8f5}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!fit\+Ellipse@{fit\+Ellipse}}
\index{fit\+Ellipse@{fit\+Ellipse}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{fit\+Ellipse()}{fitEllipse()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rotated_rect}{Rotated\+Rect}} org.\+opencv.\+imgproc.\+Imgproc.\+fit\+Ellipse (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{points }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Fits an ellipse around a set of 2D points.

The function calculates the ellipse that fits (in a least-\/squares sense) a set of 2D points best of all. It returns the rotated rectangle in which the ellipse is inscribed. The algorithm \mbox{[}Fitzgibbon95\mbox{]} is used. Developer should keep in mind that it is possible that the returned ellipse/rotated\+Rect data contains negative indices, due to the data points being close to the border of the containing Mat element.

Note\+:


\begin{DoxyItemize}
\item An example using the fit\+Ellipse technique can be found at opencv\+\_\+source\+\_\+code/samples/cpp/fitellipse.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em points} & Input 2D point set, stored in\+: 
\begin{DoxyItemize}
\item {\ttfamily std.\+vector$<$$>$} or {\ttfamily Mat} (C++ interface) 
\item {\ttfamily Cv\+Seq$\ast$} or {\ttfamily Cv\+Mat$\ast$} (C interface) 
\item Nx2 numpy array (Python interface) 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#fitellipse}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+fit\+Ellipse} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a78923d7431756fb4cb2046359b75607f}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a78923d7431756fb4cb2046359b75607f}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!fit\+Line@{fit\+Line}}
\index{fit\+Line@{fit\+Line}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{fit\+Line()}{fitLine()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+fit\+Line (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{line,  }\item[{int}]{dist\+Type,  }\item[{double}]{param,  }\item[{double}]{reps,  }\item[{double}]{aeps }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Fits a line to a 2D or 3D point set.

The function {\ttfamily fit\+Line} fits a line to a 2D or 3D point set by minimizing {\itshape sum\+\_\+i rho(r\+\_\+i)} where {\itshape r\+\_\+i} is a distance between the {\itshape i$^\wedge$(th)} point, the line and {\itshape rho(r)} is a distance function, one of the following\+:


\begin{DoxyItemize}
\item dist\+Type=C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L2 
\end{DoxyItemize}

{\itshape rho(r) = r$^\wedge$2/2(the simplest and the fastest least-\/squares method)}


\begin{DoxyItemize}
\item dist\+Type=C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L1 
\end{DoxyItemize}

{\itshape rho(r) = r}


\begin{DoxyItemize}
\item dist\+Type=C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+L12 
\end{DoxyItemize}

{\itshape rho(r) = 2 $\ast$ (sqrt(1 + frac(r$^\wedge$2)2) -\/ 1)}


\begin{DoxyItemize}
\item dist\+Type=C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+F\+A\+IR 
\end{DoxyItemize}

{\itshape rho(r) = C$^\wedge$2 $\ast$ ((r)/(C) -\/ log((1 + (r)/(C)))) where C=1.\+3998}


\begin{DoxyItemize}
\item dist\+Type=C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+W\+E\+L\+S\+CH 
\end{DoxyItemize}

{\itshape rho(r) = (C$^\wedge$2)/2 $\ast$ (1 -\/ exp((-\/((r)/(C))$^\wedge$2))) where C=2.\+9846}


\begin{DoxyItemize}
\item dist\+Type=C\+V\+\_\+\+D\+I\+S\+T\+\_\+\+H\+U\+B\+ER 
\end{DoxyItemize}

{\itshape rho(r) = r$^\wedge$2/2 if r \&lt C; C $\ast$ (r-\/\+C/2) otherwise where C=1.\+345}

The algorithm is based on the M-\/estimator (\href{http://en.wikipedia.org/wiki/M-estimator}{\tt http\+://en.\+wikipedia.\+org/wiki/\+M-\/estimator}) technique that iteratively fits the line using the weighted least-\/squares algorithm. After each iteration the weights {\itshape w\+\_\+i} are adjusted to be inversely proportional to {\itshape rho(r\+\_\+i)}... Sample code\+:


\begin{DoxyItemize}
\item (Python) An example of robust line fitting can be found at opencv\+\_\+source\+\_\+code/samples/python2/fitline.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em points} & Input vector of 2D or 3D points, stored in {\ttfamily std.\+vector$<$$>$} or {\ttfamily Mat}. \\
\hline
{\em line} & Output line parameters. In case of 2D fitting, it should be a vector of 4 elements (like {\ttfamily Vec4f}) -\/ {\ttfamily (vx, vy, x0, y0)}, where {\ttfamily (vx, vy)} is a normalized vector collinear to the line and {\ttfamily (x0, y0)} is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like {\ttfamily Vec6f}) -\/ {\ttfamily (vx, vy, vz, x0, y0, z0)}, where {\ttfamily (vx, vy, vz)} is a normalized vector collinear to the line and {\ttfamily (x0, y0, z0)} is a point on the line. \\
\hline
{\em dist\+Type} & Distance used by the M-\/estimator (see the discussion below). \\
\hline
{\em param} & Numerical parameter ({\ttfamily C}) for some types of distances. If it is 0, an optimal value is chosen. \\
\hline
{\em reps} & Sufficient accuracy for the radius (distance between the coordinate origin and the line). \\
\hline
{\em aeps} & Sufficient accuracy for the angle. 0.\+01 would be a good default value for {\ttfamily reps} and {\ttfamily aeps}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#fitline}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+fit\+Line} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af2c9b324bfce19842e0a1dbc6e97caf7}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af2c9b324bfce19842e0a1dbc6e97caf7}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!flood\+Fill@{flood\+Fill}}
\index{flood\+Fill@{flood\+Fill}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{flood\+Fill()}{floodFill()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static int org.\+opencv.\+imgproc.\+Imgproc.\+flood\+Fill (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{seed\+Point,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{new\+Val,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{rect,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{lo\+Diff,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{up\+Diff,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Fills a connected component with the given color.

The functions {\ttfamily flood\+Fill} fill a connected component starting from the seed point with the specified color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The pixel at {\itshape (x,y)} is considered to belong to the repainted domain if\+:


\begin{DoxyItemize}
\item {\itshape src(x\textquotesingle{},y\textquotesingle{})-\/ lo\+Diff $<$= src(x,y) $<$= src(x\textquotesingle{},y\textquotesingle{})+ up\+Diff} 
\end{DoxyItemize}

in case of a grayscale image and floating range


\begin{DoxyItemize}
\item {\itshape src(seed\+Point.\+x, seed\+Point.\+y)-\/ lo\+Diff $<$= src(x,y) $<$= src(seed\+Point.\+x, seed\+Point.\+y)+ up\+Diff} 
\end{DoxyItemize}

in case of a grayscale image and fixed range


\begin{DoxyItemize}
\item {\itshape src(x\textquotesingle{},y\textquotesingle{})\+\_\+r-\/ lo\+Diff \+\_\+r $<$= src(x,y)\+\_\+r $<$= src(x\textquotesingle{},y\textquotesingle{})\+\_\+r+ up\+Diff \+\_\+r,}


\end{DoxyItemize}

{\itshape src(x\textquotesingle{},y\textquotesingle{})\+\_\+g-\/ lo\+Diff \+\_\+g $<$= src(x,y)\+\_\+g $<$= src(x\textquotesingle{},y\textquotesingle{})\+\_\+g+ up\+Diff \+\_\+g}

and

{\itshape src(x\textquotesingle{},y\textquotesingle{})\+\_\+b-\/ lo\+Diff \+\_\+b $<$= src(x,y)\+\_\+b $<$= src(x\textquotesingle{},y\textquotesingle{})\+\_\+b+ up\+Diff \+\_\+b}

in case of a color image and floating range


\begin{DoxyItemize}
\item {\itshape src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+r-\/ lo\+Diff \+\_\+r $<$= src(x,y)\+\_\+r $<$= src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+r+ up\+Diff \+\_\+r,}


\end{DoxyItemize}

{\itshape src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+g-\/ lo\+Diff \+\_\+g $<$= src(x,y)\+\_\+g $<$= src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+g+ up\+Diff \+\_\+g}

and

{\itshape src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+b-\/ lo\+Diff \+\_\+b $<$= src(x,y)\+\_\+b $<$= src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+b+ up\+Diff \+\_\+b}

in case of a color image and fixed range

where {\itshape src(x\textquotesingle{},y\textquotesingle{})} is the value of one of pixel neighbors that is already known to belong to the component. That is, to be added to the connected component, a color/brightness of the pixel should be close enough to\+:


\begin{DoxyItemize}
\item Color/brightness of one of its neighbors that already belong to the connected component in case of a floating range. 
\item Color/brightness of the seed point in case of a fixed range. 
\end{DoxyItemize}

Use these functions to either mark a connected component with the specified color in-\/place, or build a mask and then extract the contour, or copy the region to another image, and so on.

Note\+:


\begin{DoxyItemize}
\item An example using the Flood\+Fill technique can be found at opencv\+\_\+source\+\_\+code/samples/cpp/ffilldemo.\+cpp 
\item (Python) An example using the Flood\+Fill technique can be found at opencv\+\_\+source\+\_\+code/samples/python2/floodfill.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & Input/output 1-\/ or 3-\/channel, 8-\/bit, or floating-\/point image. It is modified by the function unless the {\ttfamily F\+L\+O\+O\+D\+F\+I\+L\+L\+\_\+\+M\+A\+S\+K\+\_\+\+O\+N\+LY} flag is set in the second variant of the function. See the details below. \\
\hline
{\em mask} & (For the second function only) Operation mask that should be a single-\/channel 8-\/bit image, 2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of initializing the {\ttfamily mask} content. Flood-\/filling cannot go across non-\/zero pixels in the mask. For example, an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask in multiple calls to the function to make sure the filled area does not overlap.\\
\hline
\end{DoxyParams}


Note\+: Since the mask is larger than the filled image, a pixel {\itshape (x, y)} in {\ttfamily image} corresponds to the pixel {\itshape (x+1, y+1)} in the {\ttfamily mask}.


\begin{DoxyParams}{Parameters}
{\em seed\+Point} & Starting point. \\
\hline
{\em new\+Val} & New value of the repainted domain pixels. \\
\hline
{\em rect} & Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain. \\
\hline
{\em lo\+Diff} & Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component. \\
\hline
{\em up\+Diff} & Maximal upper brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component. \\
\hline
{\em flags} & Operation flags. Lower bits contain a connectivity value, 4 (default) or 8, used within the function. Connectivity determines which neighbors of a pixel are considered. Upper bits can be 0 or a combination of the following flags\+: 
\begin{DoxyItemize}
\item F\+L\+O\+O\+D\+F\+I\+L\+L\+\_\+\+F\+I\+X\+E\+D\+\_\+\+R\+A\+N\+GE If set, the difference between the current pixel and seed pixel is considered. Otherwise, the difference between neighbor pixels is considered (that is, the range is floating). 
\item F\+L\+O\+O\+D\+F\+I\+L\+L\+\_\+\+M\+A\+S\+K\+\_\+\+O\+N\+LY If set, the function does not change the image ({\ttfamily new\+Val} is ignored), but fills the mask. The flag can be used for the second variant only. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#floodfill}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+flood\+Fill} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a60284da5baddfe0b44c6553177de8bf9}{org.\+opencv.\+imgproc.\+Imgproc\+::find\+Contours}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a86974fce952ae2763066b15290d01be9}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a86974fce952ae2763066b15290d01be9}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!flood\+Fill@{flood\+Fill}}
\index{flood\+Fill@{flood\+Fill}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{flood\+Fill()}{floodFill()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static int org.\+opencv.\+imgproc.\+Imgproc.\+flood\+Fill (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{seed\+Point,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{new\+Val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Fills a connected component with the given color.

The functions {\ttfamily flood\+Fill} fill a connected component starting from the seed point with the specified color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The pixel at {\itshape (x,y)} is considered to belong to the repainted domain if\+:


\begin{DoxyItemize}
\item {\itshape src(x\textquotesingle{},y\textquotesingle{})-\/ lo\+Diff $<$= src(x,y) $<$= src(x\textquotesingle{},y\textquotesingle{})+ up\+Diff} 
\end{DoxyItemize}

in case of a grayscale image and floating range


\begin{DoxyItemize}
\item {\itshape src(seed\+Point.\+x, seed\+Point.\+y)-\/ lo\+Diff $<$= src(x,y) $<$= src(seed\+Point.\+x, seed\+Point.\+y)+ up\+Diff} 
\end{DoxyItemize}

in case of a grayscale image and fixed range


\begin{DoxyItemize}
\item {\itshape src(x\textquotesingle{},y\textquotesingle{})\+\_\+r-\/ lo\+Diff \+\_\+r $<$= src(x,y)\+\_\+r $<$= src(x\textquotesingle{},y\textquotesingle{})\+\_\+r+ up\+Diff \+\_\+r,}


\end{DoxyItemize}

{\itshape src(x\textquotesingle{},y\textquotesingle{})\+\_\+g-\/ lo\+Diff \+\_\+g $<$= src(x,y)\+\_\+g $<$= src(x\textquotesingle{},y\textquotesingle{})\+\_\+g+ up\+Diff \+\_\+g}

and

{\itshape src(x\textquotesingle{},y\textquotesingle{})\+\_\+b-\/ lo\+Diff \+\_\+b $<$= src(x,y)\+\_\+b $<$= src(x\textquotesingle{},y\textquotesingle{})\+\_\+b+ up\+Diff \+\_\+b}

in case of a color image and floating range


\begin{DoxyItemize}
\item {\itshape src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+r-\/ lo\+Diff \+\_\+r $<$= src(x,y)\+\_\+r $<$= src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+r+ up\+Diff \+\_\+r,}


\end{DoxyItemize}

{\itshape src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+g-\/ lo\+Diff \+\_\+g $<$= src(x,y)\+\_\+g $<$= src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+g+ up\+Diff \+\_\+g}

and

{\itshape src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+b-\/ lo\+Diff \+\_\+b $<$= src(x,y)\+\_\+b $<$= src(seed\+Point.\+x, seed\+Point.\+y)\+\_\+b+ up\+Diff \+\_\+b}

in case of a color image and fixed range

where {\itshape src(x\textquotesingle{},y\textquotesingle{})} is the value of one of pixel neighbors that is already known to belong to the component. That is, to be added to the connected component, a color/brightness of the pixel should be close enough to\+:


\begin{DoxyItemize}
\item Color/brightness of one of its neighbors that already belong to the connected component in case of a floating range. 
\item Color/brightness of the seed point in case of a fixed range. 
\end{DoxyItemize}

Use these functions to either mark a connected component with the specified color in-\/place, or build a mask and then extract the contour, or copy the region to another image, and so on.

Note\+:


\begin{DoxyItemize}
\item An example using the Flood\+Fill technique can be found at opencv\+\_\+source\+\_\+code/samples/cpp/ffilldemo.\+cpp 
\item (Python) An example using the Flood\+Fill technique can be found at opencv\+\_\+source\+\_\+code/samples/python2/floodfill.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & Input/output 1-\/ or 3-\/channel, 8-\/bit, or floating-\/point image. It is modified by the function unless the {\ttfamily F\+L\+O\+O\+D\+F\+I\+L\+L\+\_\+\+M\+A\+S\+K\+\_\+\+O\+N\+LY} flag is set in the second variant of the function. See the details below. \\
\hline
{\em mask} & (For the second function only) Operation mask that should be a single-\/channel 8-\/bit image, 2 pixels wider and 2 pixels taller. The function uses and updates the mask, so you take responsibility of initializing the {\ttfamily mask} content. Flood-\/filling cannot go across non-\/zero pixels in the mask. For example, an edge detector output can be used as a mask to stop filling at edges. It is possible to use the same mask in multiple calls to the function to make sure the filled area does not overlap.\\
\hline
\end{DoxyParams}


Note\+: Since the mask is larger than the filled image, a pixel {\itshape (x, y)} in {\ttfamily image} corresponds to the pixel {\itshape (x+1, y+1)} in the {\ttfamily mask}.


\begin{DoxyParams}{Parameters}
{\em seed\+Point} & Starting point. \\
\hline
{\em new\+Val} & New value of the repainted domain pixels.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#floodfill}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+flood\+Fill} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a60284da5baddfe0b44c6553177de8bf9}{org.\+opencv.\+imgproc.\+Imgproc\+::find\+Contours}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Gaussian\+Blur@{Gaussian\+Blur}}
\index{Gaussian\+Blur@{Gaussian\+Blur}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Gaussian\+Blur()}{GaussianBlur()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Gaussian\+Blur (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{double}]{sigmaX,  }\item[{double}]{sigmaY,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image using a Gaussian filter.

The function convolves the source image with the specified Gaussian kernel. In-\/place filtering is supported.


\begin{DoxyParams}{Parameters}
{\em src} & input image; the image can have any number of channels, which are processed independently, but the depth should be {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F} or {\ttfamily C\+V\+\_\+64F}. \\
\hline
{\em dst} & output image of the same size and type as {\ttfamily src}. \\
\hline
{\em ksize} & Gaussian kernel size. {\ttfamily ksize.\+width} and {\ttfamily ksize.\+height} can differ but they both must be positive and odd. Or, they can be zero\textquotesingle{}s and then they are computed from {\ttfamily sigma$\ast$}. \\
\hline
{\em sigmaX} & Gaussian kernel standard deviation in X direction. \\
\hline
{\em sigmaY} & Gaussian kernel standard deviation in Y direction; if {\ttfamily sigmaY} is zero, it is set to be equal to {\ttfamily sigmaX}, if both sigmas are zeros, they are computed from {\ttfamily ksize.\+width} and {\ttfamily ksize.\+height}, respectively (see \char`\"{}get\+Gaussian\+Kernel\char`\"{} for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of {\ttfamily ksize}, {\ttfamily sigmaX}, and {\ttfamily sigmaY}. \\
\hline
{\em border\+Type} & pixel extrapolation method (see \char`\"{}border\+Interpolate\char`\"{} for details).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#gaussianblur}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Gaussian\+Blur} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{org.\+opencv.\+imgproc.\+Imgproc\+::sep\+Filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}{org.\+opencv.\+imgproc.\+Imgproc\+::median\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}{org.\+opencv.\+imgproc.\+Imgproc\+::box\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{org.\+opencv.\+imgproc.\+Imgproc\+::blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{org.\+opencv.\+imgproc.\+Imgproc\+::filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}{org.\+opencv.\+imgproc.\+Imgproc\+::bilateral\+Filter}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6550b1518d3df5dc446f27cd8f1c2285}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6550b1518d3df5dc446f27cd8f1c2285}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Gaussian\+Blur@{Gaussian\+Blur}}
\index{Gaussian\+Blur@{Gaussian\+Blur}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Gaussian\+Blur()}{GaussianBlur()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Gaussian\+Blur (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{double}]{sigmaX,  }\item[{double}]{sigmaY }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image using a Gaussian filter.

The function convolves the source image with the specified Gaussian kernel. In-\/place filtering is supported.


\begin{DoxyParams}{Parameters}
{\em src} & input image; the image can have any number of channels, which are processed independently, but the depth should be {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F} or {\ttfamily C\+V\+\_\+64F}. \\
\hline
{\em dst} & output image of the same size and type as {\ttfamily src}. \\
\hline
{\em ksize} & Gaussian kernel size. {\ttfamily ksize.\+width} and {\ttfamily ksize.\+height} can differ but they both must be positive and odd. Or, they can be zero\textquotesingle{}s and then they are computed from {\ttfamily sigma$\ast$}. \\
\hline
{\em sigmaX} & Gaussian kernel standard deviation in X direction. \\
\hline
{\em sigmaY} & Gaussian kernel standard deviation in Y direction; if {\ttfamily sigmaY} is zero, it is set to be equal to {\ttfamily sigmaX}, if both sigmas are zeros, they are computed from {\ttfamily ksize.\+width} and {\ttfamily ksize.\+height}, respectively (see \char`\"{}get\+Gaussian\+Kernel\char`\"{} for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of {\ttfamily ksize}, {\ttfamily sigmaX}, and {\ttfamily sigmaY}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#gaussianblur}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Gaussian\+Blur} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{org.\+opencv.\+imgproc.\+Imgproc\+::sep\+Filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}{org.\+opencv.\+imgproc.\+Imgproc\+::median\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}{org.\+opencv.\+imgproc.\+Imgproc\+::box\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{org.\+opencv.\+imgproc.\+Imgproc\+::blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{org.\+opencv.\+imgproc.\+Imgproc\+::filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}{org.\+opencv.\+imgproc.\+Imgproc\+::bilateral\+Filter}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a38b4cc1a250ce929d1b2635675332b6a}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a38b4cc1a250ce929d1b2635675332b6a}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Gaussian\+Blur@{Gaussian\+Blur}}
\index{Gaussian\+Blur@{Gaussian\+Blur}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Gaussian\+Blur()}{GaussianBlur()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Gaussian\+Blur (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{double}]{sigmaX }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image using a Gaussian filter.

The function convolves the source image with the specified Gaussian kernel. In-\/place filtering is supported.


\begin{DoxyParams}{Parameters}
{\em src} & input image; the image can have any number of channels, which are processed independently, but the depth should be {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F} or {\ttfamily C\+V\+\_\+64F}. \\
\hline
{\em dst} & output image of the same size and type as {\ttfamily src}. \\
\hline
{\em ksize} & Gaussian kernel size. {\ttfamily ksize.\+width} and {\ttfamily ksize.\+height} can differ but they both must be positive and odd. Or, they can be zero\textquotesingle{}s and then they are computed from {\ttfamily sigma$\ast$}. \\
\hline
{\em sigmaX} & Gaussian kernel standard deviation in X direction.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#gaussianblur}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Gaussian\+Blur} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{org.\+opencv.\+imgproc.\+Imgproc\+::sep\+Filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}{org.\+opencv.\+imgproc.\+Imgproc\+::median\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}{org.\+opencv.\+imgproc.\+Imgproc\+::box\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{org.\+opencv.\+imgproc.\+Imgproc\+::blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{org.\+opencv.\+imgproc.\+Imgproc\+::filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}{org.\+opencv.\+imgproc.\+Imgproc\+::bilateral\+Filter}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a283e61c00d4e6ba9625264d8d7f5f8db}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a283e61c00d4e6ba9625264d8d7f5f8db}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Affine\+Transform@{get\+Affine\+Transform}}
\index{get\+Affine\+Transform@{get\+Affine\+Transform}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Affine\+Transform()}{getAffineTransform()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+imgproc.\+Imgproc.\+get\+Affine\+Transform (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates an affine transform from three pairs of the corresponding points.

The function calculates the {\itshape 2 x 3} matrix of an affine transform so that\+:

{\itshape x\textquotesingle{}\+\_\+i y\textquotesingle{}\+\_\+i = map\+\_\+matrix $\ast$ x\+\_\+i y\+\_\+i 1 }

where

{\itshape dst(i)=(x\textquotesingle{}\+\_\+i,y\textquotesingle{}\+\_\+i),\&lt\+BR\&gtsrc(i)=(x\+\_\+i, y\+\_\+i),\&lt\+BR\&gti=0,1,2}


\begin{DoxyParams}{Parameters}
{\em src} & Coordinates of triangle vertices in the source image. \\
\hline
{\em dst} & Coordinates of the corresponding triangle vertices in the destination image.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getaffinetransform}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Affine\+Transform} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Affine}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a221e7697d1a57961ee8a843b7aa05b75}{org.\+opencv.\+core.\+Core\+::transform}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_adaa73e104d926966ba7d5666c4458e51}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_adaa73e104d926966ba7d5666c4458e51}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Default\+New\+Camera\+Matrix@{get\+Default\+New\+Camera\+Matrix}}
\index{get\+Default\+New\+Camera\+Matrix@{get\+Default\+New\+Camera\+Matrix}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Default\+New\+Camera\+Matrix()}{getDefaultNewCameraMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+imgproc.\+Imgproc.\+get\+Default\+New\+Camera\+Matrix (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{imgsize,  }\item[{boolean}]{center\+Principal\+Point }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the default new camera matrix.

The function returns the camera matrix that is either an exact copy of the input {\ttfamily camera\+Matrix} (when {\ttfamily center\+Prinicipal\+Point=false}), or the modified one (when {\ttfamily center\+Principal\+Point=true}).

In the latter case, the new camera matrix will be\+:

{\itshape f\+\_\+x 0(img\+Size.\+width -\/1)$\ast$0.5 0 f\+\_\+y(img\+Size.\+height -\/1)$\ast$0.5 0 0 1,}

where {\itshape f\+\_\+x} and {\itshape f\+\_\+y} are {\itshape (0,0)} and {\itshape (1,1)} elements of {\ttfamily camera\+Matrix}, respectively.

By default, the undistortion functions in Open\+CV (see \char`\"{}init\+Undistort\+Rectify\+Map\char`\"{}, \char`\"{}undistort\char`\"{}) do not move the principal point. However, when you work with stereo, it is important to move the principal points in both views to the same y-\/coordinate (which is required by most of stereo correspondence algorithms), and may be to the same x-\/coordinate too. So, you can form the new camera matrix for each view where the principal points are located at the center.


\begin{DoxyParams}{Parameters}
{\em camera\+Matrix} & Input camera matrix. \\
\hline
{\em imgsize} & Camera view image size in pixels. \\
\hline
{\em center\+Principal\+Point} & Location of the principal point in the new camera matrix. The parameter indicates whether this location should be at the image center or not.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getdefaultnewcameramatrix}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Default\+New\+Camera\+Matrix} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7299c13c7cc005dcd769dbf58c349b82}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7299c13c7cc005dcd769dbf58c349b82}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Default\+New\+Camera\+Matrix@{get\+Default\+New\+Camera\+Matrix}}
\index{get\+Default\+New\+Camera\+Matrix@{get\+Default\+New\+Camera\+Matrix}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Default\+New\+Camera\+Matrix()}{getDefaultNewCameraMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+imgproc.\+Imgproc.\+get\+Default\+New\+Camera\+Matrix (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns the default new camera matrix.

The function returns the camera matrix that is either an exact copy of the input {\ttfamily camera\+Matrix} (when {\ttfamily center\+Prinicipal\+Point=false}), or the modified one (when {\ttfamily center\+Principal\+Point=true}).

In the latter case, the new camera matrix will be\+:

{\itshape f\+\_\+x 0(img\+Size.\+width -\/1)$\ast$0.5 0 f\+\_\+y(img\+Size.\+height -\/1)$\ast$0.5 0 0 1,}

where {\itshape f\+\_\+x} and {\itshape f\+\_\+y} are {\itshape (0,0)} and {\itshape (1,1)} elements of {\ttfamily camera\+Matrix}, respectively.

By default, the undistortion functions in Open\+CV (see \char`\"{}init\+Undistort\+Rectify\+Map\char`\"{}, \char`\"{}undistort\char`\"{}) do not move the principal point. However, when you work with stereo, it is important to move the principal points in both views to the same y-\/coordinate (which is required by most of stereo correspondence algorithms), and may be to the same x-\/coordinate too. So, you can form the new camera matrix for each view where the principal points are located at the center.


\begin{DoxyParams}{Parameters}
{\em camera\+Matrix} & Input camera matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getdefaultnewcameramatrix}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Default\+New\+Camera\+Matrix} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad7100f31c477bc17ad6c868f16822f2}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad7100f31c477bc17ad6c868f16822f2}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Deriv\+Kernels@{get\+Deriv\+Kernels}}
\index{get\+Deriv\+Kernels@{get\+Deriv\+Kernels}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Deriv\+Kernels()}{getDerivKernels()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+get\+Deriv\+Kernels (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kx,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{ky,  }\item[{int}]{dx,  }\item[{int}]{dy,  }\item[{int}]{ksize,  }\item[{boolean}]{normalize,  }\item[{int}]{ktype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns filter coefficients for computing spatial image derivatives.

The function computes and returns the filter coefficients for spatial image derivatives. When {\ttfamily ksize=C\+V\+\_\+\+S\+C\+H\+A\+RR}, the Scharr {\itshape 3 x 3} kernels are generated (see \char`\"{}\+Scharr\char`\"{}). Otherwise, Sobel kernels are generated (see \char`\"{}\+Sobel\char`\"{}). The filters are normally passed to \char`\"{}sep\+Filter2\+D\char`\"{} or to \char`\"{}create\+Separable\+Linear\+Filter\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em kx} & Output matrix of row filter coefficients. It has the type {\ttfamily ktype}. \\
\hline
{\em ky} & Output matrix of column filter coefficients. It has the type {\ttfamily ktype}. \\
\hline
{\em dx} & Derivative order in respect of x. \\
\hline
{\em dy} & Derivative order in respect of y. \\
\hline
{\em ksize} & Aperture size. It can be {\ttfamily C\+V\+\_\+\+S\+C\+H\+A\+RR}, 1, 3, 5, or 7. \\
\hline
{\em normalize} & Flag indicating whether to normalize (scale down) the filter coefficients or not. Theoretically, the coefficients should have the denominator {\itshape =2$^\wedge$(ksize$\ast$2-\/dx-\/dy-\/2)}. If you are going to filter floating-\/point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-\/bit image, store the results in a 16-\/bit image, and wish to preserve all the fractional bits, you may want to set {\ttfamily normalize=false}. \\
\hline
{\em ktype} & Type of filter coefficients. It can be {\ttfamily C\+V\+\_\+32f} or {\ttfamily C\+V\+\_\+64F}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#getderivkernels}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Deriv\+Kernels} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aadd8e596cd6747ac2bf7cf2936f09058}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aadd8e596cd6747ac2bf7cf2936f09058}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Deriv\+Kernels@{get\+Deriv\+Kernels}}
\index{get\+Deriv\+Kernels@{get\+Deriv\+Kernels}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Deriv\+Kernels()}{getDerivKernels()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+get\+Deriv\+Kernels (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kx,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{ky,  }\item[{int}]{dx,  }\item[{int}]{dy,  }\item[{int}]{ksize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns filter coefficients for computing spatial image derivatives.

The function computes and returns the filter coefficients for spatial image derivatives. When {\ttfamily ksize=C\+V\+\_\+\+S\+C\+H\+A\+RR}, the Scharr {\itshape 3 x 3} kernels are generated (see \char`\"{}\+Scharr\char`\"{}). Otherwise, Sobel kernels are generated (see \char`\"{}\+Sobel\char`\"{}). The filters are normally passed to \char`\"{}sep\+Filter2\+D\char`\"{} or to \char`\"{}create\+Separable\+Linear\+Filter\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em kx} & Output matrix of row filter coefficients. It has the type {\ttfamily ktype}. \\
\hline
{\em ky} & Output matrix of column filter coefficients. It has the type {\ttfamily ktype}. \\
\hline
{\em dx} & Derivative order in respect of x. \\
\hline
{\em dy} & Derivative order in respect of y. \\
\hline
{\em ksize} & Aperture size. It can be {\ttfamily C\+V\+\_\+\+S\+C\+H\+A\+RR}, 1, 3, 5, or 7.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#getderivkernels}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Deriv\+Kernels} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a878eb2f5d4a0fa92115642d5f2cfcc1a}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a878eb2f5d4a0fa92115642d5f2cfcc1a}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Gabor\+Kernel@{get\+Gabor\+Kernel}}
\index{get\+Gabor\+Kernel@{get\+Gabor\+Kernel}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Gabor\+Kernel()}{getGaborKernel()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+imgproc.\+Imgproc.\+get\+Gabor\+Kernel (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{double}]{sigma,  }\item[{double}]{theta,  }\item[{double}]{lambd,  }\item[{double}]{gamma,  }\item[{double}]{psi,  }\item[{int}]{ktype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6a76e5878eee9211bfca7e7d63802cc1}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6a76e5878eee9211bfca7e7d63802cc1}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Gabor\+Kernel@{get\+Gabor\+Kernel}}
\index{get\+Gabor\+Kernel@{get\+Gabor\+Kernel}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Gabor\+Kernel()}{getGaborKernel()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+imgproc.\+Imgproc.\+get\+Gabor\+Kernel (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{double}]{sigma,  }\item[{double}]{theta,  }\item[{double}]{lambd,  }\item[{double}]{gamma }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7f775ca4b4dd4c420a16a65ca28cbc58}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7f775ca4b4dd4c420a16a65ca28cbc58}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Gaussian\+Kernel@{get\+Gaussian\+Kernel}}
\index{get\+Gaussian\+Kernel@{get\+Gaussian\+Kernel}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Gaussian\+Kernel()}{getGaussianKernel()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+imgproc.\+Imgproc.\+get\+Gaussian\+Kernel (\begin{DoxyParamCaption}\item[{int}]{ksize,  }\item[{double}]{sigma,  }\item[{int}]{ktype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns Gaussian filter coefficients.

The function computes and returns the {\itshape ksize x 1} matrix of Gaussian filter coefficients\+:

{\itshape G\+\_\+i= alpha {\itshape e$^\wedge$(-\/(i-\/(ksize -\/1)/2)$^\wedge$2/(2} sigma)$^\wedge$2),}

where {\itshape i=0..ksize-\/1} and {\itshape alpha} is the scale factor chosen so that {\itshape sum\+\_\+i G\+\_\+i=1}.

Two of such generated kernels can be passed to \char`\"{}sep\+Filter2\+D\char`\"{} or to \char`\"{}create\+Separable\+Linear\+Filter\char`\"{}. Those functions automatically recognize smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly. You may also use the higher-\/level \char`\"{}\+Gaussian\+Blur\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em ksize} & Aperture size. It should be odd ({\itshape ksize mod 2 = 1}) and positive. \\
\hline
{\em sigma} & Gaussian standard deviation. If it is non-\/positive, it is computed from {\ttfamily ksize} as {\ttfamily sigma = 0.\+3$\ast$((ksize-\/1)$\ast$0.5 -\/ 1) + 0.\+8}. \\
\hline
{\em ktype} & Type of filter coefficients. It can be {\ttfamily C\+V\+\_\+32f} or {\ttfamily C\+V\+\_\+64F}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#getgaussiankernel}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Gaussian\+Kernel} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{org.\+opencv.\+imgproc.\+Imgproc\+::sep\+Filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a91f9695453e02aa885270c0cb3cb7207}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Structuring\+Element}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad7100f31c477bc17ad6c868f16822f2}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Deriv\+Kernels}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a60b28f1c495e346912dd0808d267ba3f}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a60b28f1c495e346912dd0808d267ba3f}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Gaussian\+Kernel@{get\+Gaussian\+Kernel}}
\index{get\+Gaussian\+Kernel@{get\+Gaussian\+Kernel}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Gaussian\+Kernel()}{getGaussianKernel()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+imgproc.\+Imgproc.\+get\+Gaussian\+Kernel (\begin{DoxyParamCaption}\item[{int}]{ksize,  }\item[{double}]{sigma }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns Gaussian filter coefficients.

The function computes and returns the {\itshape ksize x 1} matrix of Gaussian filter coefficients\+:

{\itshape G\+\_\+i= alpha {\itshape e$^\wedge$(-\/(i-\/(ksize -\/1)/2)$^\wedge$2/(2} sigma)$^\wedge$2),}

where {\itshape i=0..ksize-\/1} and {\itshape alpha} is the scale factor chosen so that {\itshape sum\+\_\+i G\+\_\+i=1}.

Two of such generated kernels can be passed to \char`\"{}sep\+Filter2\+D\char`\"{} or to \char`\"{}create\+Separable\+Linear\+Filter\char`\"{}. Those functions automatically recognize smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly. You may also use the higher-\/level \char`\"{}\+Gaussian\+Blur\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em ksize} & Aperture size. It should be odd ({\itshape ksize mod 2 = 1}) and positive. \\
\hline
{\em sigma} & Gaussian standard deviation. If it is non-\/positive, it is computed from {\ttfamily ksize} as {\ttfamily sigma = 0.\+3$\ast$((ksize-\/1)$\ast$0.5 -\/ 1) + 0.\+8}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#getgaussiankernel}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Gaussian\+Kernel} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{org.\+opencv.\+imgproc.\+Imgproc\+::sep\+Filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a91f9695453e02aa885270c0cb3cb7207}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Structuring\+Element}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad7100f31c477bc17ad6c868f16822f2}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Deriv\+Kernels}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab3727363e269af640d5254f76e14ddb6}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab3727363e269af640d5254f76e14ddb6}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Perspective\+Transform@{get\+Perspective\+Transform}}
\index{get\+Perspective\+Transform@{get\+Perspective\+Transform}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Perspective\+Transform()}{getPerspectiveTransform()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+imgproc.\+Imgproc.\+get\+Perspective\+Transform (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a perspective transform from four pairs of the corresponding points.

The function calculates the {\itshape 3 x 3} matrix of a perspective transform so that\+:

{\itshape t\+\_\+i x\textquotesingle{}\+\_\+i t\+\_\+i y\textquotesingle{}\+\_\+i t\+\_\+i = map\+\_\+matrix $\ast$ x\+\_\+i y\+\_\+i 1 }

where

{\itshape dst(i)=(x\textquotesingle{}\+\_\+i,y\textquotesingle{}\+\_\+i),\&lt\+BR\&gtsrc(i)=(x\+\_\+i, y\+\_\+i),\&lt\+BR\&gti=0,1,2,3}


\begin{DoxyParams}{Parameters}
{\em src} & Coordinates of quadrangle vertices in the source image. \\
\hline
{\em dst} & Coordinates of the corresponding quadrangle vertices in the destination image.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getperspectivetransform}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Perspective\+Transform} 

\mbox{\hyperlink{classorg_1_1opencv_1_1calib3d_1_1_calib3d_a2c32d44d2f35dc41aa09d54eb6829ab8}{org.\+opencv.\+calib3d.\+Calib3d\+::find\+Homography}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1ff0eace0f00e79af5228fdae120342a}{org.\+opencv.\+core.\+Core\+::perspective\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa547e4fbdf1a4806a1fd35ebbfe2a117}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa547e4fbdf1a4806a1fd35ebbfe2a117}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Rect\+Sub\+Pix@{get\+Rect\+Sub\+Pix}}
\index{get\+Rect\+Sub\+Pix@{get\+Rect\+Sub\+Pix}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Rect\+Sub\+Pix()}{getRectSubPix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+get\+Rect\+Sub\+Pix (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{patch\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{center,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{patch,  }\item[{int}]{patch\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Retrieves a pixel rectangle from an image with sub-\/pixel accuracy.

The function {\ttfamily get\+Rect\+Sub\+Pix} extracts pixels from {\ttfamily src}

{\itshape dst(x, y) = src(x + center.\+x -\/ (dst.\+cols -\/1)$\ast$0.5, y + center.\+y -\/ (dst.\+rows -\/1)$\ast$0.5)}

where the values of the pixels at non-\/integer coordinates are retrieved using bilinear interpolation. Every channel of multi-\/channel images is processed independently. While the center of the rectangle must be inside the image, parts of the rectangle may be outside. In this case, the replication border mode (see \char`\"{}border\+Interpolate\char`\"{}) is used to extrapolate the pixel values outside of the image.


\begin{DoxyParams}{Parameters}
{\em image} & a image \\
\hline
{\em patch\+Size} & Size of the extracted patch. \\
\hline
{\em center} & Floating point coordinates of the center of the extracted rectangle within the source image. The center must be inside the image. \\
\hline
{\em patch} & a patch \\
\hline
{\em patch\+Type} & Depth of the extracted pixels. By default, they have the same depth as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getrectsubpix}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Rect\+Sub\+Pix} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Affine}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3fd684028b07b7ba5327cb890cca0bbd}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3fd684028b07b7ba5327cb890cca0bbd}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Rect\+Sub\+Pix@{get\+Rect\+Sub\+Pix}}
\index{get\+Rect\+Sub\+Pix@{get\+Rect\+Sub\+Pix}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Rect\+Sub\+Pix()}{getRectSubPix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+get\+Rect\+Sub\+Pix (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{patch\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{center,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{patch }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Retrieves a pixel rectangle from an image with sub-\/pixel accuracy.

The function {\ttfamily get\+Rect\+Sub\+Pix} extracts pixels from {\ttfamily src}

{\itshape dst(x, y) = src(x + center.\+x -\/ (dst.\+cols -\/1)$\ast$0.5, y + center.\+y -\/ (dst.\+rows -\/1)$\ast$0.5)}

where the values of the pixels at non-\/integer coordinates are retrieved using bilinear interpolation. Every channel of multi-\/channel images is processed independently. While the center of the rectangle must be inside the image, parts of the rectangle may be outside. In this case, the replication border mode (see \char`\"{}border\+Interpolate\char`\"{}) is used to extrapolate the pixel values outside of the image.


\begin{DoxyParams}{Parameters}
{\em image} & a image \\
\hline
{\em patch\+Size} & Size of the extracted patch. \\
\hline
{\em center} & Floating point coordinates of the center of the extracted rectangle within the source image. The center must be inside the image. \\
\hline
{\em patch} & a patch\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getrectsubpix}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Rect\+Sub\+Pix} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Affine}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac336c5ce363b2561904027535a7edab6}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac336c5ce363b2561904027535a7edab6}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Rotation\+Matrix2D@{get\+Rotation\+Matrix2D}}
\index{get\+Rotation\+Matrix2D@{get\+Rotation\+Matrix2D}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Rotation\+Matrix2\+D()}{getRotationMatrix2D()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+imgproc.\+Imgproc.\+get\+Rotation\+Matrix2D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{center,  }\item[{double}]{angle,  }\item[{double}]{scale }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates an affine matrix of 2D rotation.

The function calculates the following matrix\+:

{\itshape alpha beta(1-\/ alpha) $\ast$ center.\+x -\/ beta $\ast$ center.\+y
\begin{DoxyItemize}
\item beta alpha beta $\ast$ center.\+x + (1-\/ alpha) $\ast$ center.\+y 
\end{DoxyItemize}}

{\itshape }

{\itshape }

{\itshape where}

{\itshape }

{\itshape }

{\itshape {\itshape alpha = scale $\ast$ cos angle, beta = scale $\ast$ sin angle }}

{\itshape }

{\itshape }

{\itshape The transformation maps the rotation center to itself. If this is not the target, adjust the shift.}

{\itshape }

{\itshape 
\begin{DoxyParams}{Parameters}
{\em center} & Center of the rotation in the source image. \\
\hline
{\em angle} & Rotation angle in degrees. Positive values mean counter-\/clockwise rotation (the coordinate origin is assumed to be the top-\/left corner). \\
\hline
{\em scale} & Isotropic scale factor.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#getrotationmatrix2d}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Rotation\+Matrix2D} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Affine}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a283e61c00d4e6ba9625264d8d7f5f8db}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Affine\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a221e7697d1a57961ee8a843b7aa05b75}{org.\+opencv.\+core.\+Core\+::transform}} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a91f9695453e02aa885270c0cb3cb7207}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a91f9695453e02aa885270c0cb3cb7207}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Structuring\+Element@{get\+Structuring\+Element}}
\index{get\+Structuring\+Element@{get\+Structuring\+Element}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Structuring\+Element()}{getStructuringElement()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+imgproc.\+Imgproc.\+get\+Structuring\+Element (\begin{DoxyParamCaption}\item[{int}]{shape,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a structuring element of the specified size and shape for morphological operations.

The function constructs and returns the structuring element that can be further passed to \char`\"{}create\+Morphology\+Filter\char`\"{}, \char`\"{}erode\char`\"{}, \char`\"{}dilate\char`\"{} or \char`\"{}morphology\+Ex\char`\"{}. But you can also construct an arbitrary binary mask yourself and use it as the structuring element.

Note\+: When using Open\+CV 1.\+x C A\+PI, the created structuring element {\ttfamily Ipl\+Conv\+Kernel$\ast$ element} must be released in the end using {\ttfamily cv\+Release\+Structuring\+Element(\&element)}.


\begin{DoxyParams}{Parameters}
{\em shape} & Element shape that could be one of the following\+: 
\begin{DoxyItemize}
\item M\+O\+R\+P\+H\+\_\+\+R\+E\+CT -\/ a rectangular structuring element\+: 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


{\itshape E\+\_\+(ij)=1}


\begin{DoxyItemize}
\item M\+O\+R\+P\+H\+\_\+\+E\+L\+L\+I\+P\+SE -\/ an elliptic structuring element, that is, a filled ellipse inscribed into the rectangle {\ttfamily Rect(0, 0, esize.\+width, 0.\+esize.\+height)} 
\item M\+O\+R\+P\+H\+\_\+\+C\+R\+O\+SS -\/ a cross-\/shaped structuring element\+: 
\end{DoxyItemize}

{\itshape E\+\_\+(ij) = 1 if i=anchor.\+y or j=anchor.\+x; 0 otherwise}


\begin{DoxyItemize}
\item C\+V\+\_\+\+S\+H\+A\+P\+E\+\_\+\+C\+U\+S\+T\+OM -\/ custom structuring element (Open\+CV 1.\+x A\+PI) 
\end{DoxyItemize}
\begin{DoxyParams}{Parameters}
{\em ksize} & Size of the structuring element. \\
\hline
{\em anchor} & Anchor position within the element. The default value {\itshape (-\/1, -\/1)} means that the anchor is at the center. Note that only the shape of a cross-\/shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#getstructuringelement}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Structuring\+Element} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a4e25f50f644c596500ea7cbb7d8f72cf}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a4e25f50f644c596500ea7cbb7d8f72cf}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!get\+Structuring\+Element@{get\+Structuring\+Element}}
\index{get\+Structuring\+Element@{get\+Structuring\+Element}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{get\+Structuring\+Element()}{getStructuringElement()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+imgproc.\+Imgproc.\+get\+Structuring\+Element (\begin{DoxyParamCaption}\item[{int}]{shape,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{ksize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a structuring element of the specified size and shape for morphological operations.

The function constructs and returns the structuring element that can be further passed to \char`\"{}create\+Morphology\+Filter\char`\"{}, \char`\"{}erode\char`\"{}, \char`\"{}dilate\char`\"{} or \char`\"{}morphology\+Ex\char`\"{}. But you can also construct an arbitrary binary mask yourself and use it as the structuring element.

Note\+: When using Open\+CV 1.\+x C A\+PI, the created structuring element {\ttfamily Ipl\+Conv\+Kernel$\ast$ element} must be released in the end using {\ttfamily cv\+Release\+Structuring\+Element(\&element)}.


\begin{DoxyParams}{Parameters}
{\em shape} & Element shape that could be one of the following\+: 
\begin{DoxyItemize}
\item M\+O\+R\+P\+H\+\_\+\+R\+E\+CT -\/ a rectangular structuring element\+: 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


{\itshape E\+\_\+(ij)=1}


\begin{DoxyItemize}
\item M\+O\+R\+P\+H\+\_\+\+E\+L\+L\+I\+P\+SE -\/ an elliptic structuring element, that is, a filled ellipse inscribed into the rectangle {\ttfamily Rect(0, 0, esize.\+width, 0.\+esize.\+height)} 
\item M\+O\+R\+P\+H\+\_\+\+C\+R\+O\+SS -\/ a cross-\/shaped structuring element\+: 
\end{DoxyItemize}

{\itshape E\+\_\+(ij) = 1 if i=anchor.\+y or j=anchor.\+x; 0 otherwise}


\begin{DoxyItemize}
\item C\+V\+\_\+\+S\+H\+A\+P\+E\+\_\+\+C\+U\+S\+T\+OM -\/ custom structuring element (Open\+CV 1.\+x A\+PI) 
\end{DoxyItemize}
\begin{DoxyParams}{Parameters}
{\em ksize} & Size of the structuring element.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#getstructuringelement}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+get\+Structuring\+Element} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a55ca9c014b3e7fcbda05ad5d9e5e2b3e}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a55ca9c014b3e7fcbda05ad5d9e5e2b3e}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!good\+Features\+To\+Track@{good\+Features\+To\+Track}}
\index{good\+Features\+To\+Track@{good\+Features\+To\+Track}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{good\+Features\+To\+Track()}{goodFeaturesToTrack()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+good\+Features\+To\+Track (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}}}]{corners,  }\item[{int}]{max\+Corners,  }\item[{double}]{quality\+Level,  }\item[{double}]{min\+Distance,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{int}]{block\+Size,  }\item[{boolean}]{use\+Harris\+Detector,  }\item[{double}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Determines strong corners on an image.

The function finds the most prominent corners in the image or in the specified image region, as described in \mbox{[}Shi94\mbox{]}\+:


\begin{DoxyItemize}
\item Function calculates the corner quality measure at every source image pixel using the \char`\"{}corner\+Min\+Eigen\+Val\char`\"{} or \char`\"{}corner\+Harris\char`\"{}. 
\item Function performs a non-\/maximum suppression (the local maximums in {\itshape 3 x 3} neighborhood are retained). 
\item The corners with the minimal eigenvalue less than {\itshape quality\+Level $\ast$ max\+\_\+(x,y) quality\+Measure\+Map(x,y)} are rejected. 
\item The remaining corners are sorted by the quality measure in the descending order. 
\item Function throws away each corner for which there is a stronger corner at a distance less than {\ttfamily max\+Distance}. 
\end{DoxyItemize}

The function can be used to initialize a point-\/based tracker of an object.

Note\+: If the function is called with different values {\ttfamily A} and {\ttfamily B} of the parameter {\ttfamily quality\+Level}, and {\ttfamily A} \begin{quote}
\{B\}, the vector of returned corners with {\ttfamily quality\+Level=A} will \end{quote}
be the prefix of the output vector with {\ttfamily quality\+Level=B}.


\begin{DoxyParams}{Parameters}
{\em image} & Input 8-\/bit or floating-\/point 32-\/bit, single-\/channel image. \\
\hline
{\em corners} & Output vector of detected corners. \\
\hline
{\em max\+Corners} & Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. \\
\hline
{\em quality\+Level} & Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see \char`\"{}corner\+Min\+Eigen\+Val\char`\"{}) or the Harris function response (see \char`\"{}corner\+Harris\char`\"{}). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the {\ttfamily quality\+Level=0.\+01}, then all the corners with the quality measure less than 15 are rejected. \\
\hline
{\em min\+Distance} & Minimum possible Euclidean distance between the returned corners. \\
\hline
{\em mask} & Optional region of interest. If the image is not empty (it needs to have the type {\ttfamily C\+V\+\_\+8\+U\+C1} and the same size as {\ttfamily image}), it specifies the region in which the corners are detected. \\
\hline
{\em block\+Size} & Size of an average block for computing a derivative covariation matrix over each pixel neighborhood. See \char`\"{}corner\+Eigen\+Vals\+And\+Vecs\char`\"{}. \\
\hline
{\em use\+Harris\+Detector} & Parameter indicating whether to use a Harris detector (see \char`\"{}corner\+Harris\char`\"{}) or \char`\"{}corner\+Min\+Eigen\+Val\char`\"{}. \\
\hline
{\em k} & Free parameter of the Harris detector.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#goodfeaturestotrack}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+good\+Features\+To\+Track} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aff9b8e4b52de80802161886bd074cdca}{org.\+opencv.\+imgproc.\+Imgproc\+::corner\+Harris}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1video_1_1_video_ad9c2fbb377a485b9619be2c78eaf7cee}{org.\+opencv.\+video.\+Video\+::estimate\+Rigid\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9a5a2f96d413cc9f1ce919942a150a41}{org.\+opencv.\+imgproc.\+Imgproc\+::corner\+Min\+Eigen\+Val}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1video_1_1_video_af905ed0b09b612cdbfd3196135e40ef1}{org.\+opencv.\+video.\+Video\+::calc\+Optical\+Flow\+Pyr\+LK}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1aae3383c84a2d787691a18c05962764}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1aae3383c84a2d787691a18c05962764}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!good\+Features\+To\+Track@{good\+Features\+To\+Track}}
\index{good\+Features\+To\+Track@{good\+Features\+To\+Track}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{good\+Features\+To\+Track()}{goodFeaturesToTrack()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+good\+Features\+To\+Track (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}}}]{corners,  }\item[{int}]{max\+Corners,  }\item[{double}]{quality\+Level,  }\item[{double}]{min\+Distance }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Determines strong corners on an image.

The function finds the most prominent corners in the image or in the specified image region, as described in \mbox{[}Shi94\mbox{]}\+:


\begin{DoxyItemize}
\item Function calculates the corner quality measure at every source image pixel using the \char`\"{}corner\+Min\+Eigen\+Val\char`\"{} or \char`\"{}corner\+Harris\char`\"{}. 
\item Function performs a non-\/maximum suppression (the local maximums in {\itshape 3 x 3} neighborhood are retained). 
\item The corners with the minimal eigenvalue less than {\itshape quality\+Level $\ast$ max\+\_\+(x,y) quality\+Measure\+Map(x,y)} are rejected. 
\item The remaining corners are sorted by the quality measure in the descending order. 
\item Function throws away each corner for which there is a stronger corner at a distance less than {\ttfamily max\+Distance}. 
\end{DoxyItemize}

The function can be used to initialize a point-\/based tracker of an object.

Note\+: If the function is called with different values {\ttfamily A} and {\ttfamily B} of the parameter {\ttfamily quality\+Level}, and {\ttfamily A} \begin{quote}
\{B\}, the vector of returned corners with {\ttfamily quality\+Level=A} will \end{quote}
be the prefix of the output vector with {\ttfamily quality\+Level=B}.


\begin{DoxyParams}{Parameters}
{\em image} & Input 8-\/bit or floating-\/point 32-\/bit, single-\/channel image. \\
\hline
{\em corners} & Output vector of detected corners. \\
\hline
{\em max\+Corners} & Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. \\
\hline
{\em quality\+Level} & Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see \char`\"{}corner\+Min\+Eigen\+Val\char`\"{}) or the Harris function response (see \char`\"{}corner\+Harris\char`\"{}). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the {\ttfamily quality\+Level=0.\+01}, then all the corners with the quality measure less than 15 are rejected. \\
\hline
{\em min\+Distance} & Minimum possible Euclidean distance between the returned corners.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#goodfeaturestotrack}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+good\+Features\+To\+Track} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aff9b8e4b52de80802161886bd074cdca}{org.\+opencv.\+imgproc.\+Imgproc\+::corner\+Harris}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1video_1_1_video_ad9c2fbb377a485b9619be2c78eaf7cee}{org.\+opencv.\+video.\+Video\+::estimate\+Rigid\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9a5a2f96d413cc9f1ce919942a150a41}{org.\+opencv.\+imgproc.\+Imgproc\+::corner\+Min\+Eigen\+Val}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1video_1_1_video_af905ed0b09b612cdbfd3196135e40ef1}{org.\+opencv.\+video.\+Video\+::calc\+Optical\+Flow\+Pyr\+LK}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afdc316be7c75db609235d7f9aa24bdfa}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afdc316be7c75db609235d7f9aa24bdfa}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!grab\+Cut@{grab\+Cut}}
\index{grab\+Cut@{grab\+Cut}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{grab\+Cut()}{grabCut()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+grab\+Cut (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{rect,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{bgd\+Model,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{fgd\+Model,  }\item[{int}]{iter\+Count,  }\item[{int}]{mode }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Runs the Grab\+Cut algorithm.

The function implements the Grab\+Cut image segmentation algorithm (\href{http://en.wikipedia.org/wiki/GrabCut}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Grab\+Cut}). See the sample {\ttfamily grabcut.\+cpp} to learn how to use the function.

Note\+:


\begin{DoxyItemize}
\item An example using the Grab\+Cut algorithm can be found at opencv\+\_\+source\+\_\+code/samples/cpp/grabcut.\+cpp 
\item (Python) An example using the Grab\+Cut algorithm can be found at opencv\+\_\+source\+\_\+code/samples/python2/grabcut.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em img} & Input 8-\/bit 3-\/channel image. \\
\hline
{\em mask} & Input/output 8-\/bit single-\/channel mask. The mask is initialized by the function when {\ttfamily mode} is set to {\ttfamily G\+C\+\_\+\+I\+N\+I\+T\+\_\+\+W\+I\+T\+H\+\_\+\+R\+E\+CT}. Its elements may have one of following values\+: 
\begin{DoxyItemize}
\item G\+C\+\_\+\+B\+GD defines an obvious background pixels. 
\item G\+C\+\_\+\+F\+GD defines an obvious foreground (object) pixel. 
\item G\+C\+\_\+\+P\+R\+\_\+\+B\+GD defines a possible background pixel. 
\item G\+C\+\_\+\+P\+R\+\_\+\+F\+GD defines a possible foreground pixel. 
\end{DoxyItemize}\\
\hline
{\em rect} & R\+OI containing a segmented object. The pixels outside of the R\+OI are marked as \char`\"{}obvious background\char`\"{}. The parameter is only used when {\ttfamily mode==G\+C\+\_\+\+I\+N\+I\+T\+\_\+\+W\+I\+T\+H\+\_\+\+R\+E\+CT}. \\
\hline
{\em bgd\+Model} & Temporary array for the background model. Do not modify it while you are processing the same image. \\
\hline
{\em fgd\+Model} & Temporary arrays for the foreground model. Do not modify it while you are processing the same image. \\
\hline
{\em iter\+Count} & Number of iterations the algorithm should make before returning the result. Note that the result can be refined with further calls with {\ttfamily mode==G\+C\+\_\+\+I\+N\+I\+T\+\_\+\+W\+I\+T\+H\+\_\+\+M\+A\+SK} or {\ttfamily mode==G\+C\+\_\+\+E\+V\+AL}. \\
\hline
{\em mode} & Operation mode that could be one of the following\+: 
\begin{DoxyItemize}
\item G\+C\+\_\+\+I\+N\+I\+T\+\_\+\+W\+I\+T\+H\+\_\+\+R\+E\+CT The function initializes the state and the mask using the provided rectangle. After that it runs {\ttfamily iter\+Count} iterations of the algorithm. 
\item G\+C\+\_\+\+I\+N\+I\+T\+\_\+\+W\+I\+T\+H\+\_\+\+M\+A\+SK The function initializes the state using the provided mask. Note that {\ttfamily G\+C\+\_\+\+I\+N\+I\+T\+\_\+\+W\+I\+T\+H\+\_\+\+R\+E\+CT} and {\ttfamily G\+C\+\_\+\+I\+N\+I\+T\+\_\+\+W\+I\+T\+H\+\_\+\+M\+A\+SK} can be combined. Then, all the pixels outside of the R\+OI are automatically initialized with {\ttfamily G\+C\+\_\+\+B\+GD}. 
\item G\+C\+\_\+\+E\+V\+AL The value means that the algorithm should just resume. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#grabcut}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+grab\+Cut} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8be3ea0718f04a8b17bed9d0a46ba7cc}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8be3ea0718f04a8b17bed9d0a46ba7cc}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!grab\+Cut@{grab\+Cut}}
\index{grab\+Cut@{grab\+Cut}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{grab\+Cut()}{grabCut()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+grab\+Cut (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{img,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{rect,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{bgd\+Model,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{fgd\+Model,  }\item[{int}]{iter\+Count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Runs the Grab\+Cut algorithm.

The function implements the Grab\+Cut image segmentation algorithm (\href{http://en.wikipedia.org/wiki/GrabCut}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Grab\+Cut}). See the sample {\ttfamily grabcut.\+cpp} to learn how to use the function.

Note\+:


\begin{DoxyItemize}
\item An example using the Grab\+Cut algorithm can be found at opencv\+\_\+source\+\_\+code/samples/cpp/grabcut.\+cpp 
\item (Python) An example using the Grab\+Cut algorithm can be found at opencv\+\_\+source\+\_\+code/samples/python2/grabcut.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em img} & Input 8-\/bit 3-\/channel image. \\
\hline
{\em mask} & Input/output 8-\/bit single-\/channel mask. The mask is initialized by the function when {\ttfamily mode} is set to {\ttfamily G\+C\+\_\+\+I\+N\+I\+T\+\_\+\+W\+I\+T\+H\+\_\+\+R\+E\+CT}. Its elements may have one of following values\+: 
\begin{DoxyItemize}
\item G\+C\+\_\+\+B\+GD defines an obvious background pixels. 
\item G\+C\+\_\+\+F\+GD defines an obvious foreground (object) pixel. 
\item G\+C\+\_\+\+P\+R\+\_\+\+B\+GD defines a possible background pixel. 
\item G\+C\+\_\+\+P\+R\+\_\+\+F\+GD defines a possible foreground pixel. 
\end{DoxyItemize}\\
\hline
{\em rect} & R\+OI containing a segmented object. The pixels outside of the R\+OI are marked as \char`\"{}obvious background\char`\"{}. The parameter is only used when {\ttfamily mode==G\+C\+\_\+\+I\+N\+I\+T\+\_\+\+W\+I\+T\+H\+\_\+\+R\+E\+CT}. \\
\hline
{\em bgd\+Model} & Temporary array for the background model. Do not modify it while you are processing the same image. \\
\hline
{\em fgd\+Model} & Temporary arrays for the foreground model. Do not modify it while you are processing the same image. \\
\hline
{\em iter\+Count} & Number of iterations the algorithm should make before returning the result. Note that the result can be refined with further calls with {\ttfamily mode==G\+C\+\_\+\+I\+N\+I\+T\+\_\+\+W\+I\+T\+H\+\_\+\+M\+A\+SK} or {\ttfamily mode==G\+C\+\_\+\+E\+V\+AL}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#grabcut}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+grab\+Cut} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0338b01497ff28dc2c68f353a300cc7a}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0338b01497ff28dc2c68f353a300cc7a}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Hough\+Circles@{Hough\+Circles}}
\index{Hough\+Circles@{Hough\+Circles}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Hough\+Circles()}{HoughCircles()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+Circles (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{circles,  }\item[{int}]{method,  }\item[{double}]{dp,  }\item[{double}]{min\+Dist,  }\item[{double}]{param1,  }\item[{double}]{param2,  }\item[{int}]{min\+Radius,  }\item[{int}]{max\+Radius }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds circles in a grayscale image using the Hough transform.

The function finds circles in a grayscale image using a modification of the Hough transform. Example\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$cv.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$highgui.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$math.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily using namespace cv;}

{\ttfamily }

{\ttfamily }

{\ttfamily int main(int argc, char argv)}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat img, gray;}

{\ttfamily }

{\ttfamily }

{\ttfamily if(argc != 2 \&\& !(img=imread(argv\mbox{[}1\mbox{]}, 1)).data)}

{\ttfamily }

{\ttfamily }

{\ttfamily return -\/1;}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(img, gray, C\+V\+\_\+\+B\+G\+R2\+G\+R\+A\+Y);}

{\ttfamily }

{\ttfamily }

{\ttfamily // smooth it, otherwise a lot of false circles may be detected}

{\ttfamily }

{\ttfamily }

{\ttfamily Gaussian\+Blur(gray, gray, Size(9, 9), 2, 2);}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Vec3f$>$ circles;}

{\ttfamily }

{\ttfamily }

{\ttfamily Hough\+Circles(gray, circles, C\+V\+\_\+\+H\+O\+U\+G\+H\+\_\+\+G\+R\+A\+D\+I\+E\+NT,}

{\ttfamily }

{\ttfamily }

{\ttfamily 2, gray-\/$>$rows/4, 200, 100);}

{\ttfamily }

{\ttfamily }

{\ttfamily for(size\+\_\+t i = 0; i $<$ circles.\+size(); i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily Point center(cv\+Round(circles\mbox{[}i\mbox{]}\mbox{[}0\mbox{]}), cv\+Round(circles\mbox{[}i\mbox{]}\mbox{[}1\mbox{]}));}

{\ttfamily }

{\ttfamily }

{\ttfamily int radius = cv\+Round(circles\mbox{[}i\mbox{]}\mbox{[}2\mbox{]});}

{\ttfamily }

{\ttfamily }

{\ttfamily // draw the circle center}

{\ttfamily }

{\ttfamily }

{\ttfamily circle(img, center, 3, Scalar(0,255,0), -\/1, 8, 0);}

{\ttfamily }

{\ttfamily }

{\ttfamily // draw the circle outline}

{\ttfamily }

{\ttfamily }

{\ttfamily circle(img, center, radius, Scalar(0,0,255), 3, 8, 0);}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}circles\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}circles\char`\"{}, img);}

{\ttfamily }

{\ttfamily }

{\ttfamily return 0;}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: Usually the function detects the centers of circles well. However, it may fail to find correct radii. You can assist to the function by specifying the radius range ({\ttfamily min\+Radius} and {\ttfamily max\+Radius}) if you know it. Or, you may ignore the returned radius, use only the center, and find the correct radius using an additional procedure. }

Note\+:


\begin{DoxyItemize}
\item An example using the Hough circle detector can be found at opencv\+\_\+source\+\_\+code/samples/cpp/houghcircles.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & 8-\/bit, single-\/channel, grayscale input image. \\
\hline
{\em circles} & Output vector of found circles. Each vector is encoded as a 3-\/element floating-\/point vector {\itshape (x, y, radius)}. \\
\hline
{\em method} & Detection method to use. Currently, the only implemented method is {\ttfamily C\+V\+\_\+\+H\+O\+U\+G\+H\+\_\+\+G\+R\+A\+D\+I\+E\+NT}, which is basically {\itshape 21\+HT}, described in \mbox{[}Yuen90\mbox{]}. \\
\hline
{\em dp} & Inverse ratio of the accumulator resolution to the image resolution. For example, if {\ttfamily dp=1}, the accumulator has the same resolution as the input image. If {\ttfamily dp=2}, the accumulator has half as big width and height. \\
\hline
{\em min\+Dist} & Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed. \\
\hline
{\em param1} & First method-\/specific parameter. In case of {\ttfamily C\+V\+\_\+\+H\+O\+U\+G\+H\+\_\+\+G\+R\+A\+D\+I\+E\+NT}, it is the higher threshold of the two passed to the \char`\"{}\+Canny\char`\"{} edge detector (the lower one is twice smaller). \\
\hline
{\em param2} & Second method-\/specific parameter. In case of {\ttfamily C\+V\+\_\+\+H\+O\+U\+G\+H\+\_\+\+G\+R\+A\+D\+I\+E\+NT}, it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first. \\
\hline
{\em min\+Radius} & Minimum circle radius. \\
\hline
{\em max\+Radius} & Maximum circle radius.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghcircles}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+Circles} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac3ca3753976cf3f969df4b25a3f5ef78}{org.\+opencv.\+imgproc.\+Imgproc\+::min\+Enclosing\+Circle}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa1223b61730baf7b52760332c5cdd8f5}{org.\+opencv.\+imgproc.\+Imgproc\+::fit\+Ellipse}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6fa86b567ca08ae92eab90cc998728d9}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6fa86b567ca08ae92eab90cc998728d9}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Hough\+Circles@{Hough\+Circles}}
\index{Hough\+Circles@{Hough\+Circles}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Hough\+Circles()}{HoughCircles()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+Circles (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{circles,  }\item[{int}]{method,  }\item[{double}]{dp,  }\item[{double}]{min\+Dist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds circles in a grayscale image using the Hough transform.

The function finds circles in a grayscale image using a modification of the Hough transform. Example\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$cv.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$highgui.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$math.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily using namespace cv;}

{\ttfamily }

{\ttfamily }

{\ttfamily int main(int argc, char argv)}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat img, gray;}

{\ttfamily }

{\ttfamily }

{\ttfamily if(argc != 2 \&\& !(img=imread(argv\mbox{[}1\mbox{]}, 1)).data)}

{\ttfamily }

{\ttfamily }

{\ttfamily return -\/1;}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(img, gray, C\+V\+\_\+\+B\+G\+R2\+G\+R\+A\+Y);}

{\ttfamily }

{\ttfamily }

{\ttfamily // smooth it, otherwise a lot of false circles may be detected}

{\ttfamily }

{\ttfamily }

{\ttfamily Gaussian\+Blur(gray, gray, Size(9, 9), 2, 2);}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Vec3f$>$ circles;}

{\ttfamily }

{\ttfamily }

{\ttfamily Hough\+Circles(gray, circles, C\+V\+\_\+\+H\+O\+U\+G\+H\+\_\+\+G\+R\+A\+D\+I\+E\+NT,}

{\ttfamily }

{\ttfamily }

{\ttfamily 2, gray-\/$>$rows/4, 200, 100);}

{\ttfamily }

{\ttfamily }

{\ttfamily for(size\+\_\+t i = 0; i $<$ circles.\+size(); i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily Point center(cv\+Round(circles\mbox{[}i\mbox{]}\mbox{[}0\mbox{]}), cv\+Round(circles\mbox{[}i\mbox{]}\mbox{[}1\mbox{]}));}

{\ttfamily }

{\ttfamily }

{\ttfamily int radius = cv\+Round(circles\mbox{[}i\mbox{]}\mbox{[}2\mbox{]});}

{\ttfamily }

{\ttfamily }

{\ttfamily // draw the circle center}

{\ttfamily }

{\ttfamily }

{\ttfamily circle(img, center, 3, Scalar(0,255,0), -\/1, 8, 0);}

{\ttfamily }

{\ttfamily }

{\ttfamily // draw the circle outline}

{\ttfamily }

{\ttfamily }

{\ttfamily circle(img, center, radius, Scalar(0,0,255), 3, 8, 0);}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}circles\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}circles\char`\"{}, img);}

{\ttfamily }

{\ttfamily }

{\ttfamily return 0;}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: Usually the function detects the centers of circles well. However, it may fail to find correct radii. You can assist to the function by specifying the radius range ({\ttfamily min\+Radius} and {\ttfamily max\+Radius}) if you know it. Or, you may ignore the returned radius, use only the center, and find the correct radius using an additional procedure. }

Note\+:


\begin{DoxyItemize}
\item An example using the Hough circle detector can be found at opencv\+\_\+source\+\_\+code/samples/cpp/houghcircles.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & 8-\/bit, single-\/channel, grayscale input image. \\
\hline
{\em circles} & Output vector of found circles. Each vector is encoded as a 3-\/element floating-\/point vector {\itshape (x, y, radius)}. \\
\hline
{\em method} & Detection method to use. Currently, the only implemented method is {\ttfamily C\+V\+\_\+\+H\+O\+U\+G\+H\+\_\+\+G\+R\+A\+D\+I\+E\+NT}, which is basically {\itshape 21\+HT}, described in \mbox{[}Yuen90\mbox{]}. \\
\hline
{\em dp} & Inverse ratio of the accumulator resolution to the image resolution. For example, if {\ttfamily dp=1}, the accumulator has the same resolution as the input image. If {\ttfamily dp=2}, the accumulator has half as big width and height. \\
\hline
{\em min\+Dist} & Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghcircles}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+Circles} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac3ca3753976cf3f969df4b25a3f5ef78}{org.\+opencv.\+imgproc.\+Imgproc\+::min\+Enclosing\+Circle}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa1223b61730baf7b52760332c5cdd8f5}{org.\+opencv.\+imgproc.\+Imgproc\+::fit\+Ellipse}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a28db1a1f638c5882a4f1af67f081522c}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a28db1a1f638c5882a4f1af67f081522c}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Hough\+Lines@{Hough\+Lines}}
\index{Hough\+Lines@{Hough\+Lines}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Hough\+Lines()}{HoughLines()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+Lines (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{lines,  }\item[{double}]{rho,  }\item[{double}]{theta,  }\item[{int}]{threshold,  }\item[{double}]{srn,  }\item[{double}]{stn }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds lines in a binary image using the standard Hough transform.

The function implements the standard or standard multi-\/scale Hough transform algorithm for line detection. See \href{http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm}{\tt http\+://homepages.\+inf.\+ed.\+ac.\+uk/rbf/\+H\+I\+P\+R2/hough.\+htm} for a good explanation of Hough transform. See also the example in \char`\"{}\+Hough\+Lines\+P\char`\"{} description.

Note\+:


\begin{DoxyItemize}
\item An example using the Hough line detector can be found at opencv\+\_\+source\+\_\+code/samples/cpp/houghlines.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & 8-\/bit, single-\/channel binary source image. The image may be modified by the function. \\
\hline
{\em lines} & Output vector of lines. Each line is represented by a two-\/element vector {\itshape (rho, theta)}. {\itshape rho} is the distance from the coordinate origin {\itshape (0,0)} (top-\/left corner of the image). {\itshape theta} is the line rotation angle in radians ({\itshape 0 $\sim$ vertical line, pi/2 $\sim$ horizontal line}). \\
\hline
{\em rho} & Distance resolution of the accumulator in pixels. \\
\hline
{\em theta} & Angle resolution of the accumulator in radians. \\
\hline
{\em threshold} & Accumulator threshold parameter. Only those lines are returned that get enough votes ({\itshape \&gtthreshold}). \\
\hline
{\em srn} & For the multi-\/scale Hough transform, it is a divisor for the distance resolution {\ttfamily rho}. The coarse accumulator distance resolution is {\ttfamily rho} and the accurate accumulator resolution is {\ttfamily rho/srn}. If both {\ttfamily srn=0} and {\ttfamily stn=0}, the classical Hough transform is used. Otherwise, both these parameters should be positive. \\
\hline
{\em stn} & For the multi-\/scale Hough transform, it is a divisor for the distance resolution {\ttfamily theta}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghlines}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+Lines} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6b72bf2114aa1ea4e834451880a5eb8b}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6b72bf2114aa1ea4e834451880a5eb8b}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Hough\+Lines@{Hough\+Lines}}
\index{Hough\+Lines@{Hough\+Lines}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Hough\+Lines()}{HoughLines()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+Lines (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{lines,  }\item[{double}]{rho,  }\item[{double}]{theta,  }\item[{int}]{threshold }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds lines in a binary image using the standard Hough transform.

The function implements the standard or standard multi-\/scale Hough transform algorithm for line detection. See \href{http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm}{\tt http\+://homepages.\+inf.\+ed.\+ac.\+uk/rbf/\+H\+I\+P\+R2/hough.\+htm} for a good explanation of Hough transform. See also the example in \char`\"{}\+Hough\+Lines\+P\char`\"{} description.

Note\+:


\begin{DoxyItemize}
\item An example using the Hough line detector can be found at opencv\+\_\+source\+\_\+code/samples/cpp/houghlines.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & 8-\/bit, single-\/channel binary source image. The image may be modified by the function. \\
\hline
{\em lines} & Output vector of lines. Each line is represented by a two-\/element vector {\itshape (rho, theta)}. {\itshape rho} is the distance from the coordinate origin {\itshape (0,0)} (top-\/left corner of the image). {\itshape theta} is the line rotation angle in radians ({\itshape 0 $\sim$ vertical line, pi/2 $\sim$ horizontal line}). \\
\hline
{\em rho} & Distance resolution of the accumulator in pixels. \\
\hline
{\em theta} & Angle resolution of the accumulator in radians. \\
\hline
{\em threshold} & Accumulator threshold parameter. Only those lines are returned that get enough votes ({\itshape \&gtthreshold}).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghlines}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+Lines} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abcb38549a6c9bd2ec81e601a0a76e4ba}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abcb38549a6c9bd2ec81e601a0a76e4ba}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Hough\+LinesP@{Hough\+LinesP}}
\index{Hough\+LinesP@{Hough\+LinesP}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Hough\+Lines\+P()}{HoughLinesP()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+LinesP (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{lines,  }\item[{double}]{rho,  }\item[{double}]{theta,  }\item[{int}]{threshold,  }\item[{double}]{min\+Line\+Length,  }\item[{double}]{max\+Line\+Gap }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds line segments in a binary image using the probabilistic Hough transform.

The function implements the probabilistic Hough transform algorithm for line detection, described in\mbox{[}Matas00\mbox{]}. See the line detection example below\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily / $\ast$ This is a standalone program. Pass an image name as the first parameter}

{\ttfamily }

{\ttfamily }

{\ttfamily of the program. Switch between standard and probabilistic Hough transform}

{\ttfamily }

{\ttfamily }

{\ttfamily by changing \char`\"{}\#if 1\char`\"{} to \char`\"{}\#if 0\char`\"{} and back $\ast$ /}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$cv.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$highgui.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$math.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily using namespace cv;}

{\ttfamily }

{\ttfamily }

{\ttfamily int main(int argc, char argv)}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat src, dst, color\+\_\+dst;}

{\ttfamily }

{\ttfamily }

{\ttfamily if(argc != 2 $\vert$$\vert$ !(src=imread(argv\mbox{[}1\mbox{]}, 0)).data)}

{\ttfamily }

{\ttfamily }

{\ttfamily return -\/1;}

{\ttfamily }

{\ttfamily }

{\ttfamily Canny(src, dst, 50, 200, 3);}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(dst, color\+\_\+dst, C\+V\+\_\+\+G\+R\+A\+Y2\+B\+G\+R);}

{\ttfamily }

{\ttfamily }

{\ttfamily \#if 0}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Vec2f$>$ lines;}

{\ttfamily }

{\ttfamily }

{\ttfamily Hough\+Lines(dst, lines, 1, C\+V\+\_\+\+P\+I/180, 100);}

{\ttfamily }

{\ttfamily }

{\ttfamily for(size\+\_\+t i = 0; i $<$ lines.\+size(); i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily float rho = lines\mbox{[}i\mbox{]}\mbox{[}0\mbox{]};}

{\ttfamily }

{\ttfamily }

{\ttfamily float theta = lines\mbox{[}i\mbox{]}\mbox{[}1\mbox{]};}

{\ttfamily }

{\ttfamily }

{\ttfamily double a = cos(theta), b = sin(theta);}

{\ttfamily }

{\ttfamily }

{\ttfamily double x0 = a$\ast$rho, y0 = b$\ast$rho;}

{\ttfamily }

{\ttfamily }

{\ttfamily Point pt1(cv\+Round(x0 + 1000$\ast$(-\/b)),}

{\ttfamily }

{\ttfamily }

{\ttfamily cv\+Round(y0 + 1000$\ast$(a)));}

{\ttfamily }

{\ttfamily }

{\ttfamily Point pt2(cv\+Round(x0 -\/ 1000$\ast$(-\/b)),}

{\ttfamily }

{\ttfamily }

{\ttfamily cv\+Round(y0 -\/ 1000$\ast$(a)));}

{\ttfamily }

{\ttfamily }

{\ttfamily line(color\+\_\+dst, pt1, pt2, Scalar(0,0,255), 3, 8);}

{\ttfamily }

{\ttfamily }

{\ttfamily \#else}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Vec4i$>$ lines;}

{\ttfamily }

{\ttfamily }

{\ttfamily Hough\+LinesP(dst, lines, 1, C\+V\+\_\+\+P\+I/180, 80, 30, 10);}

{\ttfamily }

{\ttfamily }

{\ttfamily for(size\+\_\+t i = 0; i $<$ lines.\+size(); i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily line(color\+\_\+dst, Point(lines\mbox{[}i\mbox{]}\mbox{[}0\mbox{]}, lines\mbox{[}i\mbox{]}\mbox{[}1\mbox{]}),}

{\ttfamily }

{\ttfamily }

{\ttfamily Point(lines\mbox{[}i\mbox{]}\mbox{[}2\mbox{]}, lines\mbox{[}i\mbox{]}\mbox{[}3\mbox{]}), Scalar(0,0,255), 3, 8);}

{\ttfamily }

{\ttfamily }

{\ttfamily \#endif}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Source\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Source\char`\"{}, src);}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Detected Lines\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Detected Lines\char`\"{}, color\+\_\+dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily wait\+Key(0);}

{\ttfamily }

{\ttfamily }

{\ttfamily return 0;}

{\ttfamily }

{\ttfamily }

{\ttfamily This is a sample picture the function parameters have been tuned for\+: }

And this is the output of the above program in case of the probabilistic Hough transform\+:


\begin{DoxyParams}{Parameters}
{\em image} & 8-\/bit, single-\/channel binary source image. The image may be modified by the function. \\
\hline
{\em lines} & Output vector of lines. Each line is represented by a 4-\/element vector {\itshape (x\+\_\+1, y\+\_\+1, x\+\_\+2, y\+\_\+2)}, where {\itshape (x\+\_\+1,y\+\_\+1)} and {\itshape (x\+\_\+2, y\+\_\+2)} are the ending points of each detected line segment. \\
\hline
{\em rho} & Distance resolution of the accumulator in pixels. \\
\hline
{\em theta} & Angle resolution of the accumulator in radians. \\
\hline
{\em threshold} & Accumulator threshold parameter. Only those lines are returned that get enough votes ({\itshape \&gtthreshold}). \\
\hline
{\em min\+Line\+Length} & Minimum line length. Line segments shorter than that are rejected. \\
\hline
{\em max\+Line\+Gap} & Maximum allowed gap between points on the same line to link them.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghlinesp}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+LinesP} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af9376e12a80f1305ddc5fb8046220902}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af9376e12a80f1305ddc5fb8046220902}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Hough\+LinesP@{Hough\+LinesP}}
\index{Hough\+LinesP@{Hough\+LinesP}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Hough\+Lines\+P()}{HoughLinesP()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+LinesP (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{lines,  }\item[{double}]{rho,  }\item[{double}]{theta,  }\item[{int}]{threshold }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds line segments in a binary image using the probabilistic Hough transform.

The function implements the probabilistic Hough transform algorithm for line detection, described in\mbox{[}Matas00\mbox{]}. See the line detection example below\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily / $\ast$ This is a standalone program. Pass an image name as the first parameter}

{\ttfamily }

{\ttfamily }

{\ttfamily of the program. Switch between standard and probabilistic Hough transform}

{\ttfamily }

{\ttfamily }

{\ttfamily by changing \char`\"{}\#if 1\char`\"{} to \char`\"{}\#if 0\char`\"{} and back $\ast$ /}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$cv.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$highgui.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily \#include $<$math.\+h$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily using namespace cv;}

{\ttfamily }

{\ttfamily }

{\ttfamily int main(int argc, char argv)}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat src, dst, color\+\_\+dst;}

{\ttfamily }

{\ttfamily }

{\ttfamily if(argc != 2 $\vert$$\vert$ !(src=imread(argv\mbox{[}1\mbox{]}, 0)).data)}

{\ttfamily }

{\ttfamily }

{\ttfamily return -\/1;}

{\ttfamily }

{\ttfamily }

{\ttfamily Canny(src, dst, 50, 200, 3);}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(dst, color\+\_\+dst, C\+V\+\_\+\+G\+R\+A\+Y2\+B\+G\+R);}

{\ttfamily }

{\ttfamily }

{\ttfamily \#if 0}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Vec2f$>$ lines;}

{\ttfamily }

{\ttfamily }

{\ttfamily Hough\+Lines(dst, lines, 1, C\+V\+\_\+\+P\+I/180, 100);}

{\ttfamily }

{\ttfamily }

{\ttfamily for(size\+\_\+t i = 0; i $<$ lines.\+size(); i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily float rho = lines\mbox{[}i\mbox{]}\mbox{[}0\mbox{]};}

{\ttfamily }

{\ttfamily }

{\ttfamily float theta = lines\mbox{[}i\mbox{]}\mbox{[}1\mbox{]};}

{\ttfamily }

{\ttfamily }

{\ttfamily double a = cos(theta), b = sin(theta);}

{\ttfamily }

{\ttfamily }

{\ttfamily double x0 = a$\ast$rho, y0 = b$\ast$rho;}

{\ttfamily }

{\ttfamily }

{\ttfamily Point pt1(cv\+Round(x0 + 1000$\ast$(-\/b)),}

{\ttfamily }

{\ttfamily }

{\ttfamily cv\+Round(y0 + 1000$\ast$(a)));}

{\ttfamily }

{\ttfamily }

{\ttfamily Point pt2(cv\+Round(x0 -\/ 1000$\ast$(-\/b)),}

{\ttfamily }

{\ttfamily }

{\ttfamily cv\+Round(y0 -\/ 1000$\ast$(a)));}

{\ttfamily }

{\ttfamily }

{\ttfamily line(color\+\_\+dst, pt1, pt2, Scalar(0,0,255), 3, 8);}

{\ttfamily }

{\ttfamily }

{\ttfamily \#else}

{\ttfamily }

{\ttfamily }

{\ttfamily vector$<$\+Vec4i$>$ lines;}

{\ttfamily }

{\ttfamily }

{\ttfamily Hough\+LinesP(dst, lines, 1, C\+V\+\_\+\+P\+I/180, 80, 30, 10);}

{\ttfamily }

{\ttfamily }

{\ttfamily for(size\+\_\+t i = 0; i $<$ lines.\+size(); i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily line(color\+\_\+dst, Point(lines\mbox{[}i\mbox{]}\mbox{[}0\mbox{]}, lines\mbox{[}i\mbox{]}\mbox{[}1\mbox{]}),}

{\ttfamily }

{\ttfamily }

{\ttfamily Point(lines\mbox{[}i\mbox{]}\mbox{[}2\mbox{]}, lines\mbox{[}i\mbox{]}\mbox{[}3\mbox{]}), Scalar(0,0,255), 3, 8);}

{\ttfamily }

{\ttfamily }

{\ttfamily \#endif}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Source\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Source\char`\"{}, src);}

{\ttfamily }

{\ttfamily }

{\ttfamily named\+Window(\char`\"{}\+Detected Lines\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily imshow(\char`\"{}\+Detected Lines\char`\"{}, color\+\_\+dst);}

{\ttfamily }

{\ttfamily }

{\ttfamily wait\+Key(0);}

{\ttfamily }

{\ttfamily }

{\ttfamily return 0;}

{\ttfamily }

{\ttfamily }

{\ttfamily This is a sample picture the function parameters have been tuned for\+: }

And this is the output of the above program in case of the probabilistic Hough transform\+:


\begin{DoxyParams}{Parameters}
{\em image} & 8-\/bit, single-\/channel binary source image. The image may be modified by the function. \\
\hline
{\em lines} & Output vector of lines. Each line is represented by a 4-\/element vector {\itshape (x\+\_\+1, y\+\_\+1, x\+\_\+2, y\+\_\+2)}, where {\itshape (x\+\_\+1,y\+\_\+1)} and {\itshape (x\+\_\+2, y\+\_\+2)} are the ending points of each detected line segment. \\
\hline
{\em rho} & Distance resolution of the accumulator in pixels. \\
\hline
{\em theta} & Angle resolution of the accumulator in radians. \\
\hline
{\em threshold} & Accumulator threshold parameter. Only those lines are returned that get enough votes ({\itshape \&gtthreshold}).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#houghlinesp}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Hough\+LinesP} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a98bb53e1f35c2f318b22de3b4bc753e1}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a98bb53e1f35c2f318b22de3b4bc753e1}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Hu\+Moments@{Hu\+Moments}}
\index{Hu\+Moments@{Hu\+Moments}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Hu\+Moments()}{HuMoments()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Hu\+Moments (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}}}]{m,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{hu }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates seven Hu invariants.

The function calculates seven Hu invariants (introduced in \mbox{[}Hu62\mbox{]}; see also \href{http://en.wikipedia.org/wiki/Image_moment}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Image\+\_\+moment}) defined as\+:

{\itshape hu\mbox{[}0\mbox{]}= eta \+\_\+20+ eta \+\_\+02 hu\mbox{[}1\mbox{]}=(eta \+\_\+20-\/ eta \+\_\+02)$^\wedge$2+4 eta \+\_\+11$^\wedge$2 hu\mbox{[}2\mbox{]}=(eta \+\_\+30-\/3 eta \+\_\+12)$^\wedge$2+ (3 eta \+\_\+21-\/ eta \+\_\+03)$^\wedge$2 hu\mbox{[}3\mbox{]}=(eta \+\_\+30+ eta \+\_\+12)$^\wedge$2+ (eta \+\_\+21+ eta \+\_\+03)$^\wedge$2 hu\mbox{[}4\mbox{]}=(eta \+\_\+30-\/3 eta \+\_\+12)(eta \+\_\+30+ eta \+\_\+12)\mbox{[}(eta \+\_\+30+ eta \+\_\+12)$^\wedge$2-\/3(eta \+\_\+21+ eta \+\_\+03)$^\wedge$2\mbox{]}+(3 eta \+\_\+21-\/ eta \+\_\+03)(eta \+\_\+21+ eta \+\_\+03)\mbox{[}3(eta \+\_\+30+ eta \+\_\+12)$^\wedge$2-\/(eta \+\_\+21+ eta \+\_\+03)$^\wedge$2\mbox{]} hu\mbox{[}5\mbox{]}=(eta \+\_\+20-\/ eta \+\_\+02)\mbox{[}(eta \+\_\+30+ eta \+\_\+12)$^\wedge$2-\/ (eta \+\_\+21+ eta \+\_\+03)$^\wedge$2\mbox{]}+4 eta \+\_\+11(eta \+\_\+30+ eta \+\_\+12)(eta \+\_\+21+ eta \+\_\+03) hu\mbox{[}6\mbox{]}=(3 eta \+\_\+21-\/ eta \+\_\+03)(eta \+\_\+21+ eta \+\_\+03)\mbox{[}3(eta \+\_\+30+ eta \+\_\+12)$^\wedge$2-\/(eta \+\_\+21+ eta \+\_\+03)$^\wedge$2\mbox{]}-\/(eta \+\_\+30-\/3 eta \+\_\+12)(eta \+\_\+21+ eta \+\_\+03)\mbox{[}3(eta \+\_\+30+ eta \+\_\+12)$^\wedge$2-\/(eta \+\_\+21+ eta \+\_\+03)$^\wedge$2\mbox{]} }

where {\itshape eta\+\_\+(ji)} stands for {\itshape Moments.\+nu\+\_\+(ji)}.

These values are proved to be invariants to the image scale, rotation, and reflection except the seventh one, whose sign is changed by reflection. This invariance is proved with the assumption of infinite image resolution. In case of raster images, the computed Hu invariants for the original and transformed images are a bit different.


\begin{DoxyParams}{Parameters}
{\em m} & a m \\
\hline
{\em hu} & Output Hu invariants.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#humoments}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Hu\+Moments} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a615b8e00934e682b9f0fa511996b4434}{org.\+opencv.\+imgproc.\+Imgproc\+::match\+Shapes}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae7ecce50c4e0db8881a8a59a02a3fdf3}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae7ecce50c4e0db8881a8a59a02a3fdf3}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!init\+Undistort\+Rectify\+Map@{init\+Undistort\+Rectify\+Map}}
\index{init\+Undistort\+Rectify\+Map@{init\+Undistort\+Rectify\+Map}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{init\+Undistort\+Rectify\+Map()}{initUndistortRectifyMap()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+init\+Undistort\+Rectify\+Map (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{new\+Camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{size,  }\item[{int}]{m1type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes the undistortion and rectification transformation map.

The function computes the joint undistortion and rectification transformation and represents the result in the form of maps for \char`\"{}remap\char`\"{}. The undistorted image looks like original, as if it is captured with a camera using the camera matrix {\ttfamily =new\+Camera\+Matrix} and zero distortion. In case of a monocular camera, {\ttfamily new\+Camera\+Matrix} is usually equal to {\ttfamily camera\+Matrix}, or it can be computed by \char`\"{}get\+Optimal\+New\+Camera\+Matrix\char`\"{} for a better control over scaling. In case of a stereo camera, {\ttfamily new\+Camera\+Matrix} is normally set to {\ttfamily P1} or {\ttfamily P2} computed by \char`\"{}stereo\+Rectify\char`\"{}.

Also, this new camera is oriented differently in the coordinate space, according to {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}}. That, for example, helps to align two heads of a stereo camera so that the epipolar lines on both images become horizontal and have the same y-\/ coordinate (in case of a horizontally aligned stereo camera).

The function actually builds the maps for the inverse mapping algorithm that is used by \char`\"{}remap\char`\"{}. That is, for each pixel {\itshape (u, v)} in the destination (corrected and rectified) image, the function computes the corresponding coordinates in the source image (that is, in the original image from camera). The following process is applied\+:

{\itshape x $<$-\/ (u -\/ (c\textquotesingle{})\+\_\+x)/(f\textquotesingle{})\+\_\+x y $<$-\/ (v -\/ (c\textquotesingle{})\+\_\+y)/(f\textquotesingle{})\+\_\+y (\mbox{[}X Y W\mbox{]}) $^\wedge$T $<$-\/ R$^\wedge$(-\/1)$\ast$\mbox{[}x y 1\mbox{]}$^\wedge$T x\textquotesingle{} $<$-\/ X/W y\textquotesingle{} $<$-\/ Y/W x\char`\"{} $<$-\/ x\textquotesingle{} (1 + k\+\_\+1 r$^\wedge$2 + k\+\_\+2 r$^\wedge$4 + k\+\_\+3 r$^\wedge$6) + 2p\+\_\+1 x\textquotesingle{} y\textquotesingle{} + p\+\_\+2(r$^\wedge$2 + 2 x\textquotesingle{}$^\wedge$2)
y\char`\"{} $<$-\/ y\textquotesingle{} (1 + k\+\_\+1 r$^\wedge$2 + k\+\_\+2 r$^\wedge$4 + k\+\_\+3 r$^\wedge$6) + p\+\_\+1(r$^\wedge$2 + 2 y\textquotesingle{}$^\wedge$2) + 2 p\+\_\+2 x\textquotesingle{} y\textquotesingle{} map\+\_\+x(u,v) $<$-\/ x\char`\"{} f\+\_\+x + c\+\_\+x
map\+\_\+y(u,v) $<$-\/ y\char`\"{} f\+\_\+y + c\+\_\+y }

where {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{]})} are the distortion coefficients.

In case of a stereo camera, this function is called twice\+: once for each camera head, after \char`\"{}stereo\+Rectify\char`\"{}, which in its turn is called after \char`\"{}stereo\+Calibrate\char`\"{}. But if the stereo camera was not calibrated, it is still possible to compute the rectification transformations directly from the fundamental matrix using \char`\"{}stereo\+Rectify\+Uncalibrated\char`\"{}. For each camera, the function computes homography {\ttfamily H} as the rectification transformation in a pixel domain, not a rotation matrix {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}} in 3D space. {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}} can be computed from {\ttfamily H} as

{\itshape \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} = camera\+Matrix $^\wedge$(-\/1) $\ast$ H $\ast$ camera\+Matrix}

where {\ttfamily camera\+Matrix} can be chosen arbitrarily.


\begin{DoxyParams}{Parameters}
{\em camera\+Matrix} & Input camera matrix {\itshape A= }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x 0 c\+\_\+x$\vert$ $\vert$0 f\+\_\+y c\+\_\+y$\vert$ $\vert$0 0 1$\vert$ .

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed. \\
\hline
{\em \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}} & Optional rectification transformation in the object space (3x3 matrix). {\ttfamily R1} or {\ttfamily R2}, computed by \char`\"{}stereo\+Rectify\char`\"{} can be passed here. If the matrix is empty, the identity transformation is assumed. In {\ttfamily cv\+Init\+Undistort\+Map} \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} assumed to be an identity matrix. \\
\hline
{\em new\+Camera\+Matrix} & New camera matrix {\itshape A\textquotesingle{}= }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x\textquotesingle{} 0 c\+\_\+x\textquotesingle{}$\vert$ $\vert$0 f\+\_\+y\textquotesingle{} c\+\_\+y\textquotesingle{}$\vert$ $\vert$0 0 1$\vert$ }.

{\itshape  
\begin{DoxyParams}{Parameters}
{\em size} & Undistorted image size. \\
\hline
{\em m1type} & Type of the first output map that can be {\ttfamily C\+V\+\_\+32\+F\+C1} or {\ttfamily C\+V\+\_\+16\+S\+C2}. See \char`\"{}convert\+Maps\char`\"{} for details. \\
\hline
{\em map1} & The first output map. \\
\hline
{\em map2} & The second output map.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#initundistortrectifymap}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+init\+Undistort\+Rectify\+Map} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a91465eaccc847b26a082809dcd6c35bf}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a91465eaccc847b26a082809dcd6c35bf}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!init\+Wide\+Angle\+Proj\+Map@{init\+Wide\+Angle\+Proj\+Map}}
\index{init\+Wide\+Angle\+Proj\+Map@{init\+Wide\+Angle\+Proj\+Map}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{init\+Wide\+Angle\+Proj\+Map()}{initWideAngleProjMap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static float org.\+opencv.\+imgproc.\+Imgproc.\+init\+Wide\+Angle\+Proj\+Map (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{int}]{dest\+Image\+Width,  }\item[{int}]{m1type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map2,  }\item[{int}]{proj\+Type,  }\item[{double}]{alpha }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2e0a674f9382040bad9b7f245cdb1bbd}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2e0a674f9382040bad9b7f245cdb1bbd}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!init\+Wide\+Angle\+Proj\+Map@{init\+Wide\+Angle\+Proj\+Map}}
\index{init\+Wide\+Angle\+Proj\+Map@{init\+Wide\+Angle\+Proj\+Map}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{init\+Wide\+Angle\+Proj\+Map()}{initWideAngleProjMap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static float org.\+opencv.\+imgproc.\+Imgproc.\+init\+Wide\+Angle\+Proj\+Map (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{image\+Size,  }\item[{int}]{dest\+Image\+Width,  }\item[{int}]{m1type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a44841cd68ca7d5aeba8b98f886a3f8c9}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a44841cd68ca7d5aeba8b98f886a3f8c9}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!integral@{integral}}
\index{integral@{integral}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{integral()}{integral()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+integral (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{sum,  }\item[{int}]{sdepth }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the integral of an image.

The functions calculate one or more integral images for the source image as follows\+:

{\itshape sum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)}

{\itshape sqsum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)$^\wedge$2}

{\itshape tilted(\+X,\+Y) = sum(by\+: y\&ltY,abs(x-\/\+X+1) $<$= Y-\/y-\/1) image(x,y)}

Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-\/right or rotated rectangular region of the image in a constant time, for example\+:

{\itshape sum(by\+: x\+\_\+1 $<$= x \&lt x\+\_\+2, y\+\_\+1 $<$= y \&lt y\+\_\+2) image(x,y) = sum(x\+\_\+2,y\+\_\+2)-\/ sum(x\+\_\+1,y\+\_\+2)-\/ sum(x\+\_\+2,y\+\_\+1)+ sum(x\+\_\+1,y\+\_\+1)}

It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-\/channel images, sums for each channel are accumulated independently.

As a practical example, the next figure shows the calculation of the integral of a straight rectangle {\ttfamily Rect(3,3,3,2)} and of a tilted rectangle {\ttfamily Rect(5,1,2,3)}. The selected pixels in the original {\ttfamily image} are shown, as well as the relative pixels in the integral images {\ttfamily sum} and {\ttfamily tilted}.


\begin{DoxyParams}{Parameters}
{\em src} & a src \\
\hline
{\em sum} & integral image as {\itshape (W+1)x(H+1)}, 32-\/bit integer or floating-\/point (32f or 64f). \\
\hline
{\em sdepth} & desired depth of the integral and the tilted integral images, {\ttfamily C\+V\+\_\+32S}, {\ttfamily C\+V\+\_\+32F}, or {\ttfamily C\+V\+\_\+64F}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+integral} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af1ddaebf0a329d81acc73b949d229c14}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af1ddaebf0a329d81acc73b949d229c14}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!integral@{integral}}
\index{integral@{integral}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{integral()}{integral()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+integral (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{sum }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the integral of an image.

The functions calculate one or more integral images for the source image as follows\+:

{\itshape sum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)}

{\itshape sqsum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)$^\wedge$2}

{\itshape tilted(\+X,\+Y) = sum(by\+: y\&ltY,abs(x-\/\+X+1) $<$= Y-\/y-\/1) image(x,y)}

Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-\/right or rotated rectangular region of the image in a constant time, for example\+:

{\itshape sum(by\+: x\+\_\+1 $<$= x \&lt x\+\_\+2, y\+\_\+1 $<$= y \&lt y\+\_\+2) image(x,y) = sum(x\+\_\+2,y\+\_\+2)-\/ sum(x\+\_\+1,y\+\_\+2)-\/ sum(x\+\_\+2,y\+\_\+1)+ sum(x\+\_\+1,y\+\_\+1)}

It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-\/channel images, sums for each channel are accumulated independently.

As a practical example, the next figure shows the calculation of the integral of a straight rectangle {\ttfamily Rect(3,3,3,2)} and of a tilted rectangle {\ttfamily Rect(5,1,2,3)}. The selected pixels in the original {\ttfamily image} are shown, as well as the relative pixels in the integral images {\ttfamily sum} and {\ttfamily tilted}.


\begin{DoxyParams}{Parameters}
{\em src} & a src \\
\hline
{\em sum} & integral image as {\itshape (W+1)x(H+1)}, 32-\/bit integer or floating-\/point (32f or 64f).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+integral} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9df7bb343fe42a9a1fc27e46ec4c54fe}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9df7bb343fe42a9a1fc27e46ec4c54fe}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!integral2@{integral2}}
\index{integral2@{integral2}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{integral2()}{integral2()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+integral2 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{sum,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{sqsum,  }\item[{int}]{sdepth }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the integral of an image.

The functions calculate one or more integral images for the source image as follows\+:

{\itshape sum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)}

{\itshape sqsum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)$^\wedge$2}

{\itshape tilted(\+X,\+Y) = sum(by\+: y\&ltY,abs(x-\/\+X+1) $<$= Y-\/y-\/1) image(x,y)}

Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-\/right or rotated rectangular region of the image in a constant time, for example\+:

{\itshape sum(by\+: x\+\_\+1 $<$= x \&lt x\+\_\+2, y\+\_\+1 $<$= y \&lt y\+\_\+2) image(x,y) = sum(x\+\_\+2,y\+\_\+2)-\/ sum(x\+\_\+1,y\+\_\+2)-\/ sum(x\+\_\+2,y\+\_\+1)+ sum(x\+\_\+1,y\+\_\+1)}

It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-\/channel images, sums for each channel are accumulated independently.

As a practical example, the next figure shows the calculation of the integral of a straight rectangle {\ttfamily Rect(3,3,3,2)} and of a tilted rectangle {\ttfamily Rect(5,1,2,3)}. The selected pixels in the original {\ttfamily image} are shown, as well as the relative pixels in the integral images {\ttfamily sum} and {\ttfamily tilted}.


\begin{DoxyParams}{Parameters}
{\em src} & a src \\
\hline
{\em sum} & integral image as {\itshape (W+1)x(H+1)}, 32-\/bit integer or floating-\/point (32f or 64f). \\
\hline
{\em sqsum} & integral image for squared pixel values; it is {\itshape (W+1)x(H+1)}, double-\/precision floating-\/point (64f) array. \\
\hline
{\em sdepth} & desired depth of the integral and the tilted integral images, {\ttfamily C\+V\+\_\+32S}, {\ttfamily C\+V\+\_\+32F}, or {\ttfamily C\+V\+\_\+64F}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+integral} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a568b82028d35989917fbd0eefb3aaee5}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a568b82028d35989917fbd0eefb3aaee5}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!integral2@{integral2}}
\index{integral2@{integral2}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{integral2()}{integral2()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+integral2 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{sum,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{sqsum }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the integral of an image.

The functions calculate one or more integral images for the source image as follows\+:

{\itshape sum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)}

{\itshape sqsum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)$^\wedge$2}

{\itshape tilted(\+X,\+Y) = sum(by\+: y\&ltY,abs(x-\/\+X+1) $<$= Y-\/y-\/1) image(x,y)}

Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-\/right or rotated rectangular region of the image in a constant time, for example\+:

{\itshape sum(by\+: x\+\_\+1 $<$= x \&lt x\+\_\+2, y\+\_\+1 $<$= y \&lt y\+\_\+2) image(x,y) = sum(x\+\_\+2,y\+\_\+2)-\/ sum(x\+\_\+1,y\+\_\+2)-\/ sum(x\+\_\+2,y\+\_\+1)+ sum(x\+\_\+1,y\+\_\+1)}

It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-\/channel images, sums for each channel are accumulated independently.

As a practical example, the next figure shows the calculation of the integral of a straight rectangle {\ttfamily Rect(3,3,3,2)} and of a tilted rectangle {\ttfamily Rect(5,1,2,3)}. The selected pixels in the original {\ttfamily image} are shown, as well as the relative pixels in the integral images {\ttfamily sum} and {\ttfamily tilted}.


\begin{DoxyParams}{Parameters}
{\em src} & a src \\
\hline
{\em sum} & integral image as {\itshape (W+1)x(H+1)}, 32-\/bit integer or floating-\/point (32f or 64f). \\
\hline
{\em sqsum} & integral image for squared pixel values; it is {\itshape (W+1)x(H+1)}, double-\/precision floating-\/point (64f) array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+integral} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a4e6458cea7a26ba5d93f259aa4270553}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a4e6458cea7a26ba5d93f259aa4270553}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!integral3@{integral3}}
\index{integral3@{integral3}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{integral3()}{integral3()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+integral3 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{sum,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{sqsum,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tilted,  }\item[{int}]{sdepth }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the integral of an image.

The functions calculate one or more integral images for the source image as follows\+:

{\itshape sum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)}

{\itshape sqsum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)$^\wedge$2}

{\itshape tilted(\+X,\+Y) = sum(by\+: y\&ltY,abs(x-\/\+X+1) $<$= Y-\/y-\/1) image(x,y)}

Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-\/right or rotated rectangular region of the image in a constant time, for example\+:

{\itshape sum(by\+: x\+\_\+1 $<$= x \&lt x\+\_\+2, y\+\_\+1 $<$= y \&lt y\+\_\+2) image(x,y) = sum(x\+\_\+2,y\+\_\+2)-\/ sum(x\+\_\+1,y\+\_\+2)-\/ sum(x\+\_\+2,y\+\_\+1)+ sum(x\+\_\+1,y\+\_\+1)}

It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-\/channel images, sums for each channel are accumulated independently.

As a practical example, the next figure shows the calculation of the integral of a straight rectangle {\ttfamily Rect(3,3,3,2)} and of a tilted rectangle {\ttfamily Rect(5,1,2,3)}. The selected pixels in the original {\ttfamily image} are shown, as well as the relative pixels in the integral images {\ttfamily sum} and {\ttfamily tilted}.


\begin{DoxyParams}{Parameters}
{\em src} & a src \\
\hline
{\em sum} & integral image as {\itshape (W+1)x(H+1)}, 32-\/bit integer or floating-\/point (32f or 64f). \\
\hline
{\em sqsum} & integral image for squared pixel values; it is {\itshape (W+1)x(H+1)}, double-\/precision floating-\/point (64f) array. \\
\hline
{\em tilted} & integral for the image rotated by 45 degrees; it is {\itshape (W+1)x(H+1)} array with the same data type as {\ttfamily sum}. \\
\hline
{\em sdepth} & desired depth of the integral and the tilted integral images, {\ttfamily C\+V\+\_\+32S}, {\ttfamily C\+V\+\_\+32F}, or {\ttfamily C\+V\+\_\+64F}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+integral} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa4e01b9d9963a4f5be66b8a71c742094}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa4e01b9d9963a4f5be66b8a71c742094}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!integral3@{integral3}}
\index{integral3@{integral3}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{integral3()}{integral3()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+integral3 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{sum,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{sqsum,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{tilted }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the integral of an image.

The functions calculate one or more integral images for the source image as follows\+:

{\itshape sum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)}

{\itshape sqsum(\+X,\+Y) = sum(by\+: x\&lt\+X,y\&lt\+Y) image(x,y)$^\wedge$2}

{\itshape tilted(\+X,\+Y) = sum(by\+: y\&ltY,abs(x-\/\+X+1) $<$= Y-\/y-\/1) image(x,y)}

Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-\/right or rotated rectangular region of the image in a constant time, for example\+:

{\itshape sum(by\+: x\+\_\+1 $<$= x \&lt x\+\_\+2, y\+\_\+1 $<$= y \&lt y\+\_\+2) image(x,y) = sum(x\+\_\+2,y\+\_\+2)-\/ sum(x\+\_\+1,y\+\_\+2)-\/ sum(x\+\_\+2,y\+\_\+1)+ sum(x\+\_\+1,y\+\_\+1)}

It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-\/channel images, sums for each channel are accumulated independently.

As a practical example, the next figure shows the calculation of the integral of a straight rectangle {\ttfamily Rect(3,3,3,2)} and of a tilted rectangle {\ttfamily Rect(5,1,2,3)}. The selected pixels in the original {\ttfamily image} are shown, as well as the relative pixels in the integral images {\ttfamily sum} and {\ttfamily tilted}.


\begin{DoxyParams}{Parameters}
{\em src} & a src \\
\hline
{\em sum} & integral image as {\itshape (W+1)x(H+1)}, 32-\/bit integer or floating-\/point (32f or 64f). \\
\hline
{\em sqsum} & integral image for squared pixel values; it is {\itshape (W+1)x(H+1)}, double-\/precision floating-\/point (64f) array. \\
\hline
{\em tilted} & integral for the image rotated by 45 degrees; it is {\itshape (W+1)x(H+1)} array with the same data type as {\ttfamily sum}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#integral}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+integral} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a69e8aafe58e0ea526c3efca2a41542da}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a69e8aafe58e0ea526c3efca2a41542da}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!intersect\+Convex\+Convex@{intersect\+Convex\+Convex}}
\index{intersect\+Convex\+Convex@{intersect\+Convex\+Convex}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{intersect\+Convex\+Convex()}{intersectConvexConvex()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static float org.\+opencv.\+imgproc.\+Imgproc.\+intersect\+Convex\+Convex (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{\+\_\+p1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{\+\_\+p2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{\+\_\+p12,  }\item[{boolean}]{handle\+Nested }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_acd39a01ff6e0be8c297243ee0d006ab9}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_acd39a01ff6e0be8c297243ee0d006ab9}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!intersect\+Convex\+Convex@{intersect\+Convex\+Convex}}
\index{intersect\+Convex\+Convex@{intersect\+Convex\+Convex}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{intersect\+Convex\+Convex()}{intersectConvexConvex()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static float org.\+opencv.\+imgproc.\+Imgproc.\+intersect\+Convex\+Convex (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{\+\_\+p1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{\+\_\+p2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{\+\_\+p12 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aacadce25fcade314666c72930c0af3d1}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aacadce25fcade314666c72930c0af3d1}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!invert\+Affine\+Transform@{invert\+Affine\+Transform}}
\index{invert\+Affine\+Transform@{invert\+Affine\+Transform}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{invert\+Affine\+Transform()}{invertAffineTransform()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+invert\+Affine\+Transform (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{M,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{iM }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Inverts an affine transformation.

The function computes an inverse affine transformation represented by {\itshape 2 x 3} matrix {\ttfamily M} \+:

{\itshape a\+\_\+11 a\+\_\+12 b\+\_\+1 a\+\_\+21 a\+\_\+22 b\+\_\+2 }

The result is also a {\itshape 2 x 3} matrix of the same type as {\ttfamily M}.


\begin{DoxyParams}{Parameters}
{\em M} & Original affine transformation. \\
\hline
{\em iM} & Output reverse affine transformation.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#invertaffinetransform}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+invert\+Affine\+Transform} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a776c38eea614512469ac8192d57b5755}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a776c38eea614512469ac8192d57b5755}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!is\+Contour\+Convex@{is\+Contour\+Convex}}
\index{is\+Contour\+Convex@{is\+Contour\+Convex}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{is\+Contour\+Convex()}{isContourConvex()}}
{\footnotesize\ttfamily static boolean org.\+opencv.\+imgproc.\+Imgproc.\+is\+Contour\+Convex (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point}{Mat\+Of\+Point}}}]{contour }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Tests a contour convexity.

The function tests whether the input contour is convex or not. The contour must be simple, that is, without self-\/intersections. Otherwise, the function output is undefined.


\begin{DoxyParams}{Parameters}
{\em contour} & Input vector of 2D points, stored in\+: 
\begin{DoxyItemize}
\item {\ttfamily std.\+vector$<$$>$} or {\ttfamily Mat} (C++ interface) 
\item {\ttfamily Cv\+Seq$\ast$} or {\ttfamily Cv\+Mat$\ast$} (C interface) 
\item Nx2 numpy array (Python interface) 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#iscontourconvex}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+is\+Contour\+Convex} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_add62d4b55bc4e7cc4faca4a77f6d3f94}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_add62d4b55bc4e7cc4faca4a77f6d3f94}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Laplacian@{Laplacian}}
\index{Laplacian@{Laplacian}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Laplacian()}{Laplacian()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Laplacian (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{int}]{ksize,  }\item[{double}]{scale,  }\item[{double}]{delta,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the Laplacian of an image.

The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator\+:

{\itshape dst = Delta src = (d$^\wedge$2 src)/(dx$^\wedge$2) + (d$^\wedge$2 src)/(dy$^\wedge$2)}

This is done when {\ttfamily ksize $>$ 1}. When {\ttfamily ksize == 1}, the Laplacian is computed by filtering the image with the following {\itshape 3 x 3} aperture\+:

{\itshape vecthreethree 0101(-\/4)1010}

Note\+:


\begin{DoxyItemize}
\item An example using the Laplace transformation for edge detection can be found at opencv\+\_\+source\+\_\+code/samples/cpp/laplace.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & Desired depth of the destination image. \\
\hline
{\em ksize} & Aperture size used to compute the second-\/derivative filters. See \char`\"{}get\+Deriv\+Kernels\char`\"{} for details. The size must be positive and odd. \\
\hline
{\em scale} & Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See \char`\"{}get\+Deriv\+Kernels\char`\"{} for details. \\
\hline
{\em delta} & Optional delta value that is added to the results prior to storing them in {\ttfamily dst}. \\
\hline
{\em border\+Type} & Pixel extrapolation method. See \char`\"{}border\+Interpolate\char`\"{} for details.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#laplacian}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Laplacian} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c9e2fdd65ecd76ae9135e33cfb9a99}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Scharr}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a85a8cac062c05efeecf99de50f3ab8d7}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Sobel}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a0b5f6b5d9d7519bb45c57460d697e7}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a0b5f6b5d9d7519bb45c57460d697e7}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Laplacian@{Laplacian}}
\index{Laplacian@{Laplacian}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Laplacian()}{Laplacian()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Laplacian (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{int}]{ksize,  }\item[{double}]{scale,  }\item[{double}]{delta }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the Laplacian of an image.

The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator\+:

{\itshape dst = Delta src = (d$^\wedge$2 src)/(dx$^\wedge$2) + (d$^\wedge$2 src)/(dy$^\wedge$2)}

This is done when {\ttfamily ksize $>$ 1}. When {\ttfamily ksize == 1}, the Laplacian is computed by filtering the image with the following {\itshape 3 x 3} aperture\+:

{\itshape vecthreethree 0101(-\/4)1010}

Note\+:


\begin{DoxyItemize}
\item An example using the Laplace transformation for edge detection can be found at opencv\+\_\+source\+\_\+code/samples/cpp/laplace.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & Desired depth of the destination image. \\
\hline
{\em ksize} & Aperture size used to compute the second-\/derivative filters. See \char`\"{}get\+Deriv\+Kernels\char`\"{} for details. The size must be positive and odd. \\
\hline
{\em scale} & Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See \char`\"{}get\+Deriv\+Kernels\char`\"{} for details. \\
\hline
{\em delta} & Optional delta value that is added to the results prior to storing them in {\ttfamily dst}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#laplacian}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Laplacian} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c9e2fdd65ecd76ae9135e33cfb9a99}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Scharr}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a85a8cac062c05efeecf99de50f3ab8d7}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Sobel}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a69fc2b48c9e0b1e656c2320ed76b808a}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a69fc2b48c9e0b1e656c2320ed76b808a}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Laplacian@{Laplacian}}
\index{Laplacian@{Laplacian}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Laplacian()}{Laplacian()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Laplacian (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the Laplacian of an image.

The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator\+:

{\itshape dst = Delta src = (d$^\wedge$2 src)/(dx$^\wedge$2) + (d$^\wedge$2 src)/(dy$^\wedge$2)}

This is done when {\ttfamily ksize $>$ 1}. When {\ttfamily ksize == 1}, the Laplacian is computed by filtering the image with the following {\itshape 3 x 3} aperture\+:

{\itshape vecthreethree 0101(-\/4)1010}

Note\+:


\begin{DoxyItemize}
\item An example using the Laplace transformation for edge detection can be found at opencv\+\_\+source\+\_\+code/samples/cpp/laplace.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & Desired depth of the destination image.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#laplacian}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Laplacian} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c9e2fdd65ecd76ae9135e33cfb9a99}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Scharr}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a85a8cac062c05efeecf99de50f3ab8d7}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Sobel}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a615b8e00934e682b9f0fa511996b4434}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a615b8e00934e682b9f0fa511996b4434}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!match\+Shapes@{match\+Shapes}}
\index{match\+Shapes@{match\+Shapes}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{match\+Shapes()}{matchShapes()}}
{\footnotesize\ttfamily static double org.\+opencv.\+imgproc.\+Imgproc.\+match\+Shapes (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{contour1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{contour2,  }\item[{int}]{method,  }\item[{double}]{parameter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Compares two shapes.

The function compares two shapes. All three implemented methods use the Hu invariants (see \char`\"{}\+Hu\+Moments\char`\"{}) as follows ({\itshape A} denotes {\ttfamily object1},{\itshape B} denotes {\ttfamily object2})\+:


\begin{DoxyItemize}
\item method=C\+V\+\_\+\+C\+O\+N\+T\+O\+U\+R\+S\+\_\+\+M\+A\+T\+C\+H\+\_\+\+I1 
\end{DoxyItemize}

{\itshape I\+\_\+1(\+A,\+B) = sum(by\+: i=1...7) $<$= ft$\vert$1/(m$^\wedge$\+A\+\_\+i) -\/ 1/(m$^\wedge$\+B\+\_\+i) right$\vert$}


\begin{DoxyItemize}
\item method=C\+V\+\_\+\+C\+O\+N\+T\+O\+U\+R\+S\+\_\+\+M\+A\+T\+C\+H\+\_\+\+I2 
\end{DoxyItemize}

{\itshape I\+\_\+2(\+A,\+B) = sum(by\+: i=1...7) $<$= ft$\vert$m$^\wedge$\+A\+\_\+i -\/ m$^\wedge$\+B\+\_\+i right$\vert$}


\begin{DoxyItemize}
\item method=C\+V\+\_\+\+C\+O\+N\+T\+O\+U\+R\+S\+\_\+\+M\+A\+T\+C\+H\+\_\+\+I3 
\end{DoxyItemize}

{\itshape I\+\_\+3(\+A,\+B) = max \+\_\+(i=1...7)($<$= ft$\vert$ m$^\wedge$\+A\+\_\+i -\/ m$^\wedge$\+B\+\_\+i right$\vert$)/($<$= ft$\vert$ m$^\wedge$\+A\+\_\+i right$\vert$)}

where

{\itshape m$^\wedge$\+A\+\_\+i = sign(h$^\wedge$\+A\+\_\+i) $\ast$ log(h$^\wedge$\+A\+\_\+i) m$^\wedge$\+B\+\_\+i = sign(h$^\wedge$\+B\+\_\+i) $\ast$ log(h$^\wedge$\+B\+\_\+i) }

and {\itshape h$^\wedge$\+A\+\_\+i, h$^\wedge$\+B\+\_\+i} are the Hu moments of {\itshape A} and {\itshape B}, respectively.


\begin{DoxyParams}{Parameters}
{\em contour1} & a contour1 \\
\hline
{\em contour2} & a contour2 \\
\hline
{\em method} & Comparison method\+: {\ttfamily C\+V\+\_\+\+C\+O\+N\+T\+O\+U\+R\+S\+\_\+\+M\+A\+T\+C\+H\+\_\+\+I1}, {\ttfamily C\+V\+\_\+\+C\+O\+N\+T\+O\+U\+R\+S\+\_\+\+M\+A\+T\+C\+H\+\_\+\+I2} \textbackslash{} \\
\hline
\end{DoxyParams}
or {\ttfamily C\+V\+\_\+\+C\+O\+N\+T\+O\+U\+R\+S\+\_\+\+M\+A\+T\+C\+H\+\_\+\+I3} (see the details below).


\begin{DoxyParams}{Parameters}
{\em parameter} & Method-\/specific parameter (not supported now).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#matchshapes}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+match\+Shapes} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab7f64647bb4d0400664056af42b90063}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab7f64647bb4d0400664056af42b90063}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!match\+Template@{match\+Template}}
\index{match\+Template@{match\+Template}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{match\+Template()}{matchTemplate()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+match\+Template (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{templ,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{result,  }\item[{int}]{method }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Compares a template against overlapped image regions.

The function slides through {\ttfamily image}, compares the overlapped patches of size {\itshape w x h} against {\ttfamily templ} using the specified method and stores the comparison results in {\ttfamily result}. Here are the formulae for the available comparison methods ({\itshape I} denotes {\ttfamily image}, {\itshape T} {\ttfamily template}, {\itshape \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}} {\ttfamily result}). The summation is done over template and/or the image patch\+: {\itshape x\textquotesingle{} = 0...w-\/1, y\textquotesingle{} = 0...h-\/1}


\begin{DoxyItemize}
\item method=C\+V\+\_\+\+T\+M\+\_\+\+S\+Q\+D\+I\+FF 
\end{DoxyItemize}

{\itshape R(x,y)= sum(by\+: x\textquotesingle{},y\textquotesingle{})(T(x\textquotesingle{},y\textquotesingle{})-\/I(x+x\textquotesingle{},y+y\textquotesingle{}))$^\wedge$2}


\begin{DoxyItemize}
\item method=C\+V\+\_\+\+T\+M\+\_\+\+S\+Q\+D\+I\+F\+F\+\_\+\+N\+O\+R\+M\+ED 
\end{DoxyItemize}

{\itshape R(x,y)= (sum\+\_\+(x\textquotesingle{},y\textquotesingle{})(T(x\textquotesingle{},y\textquotesingle{})-\/I(x+x\textquotesingle{},y+y\textquotesingle{}))$^\wedge$2)/(sqrt(sum\+\_\+(x\textquotesingle{},y\textquotesingle{})T(x\textquotesingle{},y\textquotesingle{})$^\wedge$2
\begin{DoxyItemize}
\item sum\+\_\+(x\textquotesingle{},y\textquotesingle{}) I(x+x\textquotesingle{},y+y\textquotesingle{})$^\wedge$2))
\end{DoxyItemize}}

{\itshape }

{\itshape 
\begin{DoxyItemize}
\item method=C\+V\+\_\+\+T\+M\+\_\+\+C\+C\+O\+RR 
\end{DoxyItemize}}

{\itshape }

{\itshape {\itshape R(x,y)= sum(by\+: x\textquotesingle{},y\textquotesingle{})(T(x\textquotesingle{},y\textquotesingle{}) $\ast$ I(x+x\textquotesingle{},y+y\textquotesingle{}))}}

{\itshape }

{\itshape 
\begin{DoxyItemize}
\item method=C\+V\+\_\+\+T\+M\+\_\+\+C\+C\+O\+R\+R\+\_\+\+N\+O\+R\+M\+ED 
\end{DoxyItemize}}

{\itshape }

{\itshape {\itshape R(x,y)= (sum\+\_\+(x\textquotesingle{},y\textquotesingle{})(T(x\textquotesingle{},y\textquotesingle{}) $\ast$ I(x+x\textquotesingle{},y+y\textquotesingle{})))/(sqrt(sum\+\_\+(x\textquotesingle{},y\textquotesingle{})T(x\textquotesingle{},y\textquotesingle{})$^\wedge$2
\begin{DoxyItemize}
\item sum\+\_\+(x\textquotesingle{},y\textquotesingle{}) I(x+x\textquotesingle{},y+y\textquotesingle{})$^\wedge$2))
\end{DoxyItemize}}}

{\itshape {\itshape }}

{\itshape {\itshape 
\begin{DoxyItemize}
\item method=C\+V\+\_\+\+T\+M\+\_\+\+C\+C\+O\+E\+FF 
\end{DoxyItemize}}}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape R(x,y)= sum(by\+: x\textquotesingle{},y\textquotesingle{})(T\textquotesingle{}(x\textquotesingle{},y\textquotesingle{}) $\ast$ I\textquotesingle{}(x+x\textquotesingle{},y+y\textquotesingle{}))}}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape where}}

{\itshape {\itshape }}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape T\textquotesingle{}(x\textquotesingle{},y\textquotesingle{})=T(x\textquotesingle{},y\textquotesingle{}) -\/ 1/(w $\ast$ h) $\ast$ sum(by\+: x\textquotesingle{}\textquotesingle{},y\textquotesingle{}\textquotesingle{}) T(x\textquotesingle{}\textquotesingle{},y\textquotesingle{}\textquotesingle{}) I\textquotesingle{}(x+x\textquotesingle{},y+y\textquotesingle{})=I(x+x\textquotesingle{},y+y\textquotesingle{}) -\/ 1/(w $\ast$ h) $\ast$ sum(by\+: x\textquotesingle{}\textquotesingle{},y\textquotesingle{}\textquotesingle{}) I(x+x\textquotesingle{}\textquotesingle{},y+y\textquotesingle{}\textquotesingle{}) }}}

{\itshape {\itshape }}

{\itshape {\itshape 
\begin{DoxyItemize}
\item method=C\+V\+\_\+\+T\+M\+\_\+\+C\+C\+O\+E\+F\+F\+\_\+\+N\+O\+R\+M\+ED 
\end{DoxyItemize}}}

{\itshape {\itshape }}

{\itshape {\itshape {\itshape R(x,y)= (sum\+\_\+(x\textquotesingle{},y\textquotesingle{})(T\textquotesingle{}(x\textquotesingle{},y\textquotesingle{}) $\ast$ I\textquotesingle{}(x+x\textquotesingle{},y+y\textquotesingle{})))/(sqrt(sum\+\_\+(x\textquotesingle{},y\textquotesingle{})T\textquotesingle{}(x\textquotesingle{},y\textquotesingle{})$^\wedge$2
\begin{DoxyItemize}
\item sum\+\_\+(x\textquotesingle{},y\textquotesingle{}) I\textquotesingle{}(x+x\textquotesingle{},y+y\textquotesingle{})$^\wedge$2))
\end{DoxyItemize}}}}

{\itshape {\itshape {\itshape }}}

{\itshape {\itshape {\itshape }}}

{\itshape {\itshape {\itshape After the function finishes the comparison, the best matches can be found as global minimums (when {\ttfamily C\+V\+\_\+\+T\+M\+\_\+\+S\+Q\+D\+I\+FF} was used) or maximums (when {\ttfamily C\+V\+\_\+\+T\+M\+\_\+\+C\+C\+O\+RR} or {\ttfamily C\+V\+\_\+\+T\+M\+\_\+\+C\+C\+O\+E\+FF} was used) using the \char`\"{}min\+Max\+Loc\char`\"{} function. In case of a color image, template summation in the numerator and each sum in the denominator is done over all of the channels and separate mean values are used for each channel. That is, the function can take a color template and a color image. The result will still be a single-\/channel image, which is easier to analyze.}}}

{\itshape {\itshape {\itshape }}}

{\itshape {\itshape {\itshape }}}

{\itshape {\itshape {\itshape Note\+:}}}

{\itshape {\itshape {\itshape  
\begin{DoxyItemize}
\item (Python) An example on how to match mouse selected regions in an image can be found at opencv\+\_\+source\+\_\+code/samples/python2/mouse\+\_\+and\+\_\+match.\+py 
\end{DoxyItemize}}}}

{\itshape {\itshape {\itshape 
\begin{DoxyParams}{Parameters}
{\em image} & Image where the search is running. It must be 8-\/bit or 32-\/bit floating-\/point. \\
\hline
{\em templ} & Searched template. It must be not greater than the source image and have the same data type. \\
\hline
{\em result} & Map of comparison results. It must be single-\/channel 32-\/bit floating-\/point. If {\ttfamily image} is {\itshape W x H} and {\ttfamily templ} is {\itshape w x h}, then {\ttfamily result} is {\itshape (W-\/w+1) x(H-\/h+1)}. \\
\hline
{\em method} & Parameter specifying the comparison method (see below).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/object_detection.html#matchtemplate}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+match\+Template} 
\end{DoxySeeAlso}
}}}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c07282afb6066b0f58ea7518f77966}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!median\+Blur@{median\+Blur}}
\index{median\+Blur@{median\+Blur}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{median\+Blur()}{medianBlur()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+median\+Blur (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ksize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image using the median filter.

The function smoothes an image using the median filter with the {\itshape ksize x ksize} aperture. Each channel of a multi-\/channel image is processed independently. In-\/place operation is supported.


\begin{DoxyParams}{Parameters}
{\em src} & input 1-\/, 3-\/, or 4-\/channel image; when {\ttfamily ksize} is 3 or 5, the image depth should be {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, or {\ttfamily C\+V\+\_\+32F}, for larger aperture sizes, it can only be {\ttfamily C\+V\+\_\+8U}. \\
\hline
{\em dst} & destination array of the same size and type as {\ttfamily src}. \\
\hline
{\em ksize} & aperture linear size; it must be odd and greater than 1, for example\+: 3, 5, 7...\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#medianblur}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+median\+Blur} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}{org.\+opencv.\+imgproc.\+Imgproc\+::box\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5cb82eca4bb445eb406ece7cfc1db780}{org.\+opencv.\+imgproc.\+Imgproc\+::bilateral\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{org.\+opencv.\+imgproc.\+Imgproc\+::blur}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a36e00300ec44ed202633c9c7e466f90a}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a36e00300ec44ed202633c9c7e466f90a}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!min\+Area\+Rect@{min\+Area\+Rect}}
\index{min\+Area\+Rect@{min\+Area\+Rect}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{min\+Area\+Rect()}{minAreaRect()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rotated_rect}{Rotated\+Rect}} org.\+opencv.\+imgproc.\+Imgproc.\+min\+Area\+Rect (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{points }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds a rotated rectangle of the minimum area enclosing the input 2D point set.

The function calculates and returns the minimum-\/area bounding rectangle (possibly rotated) for a specified point set. See the Open\+CV sample {\ttfamily minarea.\+cpp}. Developer should keep in mind that the returned rotated\+Rect can contain negative indices when data is close the the containing Mat element boundary.


\begin{DoxyParams}{Parameters}
{\em points} & Input vector of 2D points, stored in\+: 
\begin{DoxyItemize}
\item {\ttfamily std.\+vector$<$$>$} or {\ttfamily Mat} (C++ interface) 
\item {\ttfamily Cv\+Seq$\ast$} or {\ttfamily Cv\+Mat$\ast$} (C interface) 
\item Nx2 numpy array (Python interface) 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#minarearect}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+min\+Area\+Rect} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac3ca3753976cf3f969df4b25a3f5ef78}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac3ca3753976cf3f969df4b25a3f5ef78}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!min\+Enclosing\+Circle@{min\+Enclosing\+Circle}}
\index{min\+Enclosing\+Circle@{min\+Enclosing\+Circle}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{min\+Enclosing\+Circle()}{minEnclosingCircle()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+min\+Enclosing\+Circle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{points,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{center,  }\item[{float \mbox{[}$\,$\mbox{]}}]{radius }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Finds a circle of the minimum area enclosing a 2D point set.

The function finds the minimal enclosing circle of a 2D point set using an iterative algorithm. See the Open\+CV sample {\ttfamily minarea.\+cpp}.


\begin{DoxyParams}{Parameters}
{\em points} & Input vector of 2D points, stored in\+: 
\begin{DoxyItemize}
\item {\ttfamily std.\+vector$<$$>$} or {\ttfamily Mat} (C++ interface) 
\item {\ttfamily Cv\+Seq$\ast$} or {\ttfamily Cv\+Mat$\ast$} (C interface) 
\item Nx2 numpy array (Python interface) 
\end{DoxyItemize}\\
\hline
{\em center} & Output center of the circle. \\
\hline
{\em radius} & Output radius of the circle.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#minenclosingcircle}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+min\+Enclosing\+Circle} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6739d6b48d3c77c9a2225f0f2b8c2de0}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6739d6b48d3c77c9a2225f0f2b8c2de0}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!moments@{moments}}
\index{moments@{moments}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{moments()}{moments()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}} org.\+opencv.\+imgproc.\+Imgproc.\+moments (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{array,  }\item[{boolean}]{binary\+Image }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates all of the moments up to the third order of a polygon or rasterized shape.

The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The results are returned in the structure {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}}} defined as\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily class \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}}}

{\ttfamily }

{\ttfamily }

{\ttfamily public\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily Moments();}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}}(double m00, double m10, double m01, double m20, double m11,}

{\ttfamily }

{\ttfamily }

{\ttfamily double m02, double m30, double m21, double m12, double m03);}

{\ttfamily }

{\ttfamily }

{\ttfamily Moments(const Cv\+Moments\& moments);}

{\ttfamily }

{\ttfamily }

{\ttfamily operator Cv\+Moments() const;}

{\ttfamily }

{\ttfamily }

{\ttfamily // spatial moments}

{\ttfamily }

{\ttfamily }

{\ttfamily double m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;}

{\ttfamily }

{\ttfamily }

{\ttfamily // central moments}

{\ttfamily }

{\ttfamily }

{\ttfamily double mu20, mu11, mu02, mu30, mu21, mu12, mu03;}

{\ttfamily }

{\ttfamily }

{\ttfamily // central normalized moments}

{\ttfamily }

{\ttfamily }

{\ttfamily double nu20, nu11, nu02, nu30, nu21, nu12, nu03;}

{\ttfamily }

{\ttfamily }

{\ttfamily In case of a raster image, the spatial moments {\itshape Moments.\+m\+\_\+(ji)} are computed as\+: }

{\itshape m \+\_\+(ji)= sum(by\+: x,y)(array(x,y) $\ast$ x$^\wedge$j $\ast$ y$^\wedge$i)}

The central moments {\itshape Moments.\+mu\+\_\+(ji)} are computed as\+:

{\itshape mu \+\_\+(ji)= sum(by\+: x,y)(array(x,y) $\ast$ (x -\/ x\char`\"{})$^\wedge$j $\ast$ (y -\/ y\char`\"{})$^\wedge$i)}

where {\itshape (x\char`\"{}, y\char`\"{})} is the mass center\+:

{\itshape x\char`\"{} = (m\+\_\+10)/(m\+\_\+(00)), y\char`\"{} = (m\+\_\+01)/(m\+\_\+(00))}

The normalized central moments {\itshape Moments.\+nu\+\_\+(ij)} are computed as\+:

{\itshape nu \+\_\+(ji)= (mu\+\_\+(ji))/(m\+\_\+(00)$^\wedge$((i+j)/2+1)).}

Note\+:

{\itshape mu\+\_\+00=m\+\_\+00}, {\itshape nu\+\_\+00=1} {\itshape nu\+\_\+10=mu\+\_\+10=mu\+\_\+01=mu\+\_\+10=0}, hence the values are not stored.

The moments of a contour are defined in the same way but computed using the Green\textquotesingle{}s formula (see \href{http://en.wikipedia.org/wiki/Green_theorem}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Green\+\_\+theorem}). So, due to a limited raster resolution, the moments computed for a contour are slightly different from the moments computed for the same rasterized contour.

Note\+:

Since the contour moments are computed using Green formula, you may get seemingly odd results for contours with self-\/intersections, e.\+g. a zero area ({\ttfamily m00}) for butterfly-\/shaped contours.


\begin{DoxyParams}{Parameters}
{\em array} & Raster image (single-\/channel, 8-\/bit or floating-\/point 2D array) or an array ({\itshape 1 x N} or {\itshape N x 1}) of 2D points ({\ttfamily Point} or {\ttfamily Point2f}). \\
\hline
{\em binary\+Image} & If it is true, all non-\/zero image pixels are treated as 1\textquotesingle{}s. The parameter is used for images only.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#moments}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+moments} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0b9b82e8b2461a102788628c8b86d1a1}{org.\+opencv.\+imgproc.\+Imgproc\+::contour\+Area}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7e92ef5f2b2d486e256ee5e813de19c6}{org.\+opencv.\+imgproc.\+Imgproc\+::arc\+Length}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c002c128b749bd96ce843ae73165e6e}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c002c128b749bd96ce843ae73165e6e}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!moments@{moments}}
\index{moments@{moments}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{moments()}{moments()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}} org.\+opencv.\+imgproc.\+Imgproc.\+moments (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{array }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates all of the moments up to the third order of a polygon or rasterized shape.

The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The results are returned in the structure {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}}} defined as\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily class \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}}}

{\ttfamily }

{\ttfamily }

{\ttfamily public\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily Moments();}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_moments}{Moments}}(double m00, double m10, double m01, double m20, double m11,}

{\ttfamily }

{\ttfamily }

{\ttfamily double m02, double m30, double m21, double m12, double m03);}

{\ttfamily }

{\ttfamily }

{\ttfamily Moments(const Cv\+Moments\& moments);}

{\ttfamily }

{\ttfamily }

{\ttfamily operator Cv\+Moments() const;}

{\ttfamily }

{\ttfamily }

{\ttfamily // spatial moments}

{\ttfamily }

{\ttfamily }

{\ttfamily double m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;}

{\ttfamily }

{\ttfamily }

{\ttfamily // central moments}

{\ttfamily }

{\ttfamily }

{\ttfamily double mu20, mu11, mu02, mu30, mu21, mu12, mu03;}

{\ttfamily }

{\ttfamily }

{\ttfamily // central normalized moments}

{\ttfamily }

{\ttfamily }

{\ttfamily double nu20, nu11, nu02, nu30, nu21, nu12, nu03;}

{\ttfamily }

{\ttfamily }

{\ttfamily In case of a raster image, the spatial moments {\itshape Moments.\+m\+\_\+(ji)} are computed as\+: }

{\itshape m \+\_\+(ji)= sum(by\+: x,y)(array(x,y) $\ast$ x$^\wedge$j $\ast$ y$^\wedge$i)}

The central moments {\itshape Moments.\+mu\+\_\+(ji)} are computed as\+:

{\itshape mu \+\_\+(ji)= sum(by\+: x,y)(array(x,y) $\ast$ (x -\/ x\char`\"{})$^\wedge$j $\ast$ (y -\/ y\char`\"{})$^\wedge$i)}

where {\itshape (x\char`\"{}, y\char`\"{})} is the mass center\+:

{\itshape x\char`\"{} = (m\+\_\+10)/(m\+\_\+(00)), y\char`\"{} = (m\+\_\+01)/(m\+\_\+(00))}

The normalized central moments {\itshape Moments.\+nu\+\_\+(ij)} are computed as\+:

{\itshape nu \+\_\+(ji)= (mu\+\_\+(ji))/(m\+\_\+(00)$^\wedge$((i+j)/2+1)).}

Note\+:

{\itshape mu\+\_\+00=m\+\_\+00}, {\itshape nu\+\_\+00=1} {\itshape nu\+\_\+10=mu\+\_\+10=mu\+\_\+01=mu\+\_\+10=0}, hence the values are not stored.

The moments of a contour are defined in the same way but computed using the Green\textquotesingle{}s formula (see \href{http://en.wikipedia.org/wiki/Green_theorem}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Green\+\_\+theorem}). So, due to a limited raster resolution, the moments computed for a contour are slightly different from the moments computed for the same rasterized contour.

Note\+:

Since the contour moments are computed using Green formula, you may get seemingly odd results for contours with self-\/intersections, e.\+g. a zero area ({\ttfamily m00}) for butterfly-\/shaped contours.


\begin{DoxyParams}{Parameters}
{\em array} & Raster image (single-\/channel, 8-\/bit or floating-\/point 2D array) or an array ({\itshape 1 x N} or {\itshape N x 1}) of 2D points ({\ttfamily Point} or {\ttfamily Point2f}).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#moments}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+moments} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0b9b82e8b2461a102788628c8b86d1a1}{org.\+opencv.\+imgproc.\+Imgproc\+::contour\+Area}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7e92ef5f2b2d486e256ee5e813de19c6}{org.\+opencv.\+imgproc.\+Imgproc\+::arc\+Length}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a72708dff026d005db5a9534c9b2b4aae}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a72708dff026d005db5a9534c9b2b4aae}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!morphology\+Ex@{morphology\+Ex}}
\index{morphology\+Ex@{morphology\+Ex}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{morphology\+Ex()}{morphologyEx()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+morphology\+Ex (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{op,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{int}]{iterations,  }\item[{int}]{border\+Type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{border\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs advanced morphological transformations.

The function can perform advanced morphological transformations using an erosion and dilation as basic operations.

Opening operation\+:

{\itshape dst = open(src, element)= dilate(erode(src, element))}

Closing operation\+:

{\itshape dst = close(src, element)= erode(dilate(src, element))}

Morphological gradient\+:

{\itshape dst = morph\+\_\+grad(src, element)= dilate(src, element)-\/ erode(src, element)}

\char`\"{}\+Top hat\char`\"{}\+:

{\itshape dst = tophat(src, element)= src -\/ open(src, element)}

\char`\"{}\+Black hat\char`\"{}\+:

{\itshape dst = blackhat(src, element)= close(src, element)-\/ src}

Any of the operations can be done in-\/place. In case of multi-\/channel images, each channel is processed independently.

Note\+:


\begin{DoxyItemize}
\item An example using the morphology\+Ex function for the morphological opening and closing operations can be found at opencv\+\_\+source\+\_\+code/samples/cpp/morphology2.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & Source image. The number of channels can be arbitrary. The depth should be one of {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F\char`\"{} or $<$/code$>$\+C\+V\+\_\+64\+F\char`\"{}. }\\
\hline
{\em dst} & {\ttfamily Destination image of the same size and type as {\ttfamily src}. }\\
\hline
{\em op} & {\ttfamily Type of a morphological operation that can be one of the following\+: 
\begin{DoxyItemize}
\item M\+O\+R\+P\+H\+\_\+\+O\+P\+EN -\/ an opening operation 
\item M\+O\+R\+P\+H\+\_\+\+C\+L\+O\+SE -\/ a closing operation 
\item M\+O\+R\+P\+H\+\_\+\+G\+R\+A\+D\+I\+E\+NT -\/ a morphological gradient 
\item M\+O\+R\+P\+H\+\_\+\+T\+O\+P\+H\+AT -\/ \char`\"{}top hat\char`\"{} 
\item M\+O\+R\+P\+H\+\_\+\+B\+L\+A\+C\+K\+H\+AT -\/ \char`\"{}black hat\char`\"{} 
\end{DoxyItemize}}\\
\hline
{\em kernel} & {\ttfamily a kernel }\\
\hline
{\em anchor} & {\ttfamily a anchor }\\
\hline
{\em iterations} & {\ttfamily Number of times erosion and dilation are applied. }\\
\hline
{\em border\+Type} & {\ttfamily Pixel extrapolation method. See \char`\"{}border\+Interpolate\char`\"{} for details. }\\
\hline
{\em border\+Value} & {\ttfamily Border value in case of a constant border. The default value has a special meaning. See \char`\"{}create\+Morphology\+Filter\char`\"{} for details.}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
{\ttfamily  \href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#morphologyex}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+morphology\+Ex} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_addf44b4eae2f6a52e93c1018cdb07ddc}{org.\+opencv.\+imgproc.\+Imgproc\+::erode}} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7ed226f2562750987d756b129d3820b2}{org.\+opencv.\+imgproc.\+Imgproc\+::dilate}} }
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aae5c49b2ab2f81167240972412b5413c}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aae5c49b2ab2f81167240972412b5413c}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!morphology\+Ex@{morphology\+Ex}}
\index{morphology\+Ex@{morphology\+Ex}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{morphology\+Ex()}{morphologyEx()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+morphology\+Ex (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{op,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{int}]{iterations }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs advanced morphological transformations.

The function can perform advanced morphological transformations using an erosion and dilation as basic operations.

Opening operation\+:

{\itshape dst = open(src, element)= dilate(erode(src, element))}

Closing operation\+:

{\itshape dst = close(src, element)= erode(dilate(src, element))}

Morphological gradient\+:

{\itshape dst = morph\+\_\+grad(src, element)= dilate(src, element)-\/ erode(src, element)}

\char`\"{}\+Top hat\char`\"{}\+:

{\itshape dst = tophat(src, element)= src -\/ open(src, element)}

\char`\"{}\+Black hat\char`\"{}\+:

{\itshape dst = blackhat(src, element)= close(src, element)-\/ src}

Any of the operations can be done in-\/place. In case of multi-\/channel images, each channel is processed independently.

Note\+:


\begin{DoxyItemize}
\item An example using the morphology\+Ex function for the morphological opening and closing operations can be found at opencv\+\_\+source\+\_\+code/samples/cpp/morphology2.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & Source image. The number of channels can be arbitrary. The depth should be one of {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F\char`\"{} or $<$/code$>$\+C\+V\+\_\+64\+F\char`\"{}. }\\
\hline
{\em dst} & {\ttfamily Destination image of the same size and type as {\ttfamily src}. }\\
\hline
{\em op} & {\ttfamily Type of a morphological operation that can be one of the following\+: 
\begin{DoxyItemize}
\item M\+O\+R\+P\+H\+\_\+\+O\+P\+EN -\/ an opening operation 
\item M\+O\+R\+P\+H\+\_\+\+C\+L\+O\+SE -\/ a closing operation 
\item M\+O\+R\+P\+H\+\_\+\+G\+R\+A\+D\+I\+E\+NT -\/ a morphological gradient 
\item M\+O\+R\+P\+H\+\_\+\+T\+O\+P\+H\+AT -\/ \char`\"{}top hat\char`\"{} 
\item M\+O\+R\+P\+H\+\_\+\+B\+L\+A\+C\+K\+H\+AT -\/ \char`\"{}black hat\char`\"{} 
\end{DoxyItemize}}\\
\hline
{\em kernel} & {\ttfamily a kernel }\\
\hline
{\em anchor} & {\ttfamily a anchor }\\
\hline
{\em iterations} & {\ttfamily Number of times erosion and dilation are applied.}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
{\ttfamily  \href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#morphologyex}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+morphology\+Ex} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_addf44b4eae2f6a52e93c1018cdb07ddc}{org.\+opencv.\+imgproc.\+Imgproc\+::erode}} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7ed226f2562750987d756b129d3820b2}{org.\+opencv.\+imgproc.\+Imgproc\+::dilate}} }
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1acac72fef3b7b66641f4c2e9cd5e876}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1acac72fef3b7b66641f4c2e9cd5e876}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!morphology\+Ex@{morphology\+Ex}}
\index{morphology\+Ex@{morphology\+Ex}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{morphology\+Ex()}{morphologyEx()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+morphology\+Ex (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{op,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernel }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs advanced morphological transformations.

The function can perform advanced morphological transformations using an erosion and dilation as basic operations.

Opening operation\+:

{\itshape dst = open(src, element)= dilate(erode(src, element))}

Closing operation\+:

{\itshape dst = close(src, element)= erode(dilate(src, element))}

Morphological gradient\+:

{\itshape dst = morph\+\_\+grad(src, element)= dilate(src, element)-\/ erode(src, element)}

\char`\"{}\+Top hat\char`\"{}\+:

{\itshape dst = tophat(src, element)= src -\/ open(src, element)}

\char`\"{}\+Black hat\char`\"{}\+:

{\itshape dst = blackhat(src, element)= close(src, element)-\/ src}

Any of the operations can be done in-\/place. In case of multi-\/channel images, each channel is processed independently.

Note\+:


\begin{DoxyItemize}
\item An example using the morphology\+Ex function for the morphological opening and closing operations can be found at opencv\+\_\+source\+\_\+code/samples/cpp/morphology2.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & Source image. The number of channels can be arbitrary. The depth should be one of {\ttfamily C\+V\+\_\+8U}, {\ttfamily C\+V\+\_\+16U}, {\ttfamily C\+V\+\_\+16S}, {\ttfamily C\+V\+\_\+32F\char`\"{} or $<$/code$>$\+C\+V\+\_\+64\+F\char`\"{}. }\\
\hline
{\em dst} & {\ttfamily Destination image of the same size and type as {\ttfamily src}. }\\
\hline
{\em op} & {\ttfamily Type of a morphological operation that can be one of the following\+: 
\begin{DoxyItemize}
\item M\+O\+R\+P\+H\+\_\+\+O\+P\+EN -\/ an opening operation 
\item M\+O\+R\+P\+H\+\_\+\+C\+L\+O\+SE -\/ a closing operation 
\item M\+O\+R\+P\+H\+\_\+\+G\+R\+A\+D\+I\+E\+NT -\/ a morphological gradient 
\item M\+O\+R\+P\+H\+\_\+\+T\+O\+P\+H\+AT -\/ \char`\"{}top hat\char`\"{} 
\item M\+O\+R\+P\+H\+\_\+\+B\+L\+A\+C\+K\+H\+AT -\/ \char`\"{}black hat\char`\"{} 
\end{DoxyItemize}}\\
\hline
{\em kernel} & {\ttfamily a kernel}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
{\ttfamily  \href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#morphologyex}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+morphology\+Ex} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_addf44b4eae2f6a52e93c1018cdb07ddc}{org.\+opencv.\+imgproc.\+Imgproc\+::erode}} }

{\ttfamily  \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7ed226f2562750987d756b129d3820b2}{org.\+opencv.\+imgproc.\+Imgproc\+::dilate}} }
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7b3ed66ff7c6ceb76fb1293177964dd1}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7b3ed66ff7c6ceb76fb1293177964dd1}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!phase\+Correlate@{phase\+Correlate}}
\index{phase\+Correlate@{phase\+Correlate}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{phase\+Correlate()}{phaseCorrelate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} org.\+opencv.\+imgproc.\+Imgproc.\+phase\+Correlate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{window }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

The function is used to detect translational shifts that occur between two images. The operation takes advantage of the Fourier shift theorem for detecting the translational shift in the frequency domain. It can be used for fast image registration as well as motion estimation. For more information please see \href{http://en.wikipedia.org/wiki/Phase_correlation}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Phase\+\_\+correlation}.

Calculates the cross-\/power spectrum of two supplied source arrays. The arrays are padded if needed with \char`\"{}get\+Optimal\+D\+F\+T\+Size\char`\"{}.

Return value\+: detected phase shift (sub-\/pixel) between the two arrays.

The function performs the following equations


\begin{DoxyItemize}
\item First it applies a Hanning window (see \href{http://en.wikipedia.org/wiki/Hann_function}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Hann\+\_\+function}) to each image to remove possible edge effects. This window is cached until the array size changes to speed up processing time. 
\item Next it computes the forward D\+F\+Ts of each source array\+: 
\end{DoxyItemize}

{\itshape mathbf(\+G)\+\_\+a = mathcal(\+F)(src\+\_\+1), mathbf(\+G)\+\_\+b = mathcal(\+F)(src\+\_\+2)}

where {\itshape mathcal(\+F)} is the forward D\+FT.


\begin{DoxyItemize}
\item It then computes the cross-\/power spectrum of each frequency domain array\+: 
\end{DoxyItemize}

{\itshape \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} = (mathbf(\+G)\+\_\+a mathbf(\+G)\+\_\+b$^\wedge$$\ast$)/($\vert$mathbf(G)\+\_\+a mathbf(\+G)\+\_\+b$^\wedge$$\ast$$\vert$)}


\begin{DoxyItemize}
\item Next the cross-\/correlation is converted back into the time domain via the inverse D\+FT\+: 
\end{DoxyItemize}

{\itshape r = mathcal(\+F)$^\wedge$(-\/1)(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}})}


\begin{DoxyItemize}
\item Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to achieve sub-\/pixel accuracy. 
\end{DoxyItemize}

{\itshape (Delta x, Delta y) = weighted\+Centroid (arg max\+\_\+((x, y))(r))}


\begin{DoxyItemize}
\item If non-\/zero, the response parameter is computed as the sum of the elements of r within the 5x5 centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single peak) and will be smaller when there are multiple peaks. 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src1} & Source floating point array (C\+V\+\_\+32\+F\+C1 or C\+V\+\_\+64\+F\+C1) \\
\hline
{\em src2} & Source floating point array (C\+V\+\_\+32\+F\+C1 or C\+V\+\_\+64\+F\+C1) \\
\hline
{\em window} & Floating point array with windowing coefficients to reduce edge effects (optional).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#phasecorrelate}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+phase\+Correlate} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8953a925c05f058b4b992831fea01eee}{org.\+opencv.\+imgproc.\+Imgproc\+::create\+Hanning\+Window}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a249146033929c968ef948e290c2a438c}{org.\+opencv.\+core.\+Core\+::mul\+Spectrums}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}{org.\+opencv.\+core.\+Core\+::get\+Optimal\+D\+F\+T\+Size}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4fc0b0f22fef014f5e602e8d5b367a44}{org.\+opencv.\+core.\+Core\+::idft}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af0784f3b7aa341ba480c44509319440c}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af0784f3b7aa341ba480c44509319440c}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!phase\+Correlate@{phase\+Correlate}}
\index{phase\+Correlate@{phase\+Correlate}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{phase\+Correlate()}{phaseCorrelate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} org.\+opencv.\+imgproc.\+Imgproc.\+phase\+Correlate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

The function is used to detect translational shifts that occur between two images. The operation takes advantage of the Fourier shift theorem for detecting the translational shift in the frequency domain. It can be used for fast image registration as well as motion estimation. For more information please see \href{http://en.wikipedia.org/wiki/Phase_correlation}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Phase\+\_\+correlation}.

Calculates the cross-\/power spectrum of two supplied source arrays. The arrays are padded if needed with \char`\"{}get\+Optimal\+D\+F\+T\+Size\char`\"{}.

Return value\+: detected phase shift (sub-\/pixel) between the two arrays.

The function performs the following equations


\begin{DoxyItemize}
\item First it applies a Hanning window (see \href{http://en.wikipedia.org/wiki/Hann_function}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Hann\+\_\+function}) to each image to remove possible edge effects. This window is cached until the array size changes to speed up processing time. 
\item Next it computes the forward D\+F\+Ts of each source array\+: 
\end{DoxyItemize}

{\itshape mathbf(\+G)\+\_\+a = mathcal(\+F)(src\+\_\+1), mathbf(\+G)\+\_\+b = mathcal(\+F)(src\+\_\+2)}

where {\itshape mathcal(\+F)} is the forward D\+FT.


\begin{DoxyItemize}
\item It then computes the cross-\/power spectrum of each frequency domain array\+: 
\end{DoxyItemize}

{\itshape \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} = (mathbf(\+G)\+\_\+a mathbf(\+G)\+\_\+b$^\wedge$$\ast$)/($\vert$mathbf(G)\+\_\+a mathbf(\+G)\+\_\+b$^\wedge$$\ast$$\vert$)}


\begin{DoxyItemize}
\item Next the cross-\/correlation is converted back into the time domain via the inverse D\+FT\+: 
\end{DoxyItemize}

{\itshape r = mathcal(\+F)$^\wedge$(-\/1)(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}})}


\begin{DoxyItemize}
\item Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to achieve sub-\/pixel accuracy. 
\end{DoxyItemize}

{\itshape (Delta x, Delta y) = weighted\+Centroid (arg max\+\_\+((x, y))(r))}


\begin{DoxyItemize}
\item If non-\/zero, the response parameter is computed as the sum of the elements of r within the 5x5 centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single peak) and will be smaller when there are multiple peaks. 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src1} & Source floating point array (C\+V\+\_\+32\+F\+C1 or C\+V\+\_\+64\+F\+C1) \\
\hline
{\em src2} & Source floating point array (C\+V\+\_\+32\+F\+C1 or C\+V\+\_\+64\+F\+C1)\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/motion_analysis_and_object_tracking.html#phasecorrelate}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+phase\+Correlate} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8953a925c05f058b4b992831fea01eee}{org.\+opencv.\+imgproc.\+Imgproc\+::create\+Hanning\+Window}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a43313221157a3008972a04727a65a58d}{org.\+opencv.\+core.\+Core\+::dft}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a249146033929c968ef948e290c2a438c}{org.\+opencv.\+core.\+Core\+::mul\+Spectrums}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a9818ffe89dca479da8352d5bf6ebd6b3}{org.\+opencv.\+core.\+Core\+::get\+Optimal\+D\+F\+T\+Size}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a4fc0b0f22fef014f5e602e8d5b367a44}{org.\+opencv.\+core.\+Core\+::idft}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8f62667aea7153feaf585aff643a5826}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8f62667aea7153feaf585aff643a5826}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!phase\+Correlate\+Res@{phase\+Correlate\+Res}}
\index{phase\+Correlate\+Res@{phase\+Correlate\+Res}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{phase\+Correlate\+Res()}{phaseCorrelateRes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} org.\+opencv.\+imgproc.\+Imgproc.\+phase\+Correlate\+Res (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{window,  }\item[{double \mbox{[}$\,$\mbox{]}}]{response }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1c576a2bdd5d4adfa3131049865be50e}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1c576a2bdd5d4adfa3131049865be50e}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!phase\+Correlate\+Res@{phase\+Correlate\+Res}}
\index{phase\+Correlate\+Res@{phase\+Correlate\+Res}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{phase\+Correlate\+Res()}{phaseCorrelateRes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} org.\+opencv.\+imgproc.\+Imgproc.\+phase\+Correlate\+Res (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{window }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2cb96fabb468911c8a44b175091d77cd}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2cb96fabb468911c8a44b175091d77cd}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!point\+Polygon\+Test@{point\+Polygon\+Test}}
\index{point\+Polygon\+Test@{point\+Polygon\+Test}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{point\+Polygon\+Test()}{pointPolygonTest()}}
{\footnotesize\ttfamily static double org.\+opencv.\+imgproc.\+Imgproc.\+point\+Polygon\+Test (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{contour,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{pt,  }\item[{boolean}]{measure\+Dist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs a point-\/in-\/contour test.

The function determines whether the point is inside a contour, outside, or lies on an edge (or coincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge) value, correspondingly. When {\ttfamily measure\+Dist=false}, the return value is +1, -\/1, and 0, respectively. Otherwise, the return value is a signed distance between the point and the nearest contour edge.

See below a sample output of the function where each image pixel is tested against the contour.


\begin{DoxyParams}{Parameters}
{\em contour} & Input contour. \\
\hline
{\em pt} & Point tested against the contour. \\
\hline
{\em measure\+Dist} & If true, the function estimates the signed distance from the point to the nearest contour edge. Otherwise, the function only checks if the point is inside a contour or not.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#pointpolygontest}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+point\+Polygon\+Test} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7cd6f2951d4243689ad0915162a14541}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7cd6f2951d4243689ad0915162a14541}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!pre\+Corner\+Detect@{pre\+Corner\+Detect}}
\index{pre\+Corner\+Detect@{pre\+Corner\+Detect}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{pre\+Corner\+Detect()}{preCornerDetect()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+pre\+Corner\+Detect (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ksize,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a feature map for corner detection.

The function calculates the complex spatial derivative-\/based function of the source image

{\itshape dst = (D\+\_\+x src)$^\wedge$2 $\ast$ D\+\_\+(yy) src + (D\+\_\+y src)$^\wedge$2 $\ast$ D\+\_\+(xx) src -\/ 2 D\+\_\+x src $\ast$ D\+\_\+y src $\ast$ D\+\_\+(xy) src}

where {\itshape D\+\_\+x},{\itshape D\+\_\+y} are the first image derivatives, {\itshape D\+\_\+(xx)},{\itshape D\+\_\+(yy)} are the second image derivatives, and {\itshape D\+\_\+(xy)} is the mixed derivative. The corners can be found as local maximums of the functions, as shown below\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat corners, dilated\+\_\+corners;}

{\ttfamily }

{\ttfamily }

{\ttfamily pre\+Corner\+Detect(image, corners, 3);}

{\ttfamily }

{\ttfamily }

{\ttfamily // dilation with 3x3 rectangular structuring element}

{\ttfamily }

{\ttfamily }

{\ttfamily dilate(corners, dilated\+\_\+corners, Mat(), 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat corner\+\_\+mask = corners == dilated\+\_\+corners;}

{\ttfamily }

{\ttfamily }

{\ttfamily }


\begin{DoxyParams}{Parameters}
{\em src} & Source single-\/channel 8-\/bit of floating-\/point image. \\
\hline
{\em dst} & Output image that has the type {\ttfamily C\+V\+\_\+32F} and the same size as {\ttfamily src}. \\
\hline
{\em ksize} & Aperture size of the \char`\"{}\+Sobel\char`\"{}. \\
\hline
{\em border\+Type} & Pixel extrapolation method. See \char`\"{}border\+Interpolate\char`\"{}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#precornerdetect}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+pre\+Corner\+Detect} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab624f1339b2cfe8cd1fb44f202184c16}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab624f1339b2cfe8cd1fb44f202184c16}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!pre\+Corner\+Detect@{pre\+Corner\+Detect}}
\index{pre\+Corner\+Detect@{pre\+Corner\+Detect}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{pre\+Corner\+Detect()}{preCornerDetect()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+pre\+Corner\+Detect (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ksize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates a feature map for corner detection.

The function calculates the complex spatial derivative-\/based function of the source image

{\itshape dst = (D\+\_\+x src)$^\wedge$2 $\ast$ D\+\_\+(yy) src + (D\+\_\+y src)$^\wedge$2 $\ast$ D\+\_\+(xx) src -\/ 2 D\+\_\+x src $\ast$ D\+\_\+y src $\ast$ D\+\_\+(xy) src}

where {\itshape D\+\_\+x},{\itshape D\+\_\+y} are the first image derivatives, {\itshape D\+\_\+(xx)},{\itshape D\+\_\+(yy)} are the second image derivatives, and {\itshape D\+\_\+(xy)} is the mixed derivative. The corners can be found as local maximums of the functions, as shown below\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat corners, dilated\+\_\+corners;}

{\ttfamily }

{\ttfamily }

{\ttfamily pre\+Corner\+Detect(image, corners, 3);}

{\ttfamily }

{\ttfamily }

{\ttfamily // dilation with 3x3 rectangular structuring element}

{\ttfamily }

{\ttfamily }

{\ttfamily dilate(corners, dilated\+\_\+corners, Mat(), 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat corner\+\_\+mask = corners == dilated\+\_\+corners;}

{\ttfamily }

{\ttfamily }

{\ttfamily }


\begin{DoxyParams}{Parameters}
{\em src} & Source single-\/channel 8-\/bit of floating-\/point image. \\
\hline
{\em dst} & Output image that has the type {\ttfamily C\+V\+\_\+32F} and the same size as {\ttfamily src}. \\
\hline
{\em ksize} & Aperture size of the \char`\"{}\+Sobel\char`\"{}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/feature_detection.html#precornerdetect}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+pre\+Corner\+Detect} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab8ba2ea90f6c3696be6e21a9c2da2a22}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ab8ba2ea90f6c3696be6e21a9c2da2a22}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!P\+S\+NR@{P\+S\+NR}}
\index{P\+S\+NR@{P\+S\+NR}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{P\+S\+N\+R()}{PSNR()}}
{\footnotesize\ttfamily static double org.\+opencv.\+imgproc.\+Imgproc.\+P\+S\+NR (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9ecbfdf7bf014c1215841957f7e7b2ca}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a9ecbfdf7bf014c1215841957f7e7b2ca}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!pyr\+Down@{pyr\+Down}}
\index{pyr\+Down@{pyr\+Down}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{pyr\+Down()}{pyrDown()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Down (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dstsize,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image and downsamples it.

The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel\+:

{\itshape 1/256 1 4 6 4 1 4 16 24 16 4 6 24 36 24 6 4 16 24 16 4 1 4 6 4 1 }

Then, it downsamples the image by rejecting even rows and columns.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image; it has the specified size and the same type as {\ttfamily src}. \\
\hline
{\em dstsize} & size of the output image; by default, it is computed as {\ttfamily Size((src.\+cols+1)/2, (src.\+rows+1)/2)}, but in any case, the following conditions should be satisfied\+:\\
\hline
\end{DoxyParams}


{\itshape  lt\+BR gt$\vert$ dstsize.\+width $\ast$2-\/src.cols$\vert$ $<$= 2 $\vert$dstsize.height $\ast$2-\/src.rows$\vert$ $<$= 2 }


\begin{DoxyParams}{Parameters}
{\em border\+Type} & a border\+Type\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrdown}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Down} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a44e5337193173eb9738b3bf1beb8af73}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a44e5337193173eb9738b3bf1beb8af73}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!pyr\+Down@{pyr\+Down}}
\index{pyr\+Down@{pyr\+Down}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{pyr\+Down()}{pyrDown()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Down (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dstsize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image and downsamples it.

The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel\+:

{\itshape 1/256 1 4 6 4 1 4 16 24 16 4 6 24 36 24 6 4 16 24 16 4 1 4 6 4 1 }

Then, it downsamples the image by rejecting even rows and columns.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image; it has the specified size and the same type as {\ttfamily src}. \\
\hline
{\em dstsize} & size of the output image; by default, it is computed as {\ttfamily Size((src.\+cols+1)/2, (src.\+rows+1)/2)}, but in any case, the following conditions should be satisfied\+:\\
\hline
\end{DoxyParams}


{\itshape  lt\+BR gt$\vert$ dstsize.\+width $\ast$2-\/src.cols$\vert$ $<$= 2 $\vert$dstsize.height $\ast$2-\/src.rows$\vert$ $<$= 2 }

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrdown}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Down} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a717ca1f10b089cf6ec50dc0c634cf5e7}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a717ca1f10b089cf6ec50dc0c634cf5e7}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!pyr\+Down@{pyr\+Down}}
\index{pyr\+Down@{pyr\+Down}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{pyr\+Down()}{pyrDown()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Down (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Blurs an image and downsamples it.

The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel\+:

{\itshape 1/256 1 4 6 4 1 4 16 24 16 4 6 24 36 24 6 4 16 24 16 4 1 4 6 4 1 }

Then, it downsamples the image by rejecting even rows and columns.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image; it has the specified size and the same type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrdown}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Down} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1e4e4c176ebc30a3f5ab6f242c30db4e}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1e4e4c176ebc30a3f5ab6f242c30db4e}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!pyr\+Mean\+Shift\+Filtering@{pyr\+Mean\+Shift\+Filtering}}
\index{pyr\+Mean\+Shift\+Filtering@{pyr\+Mean\+Shift\+Filtering}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{pyr\+Mean\+Shift\+Filtering()}{pyrMeanShiftFiltering()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Mean\+Shift\+Filtering (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{sp,  }\item[{double}]{sr,  }\item[{int}]{max\+Level,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_term_criteria}{Term\+Criteria}}}]{termcrit }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs initial step of meanshift segmentation of an image.

The function implements the filtering stage of meanshift segmentation, that is, the output of the function is the filtered \char`\"{}posterized\char`\"{} image with color gradients and fine-\/grain texture flattened. At every pixel {\ttfamily (X,Y)} of the input image (or down-\/sized input image, see below) the function executes meanshift iterations, that is, the pixel {\ttfamily (X,Y)} neighborhood in the joint space-\/color hyperspace is considered\+:

{\itshape (x,y)\+: X-\/ sp $<$= x $<$= X+ sp, Y-\/ sp $<$= y $<$= Y+ sp, $\vert$$\vert$(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B)-\/(r,g,b)$\vert$$\vert$ $<$= sr}

where {\ttfamily (\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B)} and {\ttfamily (r,g,b)} are the vectors of color components at {\ttfamily (X,Y)} and {\ttfamily (x,y)}, respectively (though, the algorithm does not depend on the color space used, so any 3-\/component color space can be used instead). Over the neighborhood the average spatial value {\ttfamily (X\textquotesingle{},Y\textquotesingle{})} and average color vector {\ttfamily (\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}\textquotesingle{},G\textquotesingle{},B\textquotesingle{})} are found and they act as the neighborhood center on the next iteration\+:

{\itshape (X,Y)$\sim$(X\textquotesingle{},Y\textquotesingle{}), (\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B)$\sim$(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}\textquotesingle{},G\textquotesingle{},B\textquotesingle{}).}

After the iterations over, the color components of the initial pixel (that is, the pixel from where the iterations started) are set to the final value (average color at the last iteration)\+:

{\itshape I(\+X,\+Y) \&lt-\/ (R$\ast$,G$\ast$,B$\ast$)}

When {\ttfamily max\+Level $>$ 0}, the gaussian pyramid of {\ttfamily max\+Level+1} levels is built, and the above procedure is run on the smallest layer first. After that, the results are propagated to the larger layer and the iterations are run again only on those pixels where the layer colors differ by more than {\ttfamily sr} from the lower-\/resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the results will be actually different from the ones obtained by running the meanshift procedure on the whole original image (i.\+e. when {\ttfamily max\+Level==0}).

Note\+:


\begin{DoxyItemize}
\item An example using mean-\/shift image segmentation can be found at opencv\+\_\+source\+\_\+code/samples/cpp/meanshift\+\_\+segmentation.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & The source 8-\/bit, 3-\/channel image. \\
\hline
{\em dst} & The destination image of the same format and the same size as the source. \\
\hline
{\em sp} & The spatial window radius. \\
\hline
{\em sr} & The color window radius. \\
\hline
{\em max\+Level} & Maximum level of the pyramid for the segmentation. \\
\hline
{\em termcrit} & Termination criteria\+: when to stop meanshift iterations.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrmeanshiftfiltering}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Mean\+Shift\+Filtering} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac61221bc09dbc9e8bdd92a9b3f1126b2}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac61221bc09dbc9e8bdd92a9b3f1126b2}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!pyr\+Mean\+Shift\+Filtering@{pyr\+Mean\+Shift\+Filtering}}
\index{pyr\+Mean\+Shift\+Filtering@{pyr\+Mean\+Shift\+Filtering}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{pyr\+Mean\+Shift\+Filtering()}{pyrMeanShiftFiltering()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Mean\+Shift\+Filtering (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{sp,  }\item[{double}]{sr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs initial step of meanshift segmentation of an image.

The function implements the filtering stage of meanshift segmentation, that is, the output of the function is the filtered \char`\"{}posterized\char`\"{} image with color gradients and fine-\/grain texture flattened. At every pixel {\ttfamily (X,Y)} of the input image (or down-\/sized input image, see below) the function executes meanshift iterations, that is, the pixel {\ttfamily (X,Y)} neighborhood in the joint space-\/color hyperspace is considered\+:

{\itshape (x,y)\+: X-\/ sp $<$= x $<$= X+ sp, Y-\/ sp $<$= y $<$= Y+ sp, $\vert$$\vert$(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B)-\/(r,g,b)$\vert$$\vert$ $<$= sr}

where {\ttfamily (\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B)} and {\ttfamily (r,g,b)} are the vectors of color components at {\ttfamily (X,Y)} and {\ttfamily (x,y)}, respectively (though, the algorithm does not depend on the color space used, so any 3-\/component color space can be used instead). Over the neighborhood the average spatial value {\ttfamily (X\textquotesingle{},Y\textquotesingle{})} and average color vector {\ttfamily (\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}\textquotesingle{},G\textquotesingle{},B\textquotesingle{})} are found and they act as the neighborhood center on the next iteration\+:

{\itshape (X,Y)$\sim$(X\textquotesingle{},Y\textquotesingle{}), (\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}},G,B)$\sim$(\mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}\textquotesingle{},G\textquotesingle{},B\textquotesingle{}).}

After the iterations over, the color components of the initial pixel (that is, the pixel from where the iterations started) are set to the final value (average color at the last iteration)\+:

{\itshape I(\+X,\+Y) \&lt-\/ (R$\ast$,G$\ast$,B$\ast$)}

When {\ttfamily max\+Level $>$ 0}, the gaussian pyramid of {\ttfamily max\+Level+1} levels is built, and the above procedure is run on the smallest layer first. After that, the results are propagated to the larger layer and the iterations are run again only on those pixels where the layer colors differ by more than {\ttfamily sr} from the lower-\/resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the results will be actually different from the ones obtained by running the meanshift procedure on the whole original image (i.\+e. when {\ttfamily max\+Level==0}).

Note\+:


\begin{DoxyItemize}
\item An example using mean-\/shift image segmentation can be found at opencv\+\_\+source\+\_\+code/samples/cpp/meanshift\+\_\+segmentation.\+cpp 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & The source 8-\/bit, 3-\/channel image. \\
\hline
{\em dst} & The destination image of the same format and the same size as the source. \\
\hline
{\em sp} & The spatial window radius. \\
\hline
{\em sr} & The color window radius.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrmeanshiftfiltering}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Mean\+Shift\+Filtering} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa55d915e843c305139824579332e90e9}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa55d915e843c305139824579332e90e9}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!pyr\+Up@{pyr\+Up}}
\index{pyr\+Up@{pyr\+Up}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{pyr\+Up()}{pyrUp()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Up (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dstsize,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Upsamples an image and then blurs it.

The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in \char`\"{}pyr\+Down\char`\"{} multiplied by 4.

Note\+:


\begin{DoxyItemize}
\item (Python) An example of Laplacian Pyramid construction and merging can be found at opencv\+\_\+source\+\_\+code/samples/python2/lappyr.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image. It has the specified size and the same type as {\ttfamily src}. \\
\hline
{\em dstsize} & size of the output image; by default, it is computed as {\ttfamily Size(src.\+cols$\ast$2, (src.\+rows$\ast$2)}, but in any case, the following conditions should be satisfied\+:\\
\hline
\end{DoxyParams}


{\itshape  lt\+BR gt$\vert$ dstsize.\+width -\/src.\+cols$\ast$2$\vert$ $<$= (dstsize.\+width mod 2) $\vert$dstsize.height -\/src.\+rows$\ast$2$\vert$ $<$= (dstsize.\+height mod 2) }


\begin{DoxyParams}{Parameters}
{\em border\+Type} & a border\+Type\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrup}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Up} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad1f5f14fec2da659a02267cc5399ab83}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad1f5f14fec2da659a02267cc5399ab83}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!pyr\+Up@{pyr\+Up}}
\index{pyr\+Up@{pyr\+Up}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{pyr\+Up()}{pyrUp()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Up (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dstsize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Upsamples an image and then blurs it.

The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in \char`\"{}pyr\+Down\char`\"{} multiplied by 4.

Note\+:


\begin{DoxyItemize}
\item (Python) An example of Laplacian Pyramid construction and merging can be found at opencv\+\_\+source\+\_\+code/samples/python2/lappyr.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image. It has the specified size and the same type as {\ttfamily src}. \\
\hline
{\em dstsize} & size of the output image; by default, it is computed as {\ttfamily Size(src.\+cols$\ast$2, (src.\+rows$\ast$2)}, but in any case, the following conditions should be satisfied\+:\\
\hline
\end{DoxyParams}


{\itshape  lt\+BR gt$\vert$ dstsize.\+width -\/src.\+cols$\ast$2$\vert$ $<$= (dstsize.\+width mod 2) $\vert$dstsize.height -\/src.\+rows$\ast$2$\vert$ $<$= (dstsize.\+height mod 2) }

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrup}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Up} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abd25266f8f94c20c8112899d52de4af6}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abd25266f8f94c20c8112899d52de4af6}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!pyr\+Up@{pyr\+Up}}
\index{pyr\+Up@{pyr\+Up}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{pyr\+Up()}{pyrUp()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Up (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Upsamples an image and then blurs it.

The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in \char`\"{}pyr\+Down\char`\"{} multiplied by 4.

Note\+:


\begin{DoxyItemize}
\item (Python) An example of Laplacian Pyramid construction and merging can be found at opencv\+\_\+source\+\_\+code/samples/python2/lappyr.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image. It has the specified size and the same type as {\ttfamily src}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#pyrup}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+pyr\+Up} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!remap@{remap}}
\index{remap@{remap}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{remap()}{remap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+remap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map2,  }\item[{int}]{interpolation,  }\item[{int}]{border\+Mode,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{border\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies a generic geometrical transformation to an image.

The function {\ttfamily remap} transforms the source image using the specified map\+:

{\itshape dst(x,y) = src(map\+\_\+x(x,y),map\+\_\+y(x,y))}

where values of pixels with non-\/integer coordinates are computed using one of available interpolation methods. {\itshape map\+\_\+x} and {\itshape map\+\_\+y} can be encoded as separate floating-\/point maps in {\itshape map\+\_\+1} and {\itshape map\+\_\+2} respectively, or interleaved floating-\/point maps of {\itshape (x,y)} in {\itshape map\+\_\+1}, or fixed-\/point maps created by using \char`\"{}convert\+Maps\char`\"{}. The reason you might want to convert from floating to fixed-\/point representations of a map is that they can yield much faster ($\sim$2x) remapping operations. In the converted case, {\itshape map\+\_\+1} contains pairs {\ttfamily (cv\+Floor(x), cv\+Floor(y))} and {\itshape map\+\_\+2} contains indices in a table of interpolation coefficients.

This function cannot operate in-\/place.


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image. It has the same size as {\ttfamily map1} and the same type as {\ttfamily src}. \\
\hline
{\em map1} & The first map of either {\ttfamily (x,y)} points or just {\ttfamily x} values having the type {\ttfamily C\+V\+\_\+16\+S\+C2}, {\ttfamily C\+V\+\_\+32\+F\+C1}, or {\ttfamily C\+V\+\_\+32\+F\+C2}. See \char`\"{}convert\+Maps\char`\"{} for details on converting a floating point representation to fixed-\/point for speed. \\
\hline
{\em map2} & The second map of {\ttfamily y} values having the type {\ttfamily C\+V\+\_\+16\+U\+C1}, {\ttfamily C\+V\+\_\+32\+F\+C1}, or none (empty map if {\ttfamily map1} is {\ttfamily (x,y)} points), respectively. \\
\hline
{\em interpolation} & Interpolation method (see \char`\"{}resize\char`\"{}). The method {\ttfamily I\+N\+T\+E\+R\+\_\+\+A\+R\+EA} is not supported by this function. \\
\hline
{\em border\+Mode} & Pixel extrapolation method (see \char`\"{}border\+Interpolate\char`\"{}). When {\ttfamily border\+Mode=B\+O\+R\+D\+E\+R\+\_\+\+T\+R\+A\+N\+S\+P\+A\+R\+E\+NT}, it means that the pixels in the destination image that corresponds to the \char`\"{}outliers\char`\"{} in the source image are not modified by the function. \\
\hline
{\em border\+Value} & Value used in case of a constant border. By default, it is 0.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#remap}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+remap} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2abe0c60d2f4707962a472e94c0841e0}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a2abe0c60d2f4707962a472e94c0841e0}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!remap@{remap}}
\index{remap@{remap}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{remap()}{remap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+remap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map1,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{map2,  }\item[{int}]{interpolation }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies a generic geometrical transformation to an image.

The function {\ttfamily remap} transforms the source image using the specified map\+:

{\itshape dst(x,y) = src(map\+\_\+x(x,y),map\+\_\+y(x,y))}

where values of pixels with non-\/integer coordinates are computed using one of available interpolation methods. {\itshape map\+\_\+x} and {\itshape map\+\_\+y} can be encoded as separate floating-\/point maps in {\itshape map\+\_\+1} and {\itshape map\+\_\+2} respectively, or interleaved floating-\/point maps of {\itshape (x,y)} in {\itshape map\+\_\+1}, or fixed-\/point maps created by using \char`\"{}convert\+Maps\char`\"{}. The reason you might want to convert from floating to fixed-\/point representations of a map is that they can yield much faster ($\sim$2x) remapping operations. In the converted case, {\itshape map\+\_\+1} contains pairs {\ttfamily (cv\+Floor(x), cv\+Floor(y))} and {\itshape map\+\_\+2} contains indices in a table of interpolation coefficients.

This function cannot operate in-\/place.


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image. It has the same size as {\ttfamily map1} and the same type as {\ttfamily src}. \\
\hline
{\em map1} & The first map of either {\ttfamily (x,y)} points or just {\ttfamily x} values having the type {\ttfamily C\+V\+\_\+16\+S\+C2}, {\ttfamily C\+V\+\_\+32\+F\+C1}, or {\ttfamily C\+V\+\_\+32\+F\+C2}. See \char`\"{}convert\+Maps\char`\"{} for details on converting a floating point representation to fixed-\/point for speed. \\
\hline
{\em map2} & The second map of {\ttfamily y} values having the type {\ttfamily C\+V\+\_\+16\+U\+C1}, {\ttfamily C\+V\+\_\+32\+F\+C1}, or none (empty map if {\ttfamily map1} is {\ttfamily (x,y)} points), respectively. \\
\hline
{\em interpolation} & Interpolation method (see \char`\"{}resize\char`\"{}). The method {\ttfamily I\+N\+T\+E\+R\+\_\+\+A\+R\+EA} is not supported by this function.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#remap}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+remap} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae781b575f9f20dbefb20eb2bb9966ae2}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae781b575f9f20dbefb20eb2bb9966ae2}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!resize@{resize}}
\index{resize@{resize}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dsize,  }\item[{double}]{fx,  }\item[{double}]{fy,  }\item[{int}]{interpolation }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Resizes an image.

The function {\ttfamily resize} resizes the image {\ttfamily src} down to or up to the specified size.\+Note that the initial {\ttfamily dst} type or size are not taken into account. Instead, the size and type are derived from the {\ttfamily src},{\ttfamily dsize},{\ttfamily fx}, and {\ttfamily fy}. If you want to resize {\ttfamily src} so that it fits the pre-\/created {\ttfamily dst}, you may call the function as follows\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // explicitly specify dsize=dst.\+size(); fx and fy will be computed from that.}

{\ttfamily }

{\ttfamily }

{\ttfamily resize(src, dst, dst.\+size(), 0, 0, interpolation);}

{\ttfamily }

{\ttfamily }

{\ttfamily If you want to decimate the image by factor of 2 in each direction, you can call the function this way\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // specify fx and fy and let the function compute the destination image size.}

{\ttfamily }

{\ttfamily }

{\ttfamily resize(src, dst, Size(), 0.\+5, 0.\+5, interpolation);}

{\ttfamily }

{\ttfamily }

{\ttfamily To shrink an image, it will generally look best with C\+V\+\_\+\+I\+N\+T\+E\+R\+\_\+\+A\+R\+EA interpolation, whereas to enlarge an image, it will generally look best with C\+V\+\_\+\+I\+N\+T\+E\+R\+\_\+\+C\+U\+B\+IC (slow) or C\+V\+\_\+\+I\+N\+T\+E\+R\+\_\+\+L\+I\+N\+E\+AR (faster but still looks OK). }


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image; it has the size {\ttfamily dsize} (when it is non-\/zero) or the size computed from {\ttfamily src.\+size()}, {\ttfamily fx}, and {\ttfamily fy}; the type of {\ttfamily dst} is the same as of {\ttfamily src}. \\
\hline
{\em dsize} & output image size; if it equals zero, it is computed as\+:\\
\hline
\end{DoxyParams}


{\itshape dsize = Size(round(fx$\ast$src.cols), round(fy$\ast$src.rows))}

Either {\ttfamily dsize} or both {\ttfamily fx} and {\ttfamily fy} must be non-\/zero.


\begin{DoxyParams}{Parameters}
{\em fx} & scale factor along the horizontal axis; when it equals 0, it is computed as\\
\hline
\end{DoxyParams}


{\itshape (double)dsize.\+width/src.cols}


\begin{DoxyParams}{Parameters}
{\em fy} & scale factor along the vertical axis; when it equals 0, it is computed as\\
\hline
\end{DoxyParams}


{\itshape (double)dsize.\+height/src.rows}


\begin{DoxyParams}{Parameters}
{\em interpolation} & interpolation method\+: 
\begin{DoxyItemize}
\item I\+N\+T\+E\+R\+\_\+\+N\+E\+A\+R\+E\+ST -\/ a nearest-\/neighbor interpolation 
\item I\+N\+T\+E\+R\+\_\+\+L\+I\+N\+E\+AR -\/ a bilinear interpolation (used by default) 
\item I\+N\+T\+E\+R\+\_\+\+A\+R\+EA -\/ resampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire\textquotesingle{}-\/free results. But when the image is zoomed, it is similar to the {\ttfamily I\+N\+T\+E\+R\+\_\+\+N\+E\+A\+R\+E\+ST} method. 
\item I\+N\+T\+E\+R\+\_\+\+C\+U\+B\+IC -\/ a bicubic interpolation over 4x4 pixel neighborhood 
\item I\+N\+T\+E\+R\+\_\+\+L\+A\+N\+C\+Z\+O\+S4 -\/ a Lanczos interpolation over 8x8 pixel neighborhood 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#resize}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+resize} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Affine}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}{org.\+opencv.\+imgproc.\+Imgproc\+::remap}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae2819900a62b48a2d701f0c5ead64922}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae2819900a62b48a2d701f0c5ead64922}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!resize@{resize}}
\index{resize@{resize}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dsize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Resizes an image.

The function {\ttfamily resize} resizes the image {\ttfamily src} down to or up to the specified size.\+Note that the initial {\ttfamily dst} type or size are not taken into account. Instead, the size and type are derived from the {\ttfamily src},{\ttfamily dsize},{\ttfamily fx}, and {\ttfamily fy}. If you want to resize {\ttfamily src} so that it fits the pre-\/created {\ttfamily dst}, you may call the function as follows\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // explicitly specify dsize=dst.\+size(); fx and fy will be computed from that.}

{\ttfamily }

{\ttfamily }

{\ttfamily resize(src, dst, dst.\+size(), 0, 0, interpolation);}

{\ttfamily }

{\ttfamily }

{\ttfamily If you want to decimate the image by factor of 2 in each direction, you can call the function this way\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // specify fx and fy and let the function compute the destination image size.}

{\ttfamily }

{\ttfamily }

{\ttfamily resize(src, dst, Size(), 0.\+5, 0.\+5, interpolation);}

{\ttfamily }

{\ttfamily }

{\ttfamily To shrink an image, it will generally look best with C\+V\+\_\+\+I\+N\+T\+E\+R\+\_\+\+A\+R\+EA interpolation, whereas to enlarge an image, it will generally look best with C\+V\+\_\+\+I\+N\+T\+E\+R\+\_\+\+C\+U\+B\+IC (slow) or C\+V\+\_\+\+I\+N\+T\+E\+R\+\_\+\+L\+I\+N\+E\+AR (faster but still looks OK). }


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image; it has the size {\ttfamily dsize} (when it is non-\/zero) or the size computed from {\ttfamily src.\+size()}, {\ttfamily fx}, and {\ttfamily fy}; the type of {\ttfamily dst} is the same as of {\ttfamily src}. \\
\hline
{\em dsize} & output image size; if it equals zero, it is computed as\+:\\
\hline
\end{DoxyParams}


{\itshape dsize = Size(round(fx$\ast$src.cols), round(fy$\ast$src.rows))}

Either {\ttfamily dsize} or both {\ttfamily fx} and {\ttfamily fy} must be non-\/zero.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#resize}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+resize} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Affine}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}{org.\+opencv.\+imgproc.\+Imgproc\+::remap}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c9e2fdd65ecd76ae9135e33cfb9a99}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c9e2fdd65ecd76ae9135e33cfb9a99}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Scharr@{Scharr}}
\index{Scharr@{Scharr}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Scharr()}{Scharr()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Scharr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{int}]{dx,  }\item[{int}]{dy,  }\item[{double}]{scale,  }\item[{double}]{delta,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the first x-\/ or y-\/ image derivative using Scharr operator.

The function computes the first x-\/ or y-\/ spatial image derivative using the Scharr operator. The call

{\itshape Scharr(src, dst, ddepth, dx, dy, scale, delta, border\+Type)}

is equivalent to

{\itshape Sobel(src, dst, ddepth, dx, dy, C\+V\+\_\+\+S\+C\+H\+A\+RR, scale, delta, border\+Type).}


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & output image depth (see \char`\"{}\+Sobel\char`\"{} for the list of supported combination of {\ttfamily src.\+depth()} and {\ttfamily ddepth}). \\
\hline
{\em dx} & order of the derivative x. \\
\hline
{\em dy} & order of the derivative y. \\
\hline
{\em scale} & optional scale factor for the computed derivative values; by default, no scaling is applied (see \char`\"{}get\+Deriv\+Kernels\char`\"{} for details). \\
\hline
{\em delta} & optional delta value that is added to the results prior to storing them in {\ttfamily dst}. \\
\hline
{\em border\+Type} & pixel extrapolation method (see \char`\"{}border\+Interpolate\char`\"{} for details).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#scharr}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Scharr} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6f27ca323b9ddb24d2b74ac4e106ea53}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a6f27ca323b9ddb24d2b74ac4e106ea53}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Scharr@{Scharr}}
\index{Scharr@{Scharr}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Scharr()}{Scharr()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Scharr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{int}]{dx,  }\item[{int}]{dy,  }\item[{double}]{scale,  }\item[{double}]{delta }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the first x-\/ or y-\/ image derivative using Scharr operator.

The function computes the first x-\/ or y-\/ spatial image derivative using the Scharr operator. The call

{\itshape Scharr(src, dst, ddepth, dx, dy, scale, delta, border\+Type)}

is equivalent to

{\itshape Sobel(src, dst, ddepth, dx, dy, C\+V\+\_\+\+S\+C\+H\+A\+RR, scale, delta, border\+Type).}


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & output image depth (see \char`\"{}\+Sobel\char`\"{} for the list of supported combination of {\ttfamily src.\+depth()} and {\ttfamily ddepth}). \\
\hline
{\em dx} & order of the derivative x. \\
\hline
{\em dy} & order of the derivative y. \\
\hline
{\em scale} & optional scale factor for the computed derivative values; by default, no scaling is applied (see \char`\"{}get\+Deriv\+Kernels\char`\"{} for details). \\
\hline
{\em delta} & optional delta value that is added to the results prior to storing them in {\ttfamily dst}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#scharr}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Scharr} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac86859d311e2cb092dd9cddcfb20d900}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ac86859d311e2cb092dd9cddcfb20d900}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Scharr@{Scharr}}
\index{Scharr@{Scharr}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Scharr()}{Scharr()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Scharr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{int}]{dx,  }\item[{int}]{dy }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the first x-\/ or y-\/ image derivative using Scharr operator.

The function computes the first x-\/ or y-\/ spatial image derivative using the Scharr operator. The call

{\itshape Scharr(src, dst, ddepth, dx, dy, scale, delta, border\+Type)}

is equivalent to

{\itshape Sobel(src, dst, ddepth, dx, dy, C\+V\+\_\+\+S\+C\+H\+A\+RR, scale, delta, border\+Type).}


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & output image depth (see \char`\"{}\+Sobel\char`\"{} for the list of supported combination of {\ttfamily src.\+depth()} and {\ttfamily ddepth}). \\
\hline
{\em dx} & order of the derivative x. \\
\hline
{\em dy} & order of the derivative y.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#scharr}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Scharr} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!sep\+Filter2D@{sep\+Filter2D}}
\index{sep\+Filter2D@{sep\+Filter2D}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{sep\+Filter2\+D()}{sepFilter2D()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+sep\+Filter2D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernelX,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernelY,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{double}]{delta,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies a separable linear filter to an image.

The function applies a separable linear filter to the image. That is, first, every row of {\ttfamily src} is filtered with the 1D kernel {\ttfamily kernelX}. Then, every column of the result is filtered with the 1D kernel {\ttfamily kernelY}. The final result shifted by {\ttfamily delta} is stored in {\ttfamily dst}.


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & Destination image depth. The following combination of {\ttfamily src.\+depth()} and {\ttfamily ddepth} are supported\+: 
\begin{DoxyItemize}
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+8U}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+16S}/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+16U}/{\ttfamily C\+V\+\_\+16S}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+32F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+64F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+64F} 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


when {\ttfamily ddepth=-\/1}, the destination image will have the same depth as the source.


\begin{DoxyParams}{Parameters}
{\em kernelX} & Coefficients for filtering each row. \\
\hline
{\em kernelY} & Coefficients for filtering each column. \\
\hline
{\em anchor} & Anchor position within the kernel. The default value {\itshape (-\/1,-\/1)} means that the anchor is at the kernel center. \\
\hline
{\em delta} & Value added to the filtered results before storing them. \\
\hline
{\em border\+Type} & Pixel extrapolation method. See \char`\"{}border\+Interpolate\char`\"{} for details.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#sepfilter2d}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+sep\+Filter2D} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a85a8cac062c05efeecf99de50f3ab8d7}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Sobel}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}{org.\+opencv.\+imgproc.\+Imgproc\+::box\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{org.\+opencv.\+imgproc.\+Imgproc\+::blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{org.\+opencv.\+imgproc.\+Imgproc\+::filter2D}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abea9b14d3e482c71996b0af7ad20b384}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abea9b14d3e482c71996b0af7ad20b384}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!sep\+Filter2D@{sep\+Filter2D}}
\index{sep\+Filter2D@{sep\+Filter2D}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{sep\+Filter2\+D()}{sepFilter2D()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+sep\+Filter2D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernelX,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernelY,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{anchor,  }\item[{double}]{delta }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies a separable linear filter to an image.

The function applies a separable linear filter to the image. That is, first, every row of {\ttfamily src} is filtered with the 1D kernel {\ttfamily kernelX}. Then, every column of the result is filtered with the 1D kernel {\ttfamily kernelY}. The final result shifted by {\ttfamily delta} is stored in {\ttfamily dst}.


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & Destination image depth. The following combination of {\ttfamily src.\+depth()} and {\ttfamily ddepth} are supported\+: 
\begin{DoxyItemize}
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+8U}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+16S}/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+16U}/{\ttfamily C\+V\+\_\+16S}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+32F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+64F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+64F} 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


when {\ttfamily ddepth=-\/1}, the destination image will have the same depth as the source.


\begin{DoxyParams}{Parameters}
{\em kernelX} & Coefficients for filtering each row. \\
\hline
{\em kernelY} & Coefficients for filtering each column. \\
\hline
{\em anchor} & Anchor position within the kernel. The default value {\itshape (-\/1,-\/1)} means that the anchor is at the kernel center. \\
\hline
{\em delta} & Value added to the filtered results before storing them.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#sepfilter2d}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+sep\+Filter2D} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a85a8cac062c05efeecf99de50f3ab8d7}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Sobel}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}{org.\+opencv.\+imgproc.\+Imgproc\+::box\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{org.\+opencv.\+imgproc.\+Imgproc\+::blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{org.\+opencv.\+imgproc.\+Imgproc\+::filter2D}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad20d4e66d9913829813d3a22f96d8c6e}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad20d4e66d9913829813d3a22f96d8c6e}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!sep\+Filter2D@{sep\+Filter2D}}
\index{sep\+Filter2D@{sep\+Filter2D}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{sep\+Filter2\+D()}{sepFilter2D()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+sep\+Filter2D (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernelX,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{kernelY }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies a separable linear filter to an image.

The function applies a separable linear filter to the image. That is, first, every row of {\ttfamily src} is filtered with the 1D kernel {\ttfamily kernelX}. Then, every column of the result is filtered with the 1D kernel {\ttfamily kernelY}. The final result shifted by {\ttfamily delta} is stored in {\ttfamily dst}.


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & Destination image depth. The following combination of {\ttfamily src.\+depth()} and {\ttfamily ddepth} are supported\+: 
\begin{DoxyItemize}
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+8U}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+16S}/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+16U}/{\ttfamily C\+V\+\_\+16S}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+32F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+64F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+64F} 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


when {\ttfamily ddepth=-\/1}, the destination image will have the same depth as the source.


\begin{DoxyParams}{Parameters}
{\em kernelX} & Coefficients for filtering each row. \\
\hline
{\em kernelY} & Coefficients for filtering each column.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#sepfilter2d}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+sep\+Filter2D} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a85a8cac062c05efeecf99de50f3ab8d7}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Sobel}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_afb9afdc474cdb1b9242cf16ffc7017e3}{org.\+opencv.\+imgproc.\+Imgproc\+::box\+Filter}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ad7911d369fbc543ce20fb9872498e9c7}{org.\+opencv.\+imgproc.\+Imgproc\+::blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{org.\+opencv.\+imgproc.\+Imgproc\+::filter2D}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a85a8cac062c05efeecf99de50f3ab8d7}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a85a8cac062c05efeecf99de50f3ab8d7}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Sobel@{Sobel}}
\index{Sobel@{Sobel}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Sobel()}{Sobel()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Sobel (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{int}]{dx,  }\item[{int}]{dy,  }\item[{int}]{ksize,  }\item[{double}]{scale,  }\item[{double}]{delta,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

In all cases except one, the {\itshape ksize x\&lt\+BR\&gtksize} separable kernel is used to calculate the derivative. When {\itshape ksize = 1}, the {\itshape 3 x 1} or {\itshape 1 x 3} kernel is used (that is, no Gaussian smoothing is done). {\ttfamily ksize = 1} can only be used for the first or the second x-\/ or y-\/ derivatives.

There is also the special value {\ttfamily ksize = C\+V\+\_\+\+S\+C\+H\+A\+RR} (-\/1) that corresponds to the {\itshape 3x3} Scharr filter that may give more accurate results than the {\itshape 3x3} Sobel. The Scharr aperture is

{\itshape  $\vert$-\/3 0 3$\vert$ $\vert$-\/10 0 10$\vert$ $\vert$-\/3 0 3$\vert$ }

for the x-\/derivative, or transposed for the y-\/derivative.

The function calculates an image derivative by convolving the image with the appropriate kernel\+:

{\itshape dst = (d$^\wedge$(xorder+yorder) src)/(dx$^\wedge$(xorder) dy$^\wedge$(yorder))}

The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ({\ttfamily xorder} = 1, {\ttfamily yorder} = 0, {\ttfamily ksize} = 3) or ({\ttfamily xorder} = 0, {\ttfamily yorder} = 1, {\ttfamily ksize} = 3) to calculate the first x-\/ or y-\/ image derivative. The first case corresponds to a kernel of\+:

{\itshape  $\vert$-\/1 0 1$\vert$ $\vert$-\/2 0 2$\vert$ $\vert$-\/1 0 1$\vert$ }

The second case corresponds to a kernel of\+:

{\itshape  $\vert$-\/1 -\/2 -\/1$\vert$ $\vert$0 0 0$\vert$ $\vert$1 2 1$\vert$ }


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & output image depth; the following combinations of {\ttfamily src.\+depth()} and {\ttfamily ddepth} are supported\+: 
\begin{DoxyItemize}
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+8U}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+16S}/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+16U}/{\ttfamily C\+V\+\_\+16S}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+32F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+64F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+64F} 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


when {\ttfamily ddepth=-\/1}, the destination image will have the same depth as the source; in the case of 8-\/bit input images it will result in truncated derivatives.


\begin{DoxyParams}{Parameters}
{\em dx} & a dx \\
\hline
{\em dy} & a dy \\
\hline
{\em ksize} & size of the extended Sobel kernel; it must be 1, 3, 5, or 7. \\
\hline
{\em scale} & optional scale factor for the computed derivative values; by default, no scaling is applied (see \char`\"{}get\+Deriv\+Kernels\char`\"{} for details). \\
\hline
{\em delta} & optional delta value that is added to the results prior to storing them in {\ttfamily dst}. \\
\hline
{\em border\+Type} & pixel extrapolation method (see \char`\"{}border\+Interpolate\char`\"{} for details).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#sobel}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Sobel} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{org.\+opencv.\+imgproc.\+Imgproc\+::sep\+Filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_add62d4b55bc4e7cc4faca4a77f6d3f94}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Laplacian}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c9e2fdd65ecd76ae9135e33cfb9a99}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Scharr}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{org.\+opencv.\+imgproc.\+Imgproc\+::filter2D}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aaec4c3ad19dcdf58835672462d7e1186}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aaec4c3ad19dcdf58835672462d7e1186}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Sobel@{Sobel}}
\index{Sobel@{Sobel}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Sobel()}{Sobel()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Sobel (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{int}]{dx,  }\item[{int}]{dy,  }\item[{int}]{ksize,  }\item[{double}]{scale,  }\item[{double}]{delta }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

In all cases except one, the {\itshape ksize x\&lt\+BR\&gtksize} separable kernel is used to calculate the derivative. When {\itshape ksize = 1}, the {\itshape 3 x 1} or {\itshape 1 x 3} kernel is used (that is, no Gaussian smoothing is done). {\ttfamily ksize = 1} can only be used for the first or the second x-\/ or y-\/ derivatives.

There is also the special value {\ttfamily ksize = C\+V\+\_\+\+S\+C\+H\+A\+RR} (-\/1) that corresponds to the {\itshape 3x3} Scharr filter that may give more accurate results than the {\itshape 3x3} Sobel. The Scharr aperture is

{\itshape  $\vert$-\/3 0 3$\vert$ $\vert$-\/10 0 10$\vert$ $\vert$-\/3 0 3$\vert$ }

for the x-\/derivative, or transposed for the y-\/derivative.

The function calculates an image derivative by convolving the image with the appropriate kernel\+:

{\itshape dst = (d$^\wedge$(xorder+yorder) src)/(dx$^\wedge$(xorder) dy$^\wedge$(yorder))}

The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ({\ttfamily xorder} = 1, {\ttfamily yorder} = 0, {\ttfamily ksize} = 3) or ({\ttfamily xorder} = 0, {\ttfamily yorder} = 1, {\ttfamily ksize} = 3) to calculate the first x-\/ or y-\/ image derivative. The first case corresponds to a kernel of\+:

{\itshape  $\vert$-\/1 0 1$\vert$ $\vert$-\/2 0 2$\vert$ $\vert$-\/1 0 1$\vert$ }

The second case corresponds to a kernel of\+:

{\itshape  $\vert$-\/1 -\/2 -\/1$\vert$ $\vert$0 0 0$\vert$ $\vert$1 2 1$\vert$ }


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & output image depth; the following combinations of {\ttfamily src.\+depth()} and {\ttfamily ddepth} are supported\+: 
\begin{DoxyItemize}
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+8U}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+16S}/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+16U}/{\ttfamily C\+V\+\_\+16S}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+32F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+64F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+64F} 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


when {\ttfamily ddepth=-\/1}, the destination image will have the same depth as the source; in the case of 8-\/bit input images it will result in truncated derivatives.


\begin{DoxyParams}{Parameters}
{\em dx} & a dx \\
\hline
{\em dy} & a dy \\
\hline
{\em ksize} & size of the extended Sobel kernel; it must be 1, 3, 5, or 7. \\
\hline
{\em scale} & optional scale factor for the computed derivative values; by default, no scaling is applied (see \char`\"{}get\+Deriv\+Kernels\char`\"{} for details). \\
\hline
{\em delta} & optional delta value that is added to the results prior to storing them in {\ttfamily dst}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#sobel}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Sobel} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{org.\+opencv.\+imgproc.\+Imgproc\+::sep\+Filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_add62d4b55bc4e7cc4faca4a77f6d3f94}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Laplacian}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c9e2fdd65ecd76ae9135e33cfb9a99}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Scharr}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{org.\+opencv.\+imgproc.\+Imgproc\+::filter2D}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae4b25b52b9fa3942a6400c936cc2e683}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae4b25b52b9fa3942a6400c936cc2e683}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!Sobel@{Sobel}}
\index{Sobel@{Sobel}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{Sobel()}{Sobel()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+Sobel (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{int}]{ddepth,  }\item[{int}]{dx,  }\item[{int}]{dy }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.

In all cases except one, the {\itshape ksize x\&lt\+BR\&gtksize} separable kernel is used to calculate the derivative. When {\itshape ksize = 1}, the {\itshape 3 x 1} or {\itshape 1 x 3} kernel is used (that is, no Gaussian smoothing is done). {\ttfamily ksize = 1} can only be used for the first or the second x-\/ or y-\/ derivatives.

There is also the special value {\ttfamily ksize = C\+V\+\_\+\+S\+C\+H\+A\+RR} (-\/1) that corresponds to the {\itshape 3x3} Scharr filter that may give more accurate results than the {\itshape 3x3} Sobel. The Scharr aperture is

{\itshape  $\vert$-\/3 0 3$\vert$ $\vert$-\/10 0 10$\vert$ $\vert$-\/3 0 3$\vert$ }

for the x-\/derivative, or transposed for the y-\/derivative.

The function calculates an image derivative by convolving the image with the appropriate kernel\+:

{\itshape dst = (d$^\wedge$(xorder+yorder) src)/(dx$^\wedge$(xorder) dy$^\wedge$(yorder))}

The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ({\ttfamily xorder} = 1, {\ttfamily yorder} = 0, {\ttfamily ksize} = 3) or ({\ttfamily xorder} = 0, {\ttfamily yorder} = 1, {\ttfamily ksize} = 3) to calculate the first x-\/ or y-\/ image derivative. The first case corresponds to a kernel of\+:

{\itshape  $\vert$-\/1 0 1$\vert$ $\vert$-\/2 0 2$\vert$ $\vert$-\/1 0 1$\vert$ }

The second case corresponds to a kernel of\+:

{\itshape  $\vert$-\/1 -\/2 -\/1$\vert$ $\vert$0 0 0$\vert$ $\vert$1 2 1$\vert$ }


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as {\ttfamily src}. \\
\hline
{\em ddepth} & output image depth; the following combinations of {\ttfamily src.\+depth()} and {\ttfamily ddepth} are supported\+: 
\begin{DoxyItemize}
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+8U}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+16S}/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+16U}/{\ttfamily C\+V\+\_\+16S}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+32F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+32F}/{\ttfamily C\+V\+\_\+64F} 
\item {\ttfamily src.\+depth()} = {\ttfamily C\+V\+\_\+64F}, {\ttfamily ddepth} = -\/1/{\ttfamily C\+V\+\_\+64F} 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}


when {\ttfamily ddepth=-\/1}, the destination image will have the same depth as the source; in the case of 8-\/bit input images it will result in truncated derivatives.


\begin{DoxyParams}{Parameters}
{\em dx} & a dx \\
\hline
{\em dy} & a dy\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/filtering.html#sobel}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+Sobel} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1f720ad6bef4616a3268c98abd811350}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Gaussian\+Blur}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a395a53b9bd769978c12c2c19a02ffeae}{org.\+opencv.\+core.\+Core\+::cart\+To\+Polar}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a7c78cbc2fc093f0008a749cfa15c3a81}{org.\+opencv.\+imgproc.\+Imgproc\+::sep\+Filter2D}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_add62d4b55bc4e7cc4faca4a77f6d3f94}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Laplacian}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a94c9e2fdd65ecd76ae9135e33cfb9a99}{org.\+opencv.\+imgproc.\+Imgproc\+::\+Scharr}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af8d713c4327b7458705f063ad4fa83e5}{org.\+opencv.\+imgproc.\+Imgproc\+::filter2D}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a428d1896f05ae5e0eadbe9a1489e6368}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a428d1896f05ae5e0eadbe9a1489e6368}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!threshold@{threshold}}
\index{threshold@{threshold}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{threshold()}{threshold()}}
{\footnotesize\ttfamily static double org.\+opencv.\+imgproc.\+Imgproc.\+threshold (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{double}]{thresh,  }\item[{double}]{maxval,  }\item[{int}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies a fixed-\/level threshold to each array element.

The function applies fixed-\/level thresholding to a single-\/channel array. The function is typically used to get a bi-\/level (binary) image out of a grayscale image (\char`\"{}compare\char`\"{} could be also used for this purpose) or for removing a noise, that is, filtering out pixels with too small or too large values. There are several types of thresholding supported by the function. They are determined by {\ttfamily type} \+:


\begin{DoxyItemize}
\item T\+H\+R\+E\+S\+H\+\_\+\+B\+I\+N\+A\+RY 
\end{DoxyItemize}

{\itshape dst(x,y) = maxval if src(x,y) \&gt thresh; 0 otherwise}


\begin{DoxyItemize}
\item T\+H\+R\+E\+S\+H\+\_\+\+B\+I\+N\+A\+R\+Y\+\_\+\+I\+NV 
\end{DoxyItemize}

{\itshape dst(x,y) = 0 if src(x,y) \&gt thresh; maxval otherwise}


\begin{DoxyItemize}
\item T\+H\+R\+E\+S\+H\+\_\+\+T\+R\+U\+NC 
\end{DoxyItemize}

{\itshape dst(x,y) = threshold if src(x,y) \&gt thresh; src(x,y) otherwise}


\begin{DoxyItemize}
\item T\+H\+R\+E\+S\+H\+\_\+\+T\+O\+Z\+E\+RO 
\end{DoxyItemize}

{\itshape dst(x,y) = src(x,y) if src(x,y) \&gt thresh; 0 otherwise}


\begin{DoxyItemize}
\item T\+H\+R\+E\+S\+H\+\_\+\+T\+O\+Z\+E\+R\+O\+\_\+\+I\+NV 
\end{DoxyItemize}

{\itshape dst(x,y) = 0 if src(x,y) \&gt thresh; src(x,y) otherwise}

Also, the special value {\ttfamily T\+H\+R\+E\+S\+H\+\_\+\+O\+T\+SU} may be combined with one of the above values. In this case, the function determines the optimal threshold value using the Otsu\textquotesingle{}s algorithm and uses it instead of the specified {\ttfamily thresh}. The function returns the computed threshold value. Currently, the Otsu\textquotesingle{}s method is implemented only for 8-\/bit images.


\begin{DoxyParams}{Parameters}
{\em src} & input array (single-\/channel, 8-\/bit or 32-\/bit floating point). \\
\hline
{\em dst} & output array of the same size and type as {\ttfamily src}. \\
\hline
{\em thresh} & threshold value. \\
\hline
{\em maxval} & maximum value to use with the {\ttfamily T\+H\+R\+E\+S\+H\+\_\+\+B\+I\+N\+A\+RY} and {\ttfamily T\+H\+R\+E\+S\+H\+\_\+\+B\+I\+N\+A\+R\+Y\+\_\+\+I\+NV} thresholding types. \\
\hline
{\em type} & thresholding type (see the details below).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#threshold}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+threshold} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a60284da5baddfe0b44c6553177de8bf9}{org.\+opencv.\+imgproc.\+Imgproc\+::find\+Contours}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_aae8ad4feaca1ca8234bd88cbf9090cf5}{org.\+opencv.\+core.\+Core\+::max}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8daf182545498116be4dabcfd9a0429e}{org.\+opencv.\+imgproc.\+Imgproc\+::adaptive\+Threshold}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a6f1dc64655b7da1219d82f809efb7e16}{org.\+opencv.\+core.\+Core\+::compare}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a24561bfde2c7fe7d2b7bee9d5ba8c92e}{org.\+opencv.\+core.\+Core\+::min}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0733bf11be8125dfc28b6ff4da746927}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0733bf11be8125dfc28b6ff4da746927}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!undistort@{undistort}}
\index{undistort@{undistort}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{undistort()}{undistort()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+undistort (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{new\+Camera\+Matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Transforms an image to compensate for lens distortion.

The function transforms an image to compensate radial and tangential lens distortion.

The function is simply a combination of \char`\"{}init\+Undistort\+Rectify\+Map\char`\"{} (with unity {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}}) and \char`\"{}remap\char`\"{} (with bilinear interpolation). See the former function for details of the transformation being performed.

Those pixels in the destination image, for which there is no correspondent pixels in the source image, are filled with zeros (black color).

A particular subset of the source image that will be visible in the corrected image can be regulated by {\ttfamily new\+Camera\+Matrix}. You can use \char`\"{}get\+Optimal\+New\+Camera\+Matrix\char`\"{} to compute the appropriate {\ttfamily new\+Camera\+Matrix} depending on your requirements.

The camera matrix and the distortion parameters can be determined using \char`\"{}calibrate\+Camera\char`\"{}. If the resolution of images is different from the resolution used at the calibration stage, {\itshape f\+\_\+x, f\+\_\+y, c\+\_\+x} and {\itshape c\+\_\+y} need to be scaled accordingly, while the distortion coefficients remain the same.


\begin{DoxyParams}{Parameters}
{\em src} & Input (distorted) image. \\
\hline
{\em dst} & Output (corrected) image that has the same size and type as {\ttfamily src}. \\
\hline
{\em camera\+Matrix} & Input camera matrix {\itshape A = }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x 0 c\+\_\+x$\vert$ $\vert$0 f\+\_\+y c\+\_\+y$\vert$ $\vert$0 0 1$\vert$ .

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed. \\
\hline
{\em new\+Camera\+Matrix} & Camera matrix of the distorted image. By default, it is the same as {\ttfamily camera\+Matrix} but you may additionally scale and shift the result by using a different matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#undistort}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+undistort} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5763c06b8dcd1822d88a806d485ad0c7}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a5763c06b8dcd1822d88a806d485ad0c7}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!undistort@{undistort}}
\index{undistort@{undistort}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{undistort()}{undistort()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+undistort (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Transforms an image to compensate for lens distortion.

The function transforms an image to compensate radial and tangential lens distortion.

The function is simply a combination of \char`\"{}init\+Undistort\+Rectify\+Map\char`\"{} (with unity {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}}) and \char`\"{}remap\char`\"{} (with bilinear interpolation). See the former function for details of the transformation being performed.

Those pixels in the destination image, for which there is no correspondent pixels in the source image, are filled with zeros (black color).

A particular subset of the source image that will be visible in the corrected image can be regulated by {\ttfamily new\+Camera\+Matrix}. You can use \char`\"{}get\+Optimal\+New\+Camera\+Matrix\char`\"{} to compute the appropriate {\ttfamily new\+Camera\+Matrix} depending on your requirements.

The camera matrix and the distortion parameters can be determined using \char`\"{}calibrate\+Camera\char`\"{}. If the resolution of images is different from the resolution used at the calibration stage, {\itshape f\+\_\+x, f\+\_\+y, c\+\_\+x} and {\itshape c\+\_\+y} need to be scaled accordingly, while the distortion coefficients remain the same.


\begin{DoxyParams}{Parameters}
{\em src} & Input (distorted) image. \\
\hline
{\em dst} & Output (corrected) image that has the same size and type as {\ttfamily src}. \\
\hline
{\em camera\+Matrix} & Input camera matrix {\itshape A = }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x 0 c\+\_\+x$\vert$ $\vert$0 f\+\_\+y c\+\_\+y$\vert$ $\vert$0 0 1$\vert$ .

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#undistort}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+undistort} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af7bbf66c0f84809e3e83482f63e628f5}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_af7bbf66c0f84809e3e83482f63e628f5}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!undistort\+Points@{undistort\+Points}}
\index{undistort\+Points@{undistort\+Points}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{undistort\+Points()}{undistortPoints()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+undistort\+Points (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{R,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{P }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes the ideal point coordinates from the observed point coordinates.

The function is similar to \char`\"{}undistort\char`\"{} and \char`\"{}init\+Undistort\+Rectify\+Map\char`\"{} but it operates on a sparse set of points instead of a raster image. Also the function performs a reverse transformation to\char`\"{}project\+Points\char`\"{}. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a planar object, it does, up to a translation vector, if the proper {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}} is specified. {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // (u,v) is the input point, (u\textquotesingle{}, v\textquotesingle{}) is the output point}

{\ttfamily }

{\ttfamily }

{\ttfamily // camera\+\_\+matrix=\mbox{[}fx 0 cx; 0 fy cy; 0 0 1\mbox{]}}

{\ttfamily }

{\ttfamily }

{\ttfamily // P=\mbox{[}fx\textquotesingle{} 0 cx\textquotesingle{} tx; 0 fy\textquotesingle{} cy\textquotesingle{} ty; 0 0 1 tz\mbox{]}}

{\ttfamily }

{\ttfamily }

{\ttfamily x" = (u -\/ cx)/fx}

{\ttfamily }

{\ttfamily }

{\ttfamily y" = (v -\/ cy)/fy}

{\ttfamily }

{\ttfamily }

{\ttfamily (x\textquotesingle{},y\textquotesingle{}) = undistort(x\char`\"{},y\char`\"{},dist\+\_\+coeffs)}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{[}X,Y,W\mbox{]}T = R$\ast$\mbox{[}x\textquotesingle{} y\textquotesingle{} 1\mbox{]}T}

{\ttfamily }

{\ttfamily }

{\ttfamily x = X/W, y = Y/W}

{\ttfamily }

{\ttfamily }

{\ttfamily // only performed if P=\mbox{[}fx\textquotesingle{} 0 cx\textquotesingle{} \mbox{[}tx\mbox{]}; 0 fy\textquotesingle{} cy\textquotesingle{} \mbox{[}ty\mbox{]}; 0 0 1 \mbox{[}tz\mbox{]}\mbox{]} is specified}

{\ttfamily }

{\ttfamily }

{\ttfamily u\textquotesingle{} = x$\ast$fx\textquotesingle{} + cx\textquotesingle{}}

{\ttfamily }

{\ttfamily }

{\ttfamily v\textquotesingle{} = y$\ast$fy\textquotesingle{} + cy\textquotesingle{},}

{\ttfamily }

{\ttfamily }

{\ttfamily where {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0733bf11be8125dfc28b6ff4da746927}{undistort()}}} is an approximate iterative algorithm that estimates the normalized original point coordinates out of the normalized distorted point coordinates (\char`\"{}normalized\char`\"{} means that the coordinates do not depend on the camera matrix). }

The function can be used for both a stereo camera head or a monocular camera (when \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} is empty).


\begin{DoxyParams}{Parameters}
{\em src} & Observed point coordinates, 1xN or Nx1 2-\/channel (C\+V\+\_\+32\+F\+C2 or C\+V\+\_\+64\+F\+C2). \\
\hline
{\em dst} & Output ideal point coordinates after undistortion and reverse perspective transformation. If matrix {\ttfamily P} is identity or omitted, {\ttfamily dst} will contain normalized point coordinates. \\
\hline
{\em camera\+Matrix} & Camera matrix {\itshape  }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x 0 c\+\_\+x$\vert$ $\vert$0 f\+\_\+y c\+\_\+y$\vert$ $\vert$0 0 1$\vert$ .

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed. \\
\hline
{\em \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}} & Rectification transformation in the object space (3x3 matrix). {\ttfamily R1} or {\ttfamily R2} computed by \char`\"{}stereo\+Rectify\char`\"{} can be passed here. If the matrix is empty, the identity transformation is used. \\
\hline
{\em P} & New camera matrix (3x3) or new projection matrix (3x4). {\ttfamily P1} or {\ttfamily P2} computed by \char`\"{}stereo\+Rectify\char`\"{} can be passed here. If the matrix is empty, the identity new camera matrix is used.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#undistortpoints}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+undistort\+Points} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa6556f1cfb24b79075a9ab96d06a1fd2}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa6556f1cfb24b79075a9ab96d06a1fd2}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!undistort\+Points@{undistort\+Points}}
\index{undistort\+Points@{undistort\+Points}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{undistort\+Points()}{undistortPoints()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+undistort\+Points (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_of_point2f}{Mat\+Of\+Point2f}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{camera\+Matrix,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dist\+Coeffs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes the ideal point coordinates from the observed point coordinates.

The function is similar to \char`\"{}undistort\char`\"{} and \char`\"{}init\+Undistort\+Rectify\+Map\char`\"{} but it operates on a sparse set of points instead of a raster image. Also the function performs a reverse transformation to\char`\"{}project\+Points\char`\"{}. In case of a 3D object, it does not reconstruct its 3D coordinates, but for a planar object, it does, up to a translation vector, if the proper {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}}} is specified. {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // (u,v) is the input point, (u\textquotesingle{}, v\textquotesingle{}) is the output point}

{\ttfamily }

{\ttfamily }

{\ttfamily // camera\+\_\+matrix=\mbox{[}fx 0 cx; 0 fy cy; 0 0 1\mbox{]}}

{\ttfamily }

{\ttfamily }

{\ttfamily // P=\mbox{[}fx\textquotesingle{} 0 cx\textquotesingle{} tx; 0 fy\textquotesingle{} cy\textquotesingle{} ty; 0 0 1 tz\mbox{]}}

{\ttfamily }

{\ttfamily }

{\ttfamily x" = (u -\/ cx)/fx}

{\ttfamily }

{\ttfamily }

{\ttfamily y" = (v -\/ cy)/fy}

{\ttfamily }

{\ttfamily }

{\ttfamily (x\textquotesingle{},y\textquotesingle{}) = undistort(x\char`\"{},y\char`\"{},dist\+\_\+coeffs)}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{[}X,Y,W\mbox{]}T = R$\ast$\mbox{[}x\textquotesingle{} y\textquotesingle{} 1\mbox{]}T}

{\ttfamily }

{\ttfamily }

{\ttfamily x = X/W, y = Y/W}

{\ttfamily }

{\ttfamily }

{\ttfamily // only performed if P=\mbox{[}fx\textquotesingle{} 0 cx\textquotesingle{} \mbox{[}tx\mbox{]}; 0 fy\textquotesingle{} cy\textquotesingle{} \mbox{[}ty\mbox{]}; 0 0 1 \mbox{[}tz\mbox{]}\mbox{]} is specified}

{\ttfamily }

{\ttfamily }

{\ttfamily u\textquotesingle{} = x$\ast$fx\textquotesingle{} + cx\textquotesingle{}}

{\ttfamily }

{\ttfamily }

{\ttfamily v\textquotesingle{} = y$\ast$fy\textquotesingle{} + cy\textquotesingle{},}

{\ttfamily }

{\ttfamily }

{\ttfamily where {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0733bf11be8125dfc28b6ff4da746927}{undistort()}}} is an approximate iterative algorithm that estimates the normalized original point coordinates out of the normalized distorted point coordinates (\char`\"{}normalized\char`\"{} means that the coordinates do not depend on the camera matrix). }

The function can be used for both a stereo camera head or a monocular camera (when \mbox{\hyperlink{classorg_1_1opencv_1_1_r}{R}} is empty).


\begin{DoxyParams}{Parameters}
{\em src} & Observed point coordinates, 1xN or Nx1 2-\/channel (C\+V\+\_\+32\+F\+C2 or C\+V\+\_\+64\+F\+C2). \\
\hline
{\em dst} & Output ideal point coordinates after undistortion and reverse perspective transformation. If matrix {\ttfamily P} is identity or omitted, {\ttfamily dst} will contain normalized point coordinates. \\
\hline
{\em camera\+Matrix} & Camera matrix {\itshape  }\\
\hline
\end{DoxyParams}
$\vert$f\+\_\+x 0 c\+\_\+x$\vert$ $\vert$0 f\+\_\+y c\+\_\+y$\vert$ $\vert$0 0 1$\vert$ .

{\itshape  
\begin{DoxyParams}{Parameters}
{\em dist\+Coeffs} & Input vector of distortion coefficients {\itshape (k\+\_\+1, k\+\_\+2, p\+\_\+1, p\+\_\+2\mbox{[}, k\+\_\+3\mbox{[}, k\+\_\+4, k\+\_\+5, k\+\_\+6\mbox{]}\mbox{]})} of 4, 5, or 8 elements. If the vector is N\+U\+L\+L/empty, the zero distortion coefficients are assumed.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#undistortpoints}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+undistort\+Points} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!warp\+Affine@{warp\+Affine}}
\index{warp\+Affine@{warp\+Affine}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{warp\+Affine()}{warpAffine()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Affine (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{M,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dsize,  }\item[{int}]{flags,  }\item[{int}]{border\+Mode,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{border\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies an affine transformation to an image.

The function {\ttfamily warp\+Affine} transforms the source image using the specified matrix\+:

{\itshape dst(x,y) = src(M \+\_\+11 x + M \+\_\+12 y + M \+\_\+13, M \+\_\+21 x + M \+\_\+22 y + M \+\_\+23)}

when the flag {\ttfamily W\+A\+R\+P\+\_\+\+I\+N\+V\+E\+R\+S\+E\+\_\+\+M\+AP} is set. Otherwise, the transformation is first inverted with \char`\"{}invert\+Affine\+Transform\char`\"{} and then put in the formula above instead of {\ttfamily M}. The function cannot operate in-\/place.

Note\+: {\ttfamily cv\+Get\+Quadrangle\+Sub\+Pix} is similar to {\ttfamily cv\+Warp\+Affine}, but the outliers are extrapolated using replication border mode.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image that has the size {\ttfamily dsize} and the same type as {\ttfamily src}. \\
\hline
{\em M} & {\itshape 2x 3} transformation matrix. \\
\hline
{\em dsize} & size of the output image. \\
\hline
{\em flags} & combination of interpolation methods (see \char`\"{}resize\char`\"{}) and the optional flag {\ttfamily W\+A\+R\+P\+\_\+\+I\+N\+V\+E\+R\+S\+E\+\_\+\+M\+AP} that means that {\ttfamily M} is the inverse transformation ({\itshape dst-\/$>$src}). \\
\hline
{\em border\+Mode} & pixel extrapolation method (see \char`\"{}border\+Interpolate\char`\"{}); when {\ttfamily border\+Mode=B\+O\+R\+D\+E\+R\+\_\+\+T\+R\+A\+N\+S\+P\+A\+R\+E\+NT}, it means that the pixels in the destination image corresponding to the \char`\"{}outliers\char`\"{} in the source image are not modified by the function. \\
\hline
{\em border\+Value} & value used in case of a constant border; by default, it is 0.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpaffine}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Affine} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}{org.\+opencv.\+imgproc.\+Imgproc\+::remap}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa547e4fbdf1a4806a1fd35ebbfe2a117}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Rect\+Sub\+Pix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae781b575f9f20dbefb20eb2bb9966ae2}{org.\+opencv.\+imgproc.\+Imgproc\+::resize}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a221e7697d1a57961ee8a843b7aa05b75}{org.\+opencv.\+core.\+Core\+::transform}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a261169d40fb66824c5cb3e5f86df0799}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a261169d40fb66824c5cb3e5f86df0799}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!warp\+Affine@{warp\+Affine}}
\index{warp\+Affine@{warp\+Affine}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{warp\+Affine()}{warpAffine()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Affine (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{M,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dsize,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies an affine transformation to an image.

The function {\ttfamily warp\+Affine} transforms the source image using the specified matrix\+:

{\itshape dst(x,y) = src(M \+\_\+11 x + M \+\_\+12 y + M \+\_\+13, M \+\_\+21 x + M \+\_\+22 y + M \+\_\+23)}

when the flag {\ttfamily W\+A\+R\+P\+\_\+\+I\+N\+V\+E\+R\+S\+E\+\_\+\+M\+AP} is set. Otherwise, the transformation is first inverted with \char`\"{}invert\+Affine\+Transform\char`\"{} and then put in the formula above instead of {\ttfamily M}. The function cannot operate in-\/place.

Note\+: {\ttfamily cv\+Get\+Quadrangle\+Sub\+Pix} is similar to {\ttfamily cv\+Warp\+Affine}, but the outliers are extrapolated using replication border mode.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image that has the size {\ttfamily dsize} and the same type as {\ttfamily src}. \\
\hline
{\em M} & {\itshape 2x 3} transformation matrix. \\
\hline
{\em dsize} & size of the output image. \\
\hline
{\em flags} & combination of interpolation methods (see \char`\"{}resize\char`\"{}) and the optional flag {\ttfamily W\+A\+R\+P\+\_\+\+I\+N\+V\+E\+R\+S\+E\+\_\+\+M\+AP} that means that {\ttfamily M} is the inverse transformation ({\itshape dst-\/$>$src}).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpaffine}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Affine} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}{org.\+opencv.\+imgproc.\+Imgproc\+::remap}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa547e4fbdf1a4806a1fd35ebbfe2a117}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Rect\+Sub\+Pix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae781b575f9f20dbefb20eb2bb9966ae2}{org.\+opencv.\+imgproc.\+Imgproc\+::resize}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a221e7697d1a57961ee8a843b7aa05b75}{org.\+opencv.\+core.\+Core\+::transform}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0fdebc53734476460d5fe9b2cb3b5154}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a0fdebc53734476460d5fe9b2cb3b5154}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!warp\+Affine@{warp\+Affine}}
\index{warp\+Affine@{warp\+Affine}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{warp\+Affine()}{warpAffine()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Affine (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{M,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dsize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies an affine transformation to an image.

The function {\ttfamily warp\+Affine} transforms the source image using the specified matrix\+:

{\itshape dst(x,y) = src(M \+\_\+11 x + M \+\_\+12 y + M \+\_\+13, M \+\_\+21 x + M \+\_\+22 y + M \+\_\+23)}

when the flag {\ttfamily W\+A\+R\+P\+\_\+\+I\+N\+V\+E\+R\+S\+E\+\_\+\+M\+AP} is set. Otherwise, the transformation is first inverted with \char`\"{}invert\+Affine\+Transform\char`\"{} and then put in the formula above instead of {\ttfamily M}. The function cannot operate in-\/place.

Note\+: {\ttfamily cv\+Get\+Quadrangle\+Sub\+Pix} is similar to {\ttfamily cv\+Warp\+Affine}, but the outliers are extrapolated using replication border mode.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image that has the size {\ttfamily dsize} and the same type as {\ttfamily src}. \\
\hline
{\em M} & {\itshape 2x 3} transformation matrix. \\
\hline
{\em dsize} & size of the output image.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpaffine}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Affine} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}{org.\+opencv.\+imgproc.\+Imgproc\+::remap}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Perspective}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa547e4fbdf1a4806a1fd35ebbfe2a117}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Rect\+Sub\+Pix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae781b575f9f20dbefb20eb2bb9966ae2}{org.\+opencv.\+imgproc.\+Imgproc\+::resize}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a221e7697d1a57961ee8a843b7aa05b75}{org.\+opencv.\+core.\+Core\+::transform}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aad167fa9fe0009a54f7732488102938c}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!warp\+Perspective@{warp\+Perspective}}
\index{warp\+Perspective@{warp\+Perspective}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{warp\+Perspective()}{warpPerspective()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Perspective (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{M,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dsize,  }\item[{int}]{flags,  }\item[{int}]{border\+Mode,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{border\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies a perspective transformation to an image.

The function {\ttfamily warp\+Perspective} transforms the source image using the specified matrix\+:

{\itshape dst(x,y) = src((M\+\_\+11 x + M\+\_\+12 y + M\+\_\+13)/(M\+\_\+(31) x + M\+\_\+32 y + M\+\_\+33),\&lt\+BR\&gt(M\+\_\+21 x + M\+\_\+22 y + M\+\_\+23)/(M\+\_\+(31) x + M\+\_\+32 y + M\+\_\+33))}

when the flag {\ttfamily W\+A\+R\+P\+\_\+\+I\+N\+V\+E\+R\+S\+E\+\_\+\+M\+AP} is set. Otherwise, the transformation is first inverted with \char`\"{}invert\char`\"{} and then put in the formula above instead of {\ttfamily M}. The function cannot operate in-\/place.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image that has the size {\ttfamily dsize} and the same type as {\ttfamily src}. \\
\hline
{\em M} & {\itshape 3x 3} transformation matrix. \\
\hline
{\em dsize} & size of the output image. \\
\hline
{\em flags} & combination of interpolation methods ({\ttfamily I\+N\+T\+E\+R\+\_\+\+L\+I\+N\+E\+AR} or {\ttfamily I\+N\+T\+E\+R\+\_\+\+N\+E\+A\+R\+E\+ST}) and the optional flag {\ttfamily W\+A\+R\+P\+\_\+\+I\+N\+V\+E\+R\+S\+E\+\_\+\+M\+AP}, that sets {\ttfamily M} as the inverse transformation ({\itshape dst-\/$>$src}). \\
\hline
{\em border\+Mode} & pixel extrapolation method ({\ttfamily B\+O\+R\+D\+E\+R\+\_\+\+C\+O\+N\+S\+T\+A\+NT} or {\ttfamily B\+O\+R\+D\+E\+R\+\_\+\+R\+E\+P\+L\+I\+C\+A\+TE}). \\
\hline
{\em border\+Value} & value used in case of a constant border; by default, it equals 0.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpperspective}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Perspective} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Affine}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}{org.\+opencv.\+imgproc.\+Imgproc\+::remap}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1ff0eace0f00e79af5228fdae120342a}{org.\+opencv.\+core.\+Core\+::perspective\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa547e4fbdf1a4806a1fd35ebbfe2a117}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Rect\+Sub\+Pix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae781b575f9f20dbefb20eb2bb9966ae2}{org.\+opencv.\+imgproc.\+Imgproc\+::resize}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3608b9b4fab7fe199ebcfeed938d59f5}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3608b9b4fab7fe199ebcfeed938d59f5}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!warp\+Perspective@{warp\+Perspective}}
\index{warp\+Perspective@{warp\+Perspective}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{warp\+Perspective()}{warpPerspective()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Perspective (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{M,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dsize,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies a perspective transformation to an image.

The function {\ttfamily warp\+Perspective} transforms the source image using the specified matrix\+:

{\itshape dst(x,y) = src((M\+\_\+11 x + M\+\_\+12 y + M\+\_\+13)/(M\+\_\+(31) x + M\+\_\+32 y + M\+\_\+33),\&lt\+BR\&gt(M\+\_\+21 x + M\+\_\+22 y + M\+\_\+23)/(M\+\_\+(31) x + M\+\_\+32 y + M\+\_\+33))}

when the flag {\ttfamily W\+A\+R\+P\+\_\+\+I\+N\+V\+E\+R\+S\+E\+\_\+\+M\+AP} is set. Otherwise, the transformation is first inverted with \char`\"{}invert\char`\"{} and then put in the formula above instead of {\ttfamily M}. The function cannot operate in-\/place.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image that has the size {\ttfamily dsize} and the same type as {\ttfamily src}. \\
\hline
{\em M} & {\itshape 3x 3} transformation matrix. \\
\hline
{\em dsize} & size of the output image. \\
\hline
{\em flags} & combination of interpolation methods ({\ttfamily I\+N\+T\+E\+R\+\_\+\+L\+I\+N\+E\+AR} or {\ttfamily I\+N\+T\+E\+R\+\_\+\+N\+E\+A\+R\+E\+ST}) and the optional flag {\ttfamily W\+A\+R\+P\+\_\+\+I\+N\+V\+E\+R\+S\+E\+\_\+\+M\+AP}, that sets {\ttfamily M} as the inverse transformation ({\itshape dst-\/$>$src}).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpperspective}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Perspective} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Affine}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}{org.\+opencv.\+imgproc.\+Imgproc\+::remap}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1ff0eace0f00e79af5228fdae120342a}{org.\+opencv.\+core.\+Core\+::perspective\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa547e4fbdf1a4806a1fd35ebbfe2a117}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Rect\+Sub\+Pix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae781b575f9f20dbefb20eb2bb9966ae2}{org.\+opencv.\+imgproc.\+Imgproc\+::resize}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1c33b5777145642c0670124ea3a35b01}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a1c33b5777145642c0670124ea3a35b01}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!warp\+Perspective@{warp\+Perspective}}
\index{warp\+Perspective@{warp\+Perspective}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{warp\+Perspective()}{warpPerspective()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Perspective (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{src,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{dst,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{M,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{dsize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Applies a perspective transformation to an image.

The function {\ttfamily warp\+Perspective} transforms the source image using the specified matrix\+:

{\itshape dst(x,y) = src((M\+\_\+11 x + M\+\_\+12 y + M\+\_\+13)/(M\+\_\+(31) x + M\+\_\+32 y + M\+\_\+33),\&lt\+BR\&gt(M\+\_\+21 x + M\+\_\+22 y + M\+\_\+23)/(M\+\_\+(31) x + M\+\_\+32 y + M\+\_\+33))}

when the flag {\ttfamily W\+A\+R\+P\+\_\+\+I\+N\+V\+E\+R\+S\+E\+\_\+\+M\+AP} is set. Otherwise, the transformation is first inverted with \char`\"{}invert\char`\"{} and then put in the formula above instead of {\ttfamily M}. The function cannot operate in-\/place.


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image that has the size {\ttfamily dsize} and the same type as {\ttfamily src}. \\
\hline
{\em M} & {\itshape 3x 3} transformation matrix. \\
\hline
{\em dsize} & size of the output image.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/geometric_transformations.html#warpperspective}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+warp\+Perspective} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a139ccfb9b241fc867096f4c850088058}{org.\+opencv.\+imgproc.\+Imgproc\+::warp\+Affine}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a8a8e3511105ae0f5fbd525e31ad7672c}{org.\+opencv.\+imgproc.\+Imgproc\+::remap}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_core_a1ff0eace0f00e79af5228fdae120342a}{org.\+opencv.\+core.\+Core\+::perspective\+Transform}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aa547e4fbdf1a4806a1fd35ebbfe2a117}{org.\+opencv.\+imgproc.\+Imgproc\+::get\+Rect\+Sub\+Pix}} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_ae781b575f9f20dbefb20eb2bb9966ae2}{org.\+opencv.\+imgproc.\+Imgproc\+::resize}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3d24a06a891561fbcf918cefee4f1977}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a3d24a06a891561fbcf918cefee4f1977}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!watershed@{watershed}}
\index{watershed@{watershed}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{watershed()}{watershed()}}
{\footnotesize\ttfamily static void org.\+opencv.\+imgproc.\+Imgproc.\+watershed (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{image,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{markers }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs a marker-\/based image segmentation using the watershed algorithm.

The function implements one of the variants of watershed, non-\/parametric marker-\/based segmentation algorithm, described in \mbox{[}Meyer92\mbox{]}.

Before passing the image to the function, you have to roughly outline the desired regions in the image {\ttfamily markers} with positive ({\ttfamily $>$0}) indices. So, every region is represented as one or more connected components with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary mask using \char`\"{}find\+Contours\char`\"{} and \char`\"{}draw\+Contours\char`\"{} (see the {\ttfamily watershed.\+cpp} demo). The markers are \char`\"{}seeds\char`\"{} of the future image regions. All the other pixels in {\ttfamily markers}, whose relation to the outlined regions is not known and should be defined by the algorithm, should be set to 0\textquotesingle{}s. In the function output, each pixel in markers is set to a value of the \char`\"{}seed\char`\"{} components or to -\/1 at boundaries between the regions.

Visual demonstration and usage example of the function can be found in the Open\+CV samples directory (see the {\ttfamily watershed.\+cpp} demo).

Note\+: Any two neighbor connected components are not necessarily separated by a watershed boundary (-\/1\textquotesingle{}s pixels); for example, they can touch each other in the initial marker image passed to the function.

Note\+:


\begin{DoxyItemize}
\item An example using the watershed algorithm can be found at opencv\+\_\+source\+\_\+code/samples/cpp/watershed.\+cpp 
\item (Python) An example using the watershed algorithm can be found at opencv\+\_\+source\+\_\+code/samples/python2/watershed.\+py 
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em image} & Input 8-\/bit 3-\/channel image. \\
\hline
{\em markers} & Input/output 32-\/bit single-\/channel image (map) of markers. It should have the same size as {\ttfamily image}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html#watershed}{\tt org.\+opencv.\+imgproc.\+Imgproc.\+watershed} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_a60284da5baddfe0b44c6553177de8bf9}{org.\+opencv.\+imgproc.\+Imgproc\+::find\+Contours}} 
\end{DoxySeeAlso}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abf7d30bf7b45f87ff811c486d74a6e66}\label{classorg_1_1opencv_1_1imgproc_1_1_imgproc_abf7d30bf7b45f87ff811c486d74a6e66}} 
\index{org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}!C\+V\+\_\+\+B\+L\+U\+R\+\_\+\+N\+O\+\_\+\+S\+C\+A\+LE@{C\+V\+\_\+\+B\+L\+U\+R\+\_\+\+N\+O\+\_\+\+S\+C\+A\+LE}}
\index{C\+V\+\_\+\+B\+L\+U\+R\+\_\+\+N\+O\+\_\+\+S\+C\+A\+LE@{C\+V\+\_\+\+B\+L\+U\+R\+\_\+\+N\+O\+\_\+\+S\+C\+A\+LE}!org\+::opencv\+::imgproc\+::\+Imgproc@{org\+::opencv\+::imgproc\+::\+Imgproc}}
\subsubsection{\texorpdfstring{C\+V\+\_\+\+B\+L\+U\+R\+\_\+\+N\+O\+\_\+\+S\+C\+A\+LE}{CV\_BLUR\_NO\_SCALE}}
{\footnotesize\ttfamily final int org.\+opencv.\+imgproc.\+Imgproc.\+C\+V\+\_\+\+B\+L\+U\+R\+\_\+\+N\+O\+\_\+\+S\+C\+A\+LE = 0\hspace{0.3cm}{\ttfamily [static]}}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/\+Marcius/\+Documents/\+Git\+Hub/\+Skaitliuko-\/\+Skeneris/open\+C\+V\+Library249/src/main/java/org/opencv/imgproc/\mbox{\hyperlink{_imgproc_8java}{Imgproc.\+java}}\end{DoxyCompactItemize}
