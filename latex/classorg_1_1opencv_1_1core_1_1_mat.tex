\hypertarget{classorg_1_1opencv_1_1core_1_1_mat}{}\section{org.\+opencv.\+core.\+Mat Class Reference}
\label{classorg_1_1opencv_1_1core_1_1_mat}\index{org.\+opencv.\+core.\+Mat@{org.\+opencv.\+core.\+Mat}}
Inheritance diagram for org.\+opencv.\+core.\+Mat\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=12.000000cm]{classorg_1_1opencv_1_1core_1_1_mat}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad81cccc01050e0cbc98d40488bd287c4}{Mat}} (long addr)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa03d10c0ff4945578646472c11ab3811}{Mat}} ()
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ac10e0831f257b5f95040cf2855b11954}{Mat}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a1e925483fbe84a9dab2499cf91c17c84}{rows}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_adddf469e35679e67bb350f779433ea8d}{cols}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}})
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ae4db7e1be7f9a6cf796243e607e1d643}{Mat}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a543d6f8a103a5f3d899030d76286f0cf}{size}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}})
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ade8a0d19976457d86412752212d1dbdb}{Mat}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a1e925483fbe84a9dab2499cf91c17c84}{rows}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_adddf469e35679e67bb350f779433ea8d}{cols}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} s)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa0a4a8f9e7d9abaaa13d250efcf12527}{Mat}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a543d6f8a103a5f3d899030d76286f0cf}{size}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} s)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a43433858be0fb9f5f5453d3723c430ab}{Mat}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a182dbb37bbaa19e65cfcb99cf4d03fbe}{row\+Range}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a28a58bdd7241151451c966e41da7e38b}{col\+Range}})
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ac327cd85a7a77b074525dda13723da60}{Mat}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a182dbb37bbaa19e65cfcb99cf4d03fbe}{row\+Range}})
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa6ed352a1abaac27fc5f4f8f467269ea}{Mat}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} roi)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a76da70f4d8bbf780fc2a351bdffc06ed}{adjust\+R\+OI}} (int dtop, int dbottom, int dleft, int dright)
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a0b4dea332af31a9102b75892f66d0395}{assign\+To}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}})
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_af363e731446cb340ff5e28e5ac8d5d6f}{assign\+To}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ababb77842613942b86dad34ec909eacf}{channels}} ()
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ab323ee864f290b7ddbd804a6fbe76ae0}{check\+Vector}} (int elem\+Channels, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a9bf4679d10841047167676cde239a5b9}{depth}}, boolean require\+Continuous)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ae1237684f5ce865f9f74f2de48f73c60}{check\+Vector}} (int elem\+Channels, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a9bf4679d10841047167676cde239a5b9}{depth}})
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a336960f25d39af05618890ee00b7e28e}{check\+Vector}} (int elem\+Channels)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a7e40ecb438d2ec75e24e209b7bee0be2}{clone}} ()
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}} (int x)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a28a58bdd7241151451c966e41da7e38b}{col\+Range}} (int startcol, int endcol)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a2be44d10bfd5d8fa88d022b3b4dc773e}{col\+Range}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}} r)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a9da03786400df5d6ef7ff4217f9a93f9}{dims}} ()
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_adddf469e35679e67bb350f779433ea8d}{cols}} ()
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}{convert\+To}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m, int rtype, double alpha, double beta)
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a0b77b1b98daf56bf32d799e2fc597037}{convert\+To}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m, int rtype, double alpha)
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_acdff78cc87bef2565f8907113d0eec11}{convert\+To}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m, int rtype)
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa2d63f03533282ef5bd1f8dc0cbcbc0b}{copy\+To}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m)
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ae1a7d7ed81f82bda92cb641c6060f2be}{copy\+To}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a539b0a3690afb6b43047b50cbb787fee}{create}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a1e925483fbe84a9dab2499cf91c17c84}{rows}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_adddf469e35679e67bb350f779433ea8d}{cols}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}})
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_afd55f958255662f40a0bbe03813cb8b2}{create}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a543d6f8a103a5f3d899030d76286f0cf}{size}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}})
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a830b2d8626fe668db82180adf69e6145}{cross}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m)
\item 
long \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a3b5dcff6ae75137a18cd781454b1129a}{data\+Addr}} ()
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a9bf4679d10841047167676cde239a5b9}{depth}} ()
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa28ea6e2ec65861e30319e443dbde298}{diag}} (int d)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a46c17fd51fa6344e2081006c1a98b4d8}{diag}} ()
\item 
double \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a053eb46b103c30891659945a6434c5db}{dot}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m)
\item 
long \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aefa109235b149088d48188cb54b891e9}{elem\+Size}} ()
\item 
long \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ae174b003b4f0e87a3a1dbf805962b145}{elem\+Size1}} ()
\item 
boolean \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a873fa8cc0d87ffae2b9c9ed94d79ddec}{empty}} ()
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ae2903c2da88b961ac9a77352577ed655}{inv}} (int method)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a3ae81a587a404aa8b3751af8c0763515}{inv}} ()
\item 
boolean \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a0aaf7d8f437a0dbd73d9f9d1534404f1}{is\+Continuous}} ()
\item 
boolean \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a5a8e2cf2e6d2951ba8c939a4c351793a}{is\+Submatrix}} ()
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a51784a0e99c00a52e8be330cf05710f8}{locate\+R\+OI}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} whole\+Size, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} ofs)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a43e95787eea4de307230ceeb14bba8f6}{mul}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m, double scale)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_afa27812124a1a17a0b4c003637b7a27b}{mul}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m)
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a137ee1d0feab4d3db45755e2b6d46c91}{push\+\_\+back}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} m)
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_afb0f872783792b1ba415c2dfcf088a14}{release}} ()
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ac272e7518dba0da8e7480df63163040b}{reshape}} (int cn, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a1e925483fbe84a9dab2499cf91c17c84}{rows}})
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a544b911ef4cf5e755658a1f8dd5f0b7d}{reshape}} (int cn)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}} (int y)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a182dbb37bbaa19e65cfcb99cf4d03fbe}{row\+Range}} (int startrow, int endrow)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a05a7c23da0150252d907e58489808b51}{row\+Range}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}} r)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a1e925483fbe84a9dab2499cf91c17c84}{rows}} ()
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a9316a305061d8ef51b7e7355d5e7440d}{set\+To}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} s)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a56d903b85bbe289ee484e1b22efa2a91}{set\+To}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}} value, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a793ccddcd93d47402e9b243ef75814b1}{set\+To}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} value, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mask)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a3c0458f17815dd73f81e4a8dfebacb3b}{set\+To}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} value)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a543d6f8a103a5f3d899030d76286f0cf}{size}} ()
\item 
long \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a758053ee22fe72074db5934097477cfe}{step1}} (int i)
\item 
long \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a657e61de4cb505cb637e8e88b12ac479}{step1}} ()
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a3d3b68f34a2c1c3aaa56b1c75f09ae60}{submat}} (int row\+Start, int row\+End, int col\+Start, int col\+End)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a4a17b77ce9a3b6b497912153906c2d37}{submat}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a182dbb37bbaa19e65cfcb99cf4d03fbe}{row\+Range}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a28a58bdd7241151451c966e41da7e38b}{col\+Range}})
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a37b5962d59cd8a91a081e232e07979f9}{submat}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}} roi)
\item 
\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a8df776cc748a0006e8837fcb7a1772f0}{t}} ()
\item 
long \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a0aa57e546fe72e994dafe806f47f0081}{total}} ()
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}} ()
\item 
String \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a2652b30a9904641accc3bef6f071db2c}{to\+String}} ()
\item 
String \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a525efae06b8fcd10a0bb10e7c5a13212}{dump}} ()
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a033211373530fc2ac99d291e405fa6f6}{put}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}}, double... data)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a041ac4ce88732c782e2be29306105968}{put}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}}, float\mbox{[}$\,$\mbox{]} data)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a5401cd68e743255a389b32aa94db5d1c}{put}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}}, int\mbox{[}$\,$\mbox{]} data)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a4d1c54091897d06ce22114cc74299796}{put}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}}, short\mbox{[}$\,$\mbox{]} data)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a4d0c8b7bef73cdbe148d51a2a3ed5e05}{put}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}}, byte\mbox{[}$\,$\mbox{]} data)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a5770a138198285c9cc0a9545bda1b0ac}{get}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}}, byte\mbox{[}$\,$\mbox{]} data)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aa1a035119cc01d317423b60eac0012c7}{get}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}}, short\mbox{[}$\,$\mbox{]} data)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a2da432d61617c9a7f4c4ed6885ba3563}{get}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}}, int\mbox{[}$\,$\mbox{]} data)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aae0f9f38d8b37170e451cb223b5bae02}{get}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}}, float\mbox{[}$\,$\mbox{]} data)
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a7878222dfb1c0b8ed9311928d2a483c2}{get}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}}, double\mbox{[}$\,$\mbox{]} data)
\item 
double \mbox{[}$\,$\mbox{]} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a1c38398b5cd4cf9adaf6c2bac63f7d0a}{get}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}{row}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}{col}})
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a6cf76dab73965b27be55ecf781db4721}{height}} ()
\item 
int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a865879f055007ff347401280a4fd9b73}{width}} ()
\item 
long \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a6c5d603d138873bb994a328ddef257da}{get\+Native\+Obj\+Addr}} ()
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a4accc142f642a4f5fc468bea14fc42f1}{diag}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} d)
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a4de6ffd10feb724153f1ec1231533aa9}{eye}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a1e925483fbe84a9dab2499cf91c17c84}{rows}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_adddf469e35679e67bb350f779433ea8d}{cols}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}})
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a3b7002cc04ec4871e280922a6de3e78a}{eye}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a543d6f8a103a5f3d899030d76286f0cf}{size}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}})
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a34d703df023730d043298601b6962f57}{ones}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a1e925483fbe84a9dab2499cf91c17c84}{rows}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_adddf469e35679e67bb350f779433ea8d}{cols}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}})
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a2a4ac31b342315b5849762dba8a2d79d}{ones}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a543d6f8a103a5f3d899030d76286f0cf}{size}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}})
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aff41070138369b96f792b19f01ab00d9}{zeros}} (int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a1e925483fbe84a9dab2499cf91c17c84}{rows}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_adddf469e35679e67bb350f779433ea8d}{cols}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}})
\item 
static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_ae346269a0f9ee375ffe987e8d8031014}{zeros}} (\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a543d6f8a103a5f3d899030d76286f0cf}{size}}, int \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type}})
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
final long \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a497713e25ec636f1185e08d7692d065b}{native\+Obj}}
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aca52fe6f5554bfbff11c44e07952ba2d}{finalize}} ()  throws Throwable 
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Open\+CV C++ n-\/dimensional dense array class

class C\+V\+\_\+\+E\+X\+P\+O\+R\+TS \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily public\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily //... a lot of methods......}

{\ttfamily }

{\ttfamily }

{\ttfamily / $\ast$! includes several bit-\/fields\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily -\/ the magic signature}

{\ttfamily }

{\ttfamily }

{\ttfamily -\/ continuity flag}

{\ttfamily }

{\ttfamily }

{\ttfamily -\/ depth}

{\ttfamily }

{\ttfamily }

{\ttfamily -\/ number of channels}

{\ttfamily  
\begin{DoxyItemize}
\item / 
\end{DoxyItemize}}

{\ttfamily }

{\ttfamily int flags;}

{\ttfamily }

{\ttfamily }

{\ttfamily //! the array dimensionality, $>$= 2}

{\ttfamily }

{\ttfamily }

{\ttfamily int dims;}

{\ttfamily }

{\ttfamily }

{\ttfamily //! the number of rows and columns or (-\/1, -\/1) when the array has more than 2 dimensions}

{\ttfamily }

{\ttfamily }

{\ttfamily int rows, cols;}

{\ttfamily }

{\ttfamily }

{\ttfamily //! pointer to the data}

{\ttfamily }

{\ttfamily }

{\ttfamily uchar$\ast$ data;}

{\ttfamily }

{\ttfamily }

{\ttfamily //! pointer to the reference counter;}

{\ttfamily }

{\ttfamily }

{\ttfamily // when array points to user-\/allocated data, the pointer is N\+U\+LL}

{\ttfamily }

{\ttfamily }

{\ttfamily int$\ast$ refcount;}

{\ttfamily }

{\ttfamily }

{\ttfamily // other members...}

{\ttfamily }

{\ttfamily }

{\ttfamily \};}

{\ttfamily }

{\ttfamily }

{\ttfamily The class {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}} represents an n-\/dimensional dense numerical single-\/channel or multi-\/channel array. It can be used to store real or complex-\/valued vectors and matrices, grayscale or color images, voxel volumes, vector fields, point clouds, tensors, histograms (though, very high-\/dimensional histograms may be better stored in a {\ttfamily Sparse\+Mat}). The data layout of the array }

{\itshape M} is defined by the array {\ttfamily M.\+step\mbox{[}\mbox{]}}, so that the address of element {\itshape (i\+\_\+0,...,i\+\_\+(M.\+dims-\/1))}, where {\itshape 0 $<$= i\+\_\+k\&lt\+M.\+size\mbox{[}k\mbox{]}}, is computed as\+:

{\itshape addr(M\+\_\+(i\+\_\+0,...,i\+\_\+(M.\+dims-\/1))) = M.\+data + M.\+step\mbox{[}0\mbox{]}$\ast$i\+\_\+0 + M.\+step\mbox{[}1\mbox{]}$\ast$i\+\_\+1 +... + M.\+step\mbox{[}M.\+dims-\/1\mbox{]}$\ast$i\+\_\+(M.\+dims-\/1)}

In case of a 2-\/dimensional array, the above formula is reduced to\+:

{\itshape addr(\+M\+\_\+(i,j)) = M.\+data + M.\+step\mbox{[}0\mbox{]}$\ast$i + M.\+step\mbox{[}1\mbox{]}$\ast$j}

Note that {\ttfamily M.\+step\mbox{[}i\mbox{]} $>$= M.\+step\mbox{[}i+1\mbox{]}} (in fact, {\ttfamily M.\+step\mbox{[}i\mbox{]} $>$= M.\+step\mbox{[}i+1\mbox{]}$\ast$M.size\mbox{[}i+1\mbox{]}}). This means that 2-\/dimensional matrices are stored row-\/by-\/row, 3-\/dimensional matrices are stored plane-\/by-\/plane, and so on. {\ttfamily M.\+step\mbox{[}M.\+dims-\/1\mbox{]}} is minimal and always equal to the element size {\ttfamily M.\+elem\+Size()}.

So, the data layout in {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}} is fully compatible with {\ttfamily Cv\+Mat}, {\ttfamily Ipl\+Image}, and {\ttfamily Cv\+Mat\+ND} types from Open\+CV 1.\+x. It is also compatible with the majority of dense array types from the standard toolkits and S\+D\+Ks, such as Numpy (ndarray), Win32 (independent device bitmaps), and others, that is, with any array that uses {\itshape steps} (or {\itshape strides}) to compute the position of a pixel. Due to this compatibility, it is possible to make a {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}} header for user-\/allocated data and process it in-\/place using Open\+CV functions.

There are many different ways to create a {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}} object. The most popular options are listed below\+:


\begin{DoxyItemize}
\item Use the {\ttfamily create(nrows, ncols, type)} method or the similar {\ttfamily Mat(nrows, ncols, type\mbox{[}, fill\+Value\mbox{]})} constructor. A new array of the specified size and type is allocated. {\ttfamily type} has the same meaning as in the {\ttfamily cv\+Create\+Mat} method. 
\end{DoxyItemize}

For example, {\ttfamily C\+V\+\_\+8\+U\+C1} means a 8-\/bit single-\/channel array, {\ttfamily C\+V\+\_\+32\+F\+C2} means a 2-\/channel (complex) floating-\/point array, and so on.

{\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // make a 7x7 complex matrix filled with 1+3j.}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} M(7,7,\+C\+V\+\_\+32\+F\+C2,\+Scalar(1,3));}

{\ttfamily }

{\ttfamily }

{\ttfamily // and now turn M to a 100x60 15-\/channel 8-\/bit matrix.}

{\ttfamily }

{\ttfamily }

{\ttfamily // The old content will be deallocated}

{\ttfamily }

{\ttfamily }

{\ttfamily M.\+create(100,60,\+C\+V\+\_\+8\+U\+C(15));}

{\ttfamily }

{\ttfamily }

{\ttfamily }

As noted in the introduction to this chapter, {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a539b0a3690afb6b43047b50cbb787fee}{create()}}} allocates only a new array when the shape or type of the current array are different from the specified ones.


\begin{DoxyItemize}
\item Create a multi-\/dimensional array\+: 
\end{DoxyItemize}

{\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // create a 100x100x100 8-\/bit array}

{\ttfamily }

{\ttfamily }

{\ttfamily int sz\mbox{[}\mbox{]} = \{100, 100, 100\};}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} big\+Cube(3, sz, C\+V\+\_\+8U, Scalar.\+all(0));}

{\ttfamily }

{\ttfamily }

{\ttfamily }

It passes the number of dimensions =1 to the {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}} constructor but the created array will be 2-\/dimensional with the number of columns set to 1. So, {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a9da03786400df5d6ef7ff4217f9a93f9}{Mat.\+dims}}} is always $>$= 2 (can also be 0 when the array is empty).


\begin{DoxyItemize}
\item Use a copy constructor or assignment operator where there can be an array or expression on the right side (see below). As noted in the introduction, the array assignment is an O(1) operation because it only copies the header and increases the reference counter. The {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a7e40ecb438d2ec75e24e209b7bee0be2}{Mat.\+clone()}}} method can be used to get a full (deep) copy of the array when you need it. 
\item Construct a header for a part of another array. It can be a single row, single column, several rows, several columns, rectangular region in the array (called a {\itshape minor} in algebra) or a diagonal. Such operations are also O(1) because the new header references the same data. You can actually modify a part of the array using this feature, for example\+: 
\end{DoxyItemize}

{\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // add the 5-\/th row, multiplied by 3 to the 3rd row}

{\ttfamily }

{\ttfamily }

{\ttfamily M.\+row(3) = M.\+row(3) + M.\+row(5)$\ast$3;}

{\ttfamily }

{\ttfamily }

{\ttfamily // now copy the 7-\/th column to the 1-\/st column}

{\ttfamily }

{\ttfamily }

{\ttfamily // M.\+col(1) = M.\+col(7); // this will not work}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} M1 = M.\+col(1);}

{\ttfamily }

{\ttfamily }

{\ttfamily M.\+col(7).copy\+To(\+M1);}

{\ttfamily }

{\ttfamily }

{\ttfamily // create a new 320x240 image}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img(\+Size(320,240),\+C\+V\+\_\+8\+U\+C3);}

{\ttfamily }

{\ttfamily }

{\ttfamily // select a R\+OI}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} roi(img, Rect(10,10,100,100));}

{\ttfamily }

{\ttfamily }

{\ttfamily // fill the R\+OI with (0,255,0) (which is green in R\+GB space);}

{\ttfamily }

{\ttfamily }

{\ttfamily // the original 320x240 image will be modified}

{\ttfamily }

{\ttfamily }

{\ttfamily roi = Scalar(0,255,0);}

{\ttfamily }

{\ttfamily }

{\ttfamily }

Due to the additional {\ttfamily datastart} and {\ttfamily dataend} members, it is possible to compute a relative sub-\/array position in the main {\itshape container} array using {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a51784a0e99c00a52e8be330cf05710f8}{locate\+R\+O\+I()}}}\+:

{\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A = Mat.\+eye(10, 10, C\+V\+\_\+32\+S);}

{\ttfamily }

{\ttfamily }

{\ttfamily // extracts A columns, 1 (inclusive) to 3 (exclusive).}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} B = A(\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range_a2dd4a07a9715665aacee5c7cdf79a175}{Range.\+all()}}, Range(1, 3));}

{\ttfamily }

{\ttfamily }

{\ttfamily // extracts B rows, 5 (inclusive) to 9 (exclusive).}

{\ttfamily }

{\ttfamily }

{\ttfamily // that is, C $\sim$ A(Range(5, 9), Range(1, 3))}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} C = B(Range(5, 9), \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range_a2dd4a07a9715665aacee5c7cdf79a175}{Range.\+all()}});}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} size; \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}} ofs;}

{\ttfamily }

{\ttfamily }

{\ttfamily C.\+locate\+R\+O\+I(size, ofs);}

{\ttfamily }

{\ttfamily }

{\ttfamily // size will be (width=10,height=10) and the ofs will be (x=1, y=5)}

{\ttfamily }

{\ttfamily }

{\ttfamily }

As in case of whole matrices, if you need a deep copy, use the {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a7e40ecb438d2ec75e24e209b7bee0be2}{clone()}}} method of the extracted sub-\/matrices.


\begin{DoxyItemize}
\item Make a header for user-\/allocated data. It can be useful to do the following\+: 
\item Process \char`\"{}foreign\char`\"{} data using Open\+CV (for example, when you implement a Direct\+Show$\ast$ filter or a processing module for {\ttfamily gstreamer}, and so on). For example\+: 
\end{DoxyItemize}

{\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily void process\+\_\+video\+\_\+frame(const unsigned char$\ast$ pixels,}

{\ttfamily }

{\ttfamily }

{\ttfamily int width, int height, int step)}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} img(height, width, C\+V\+\_\+8\+U\+C3, pixels, step);}

{\ttfamily }

{\ttfamily }

{\ttfamily Gaussian\+Blur(img, img, Size(7,7), 1.\+5, 1.\+5);}

{\ttfamily }

{\ttfamily }

{\ttfamily }


\begin{DoxyItemize}
\item Quickly initialize small matrices and/or get a super-\/fast element access. 
\end{DoxyItemize}

{\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily double m\mbox{[}3\mbox{]}\mbox{[}3\mbox{]} = \{\{a, b, c\}, \{d, e, f\}, \{g, h, i\}\};}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} M = Mat(3, 3, C\+V\+\_\+64\+F, m).\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a3ae81a587a404aa8b3751af8c0763515}{inv()}};}

{\ttfamily }

{\ttfamily }

{\ttfamily }

Partial yet very common cases of this {\itshape user-\/allocated data} case are conversions from {\ttfamily Cv\+Mat} and {\ttfamily Ipl\+Image} to {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}. For this purpose, there are special constructors taking pointers to {\ttfamily Cv\+Mat} or {\ttfamily Ipl\+Image} and the optional flag indicating whether to copy the data or not.

Backward conversion from {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}} to {\ttfamily Cv\+Mat} or {\ttfamily Ipl\+Image} is provided via cast operators {\ttfamily Mat.\+operator Cv\+Mat() const} and {\ttfamily Mat.\+operator Ipl\+Image()}. The operators do N\+OT copy the data.

{\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily Ipl\+Image$\ast$ img = cv\+Load\+Image(\char`\"{}greatwave.\+jpg\char`\"{}, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} mtx(img); // convert Ipl\+Image$\ast$ -\/$>$ \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}

{\ttfamily }

{\ttfamily }

{\ttfamily Cv\+Mat oldmat = mtx; // convert \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} -\/$>$ Cv\+Mat}

{\ttfamily }

{\ttfamily }

{\ttfamily C\+V\+\_\+\+Assert(oldmat.\+cols == img-\/$>$width \&\& oldmat.\+rows == img-\/$>$height \&\&}

{\ttfamily }

{\ttfamily }

{\ttfamily oldmat.\+data.\+ptr == (uchar$\ast$)img-\/$>$image\+Data \&\& oldmat.\+step == img-\/$>$width\+Step);}

{\ttfamily }

{\ttfamily }

{\ttfamily }


\begin{DoxyItemize}
\item Use M\+A\+T\+L\+A\+B-\/style array initializers, {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aff41070138369b96f792b19f01ab00d9}{zeros()}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a34d703df023730d043298601b6962f57}{ones()}}, \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a4de6ffd10feb724153f1ec1231533aa9}{eye()}}}, for example\+: 
\end{DoxyItemize}

{\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // create a double-\/precision identity martix and add it to M.}

{\ttfamily }

{\ttfamily }

{\ttfamily M += \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a4de6ffd10feb724153f1ec1231533aa9}{Mat.\+eye}}(M.\+rows, M.\+cols, C\+V\+\_\+64F);}

{\ttfamily }

{\ttfamily }

{\ttfamily }


\begin{DoxyItemize}
\item Use a comma-\/separated initializer\+: 
\end{DoxyItemize}

{\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // create a 3x3 double-\/precision identity matrix}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} M = (Mat\+\_\+$<$double$>$(3,3) $<$$<$ 1, 0, 0, 0, 1, 0, 0, 0, 1);}

{\ttfamily }

{\ttfamily }

{\ttfamily }

With this approach, you first call a constructor of the \char`\"{}\+Mat\+\_\+\char`\"{} class with the proper parameters, and then you just put {\ttfamily $<$$<$} operator followed by comma-\/separated values that can be constants, variables, expressions, and so on. Also, note the extra parentheses required to avoid compilation errors.

Once the array is created, it is automatically managed via a reference-\/counting mechanism. If the array header is built on top of user-\/allocated data, you should handle the data by yourself. The array data is deallocated when no one points to it. If you want to release the data pointed by a array header before the array destructor is called, use {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_afb0f872783792b1ba415c2dfcf088a14}{Mat.\+release()}}}.

The next important thing to learn about the array class is element access. This manual already described how to compute an address of each array element. Normally, you are not required to use the formula directly in the code. If you know the array element type (which can be retrieved using the method {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{Mat.\+type()}}}), you can access the element{\itshape M\+\_\+(ij)} of a 2-\/dimensional array as\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily M.\+at$<$double$>$(i,j) += 1.\+f;}

{\ttfamily }

{\ttfamily }

{\ttfamily assuming that M is a double-\/precision floating-\/point array. There are several variants of the method {\ttfamily at} for a different number of dimensions. }

If you need to process a whole row of a 2D array, the most efficient way is to get the pointer to the row first, and then just use the plain C operator {\ttfamily \mbox{[}\mbox{]}} \+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // compute sum of positive matrix elements}

{\ttfamily }

{\ttfamily }

{\ttfamily // (assuming that M isa double-\/precision matrix)}

{\ttfamily }

{\ttfamily }

{\ttfamily double sum=0;}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int i = 0; i $<$ M.\+rows; i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily const double$\ast$ Mi = M.\+ptr$<$double$>$(i);}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int j = 0; j $<$ M.\+cols; j++)}

{\ttfamily }

{\ttfamily }

{\ttfamily sum += std.\+max(Mi\mbox{[}j\mbox{]}, 0.);}

{\ttfamily }

{\ttfamily }

{\ttfamily Some operations, like the one above, do not actually depend on the array shape. They just process elements of an array one by one (or elements from multiple arrays that have the same coordinates, for example, array addition). Such operations are called {\itshape element-\/wise}. It makes sense to check whether all the input/output arrays are continuous, namely, have no gaps at the end of each row. If yes, process them as a long single row\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // compute the sum of positive matrix elements, optimized variant}

{\ttfamily }

{\ttfamily }

{\ttfamily double sum=0;}

{\ttfamily }

{\ttfamily }

{\ttfamily int cols = M.\+cols, rows = M.\+rows;}

{\ttfamily }

{\ttfamily }

{\ttfamily if(M.\+is\+Continuous())}

{\ttfamily }

{\ttfamily }

{\ttfamily cols $\ast$= rows;}

{\ttfamily }

{\ttfamily }

{\ttfamily rows = 1;}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int i = 0; i $<$ rows; i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily const double$\ast$ Mi = M.\+ptr$<$double$>$(i);}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int j = 0; j $<$ cols; j++)}

{\ttfamily }

{\ttfamily }

{\ttfamily sum += std.\+max(Mi\mbox{[}j\mbox{]}, 0.);}

{\ttfamily }

{\ttfamily }

{\ttfamily In case of the continuous matrix, the outer loop body is executed just once. So, the overhead is smaller, which is especially noticeable in case of small matrices. }

Finally, there are S\+T\+L-\/style iterators that are smart enough to skip gaps between successive rows\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // compute sum of positive matrix elements, iterator-\/based variant}

{\ttfamily }

{\ttfamily }

{\ttfamily double sum=0;}

{\ttfamily }

{\ttfamily }

{\ttfamily Mat\+Const\+Iterator\+\_\+$<$double$>$ it = M.\+begin$<$double$>$(), it\+\_\+end = M.\+end$<$double$>$();}

{\ttfamily }

{\ttfamily }

{\ttfamily for(; it != it\+\_\+end; ++it)}

{\ttfamily }

{\ttfamily }

{\ttfamily sum += std.\+max($\ast$it, 0.);}

{\ttfamily }

{\ttfamily }

{\ttfamily The matrix iterators are random-\/access iterators, so they can be passed to any S\+TL algorithm, including {\ttfamily std.\+sort()}. }

Note\+:


\begin{DoxyItemize}
\item An example demonstrating the serial out capabilities of cv.\+Mat can be found at opencv\+\_\+source\+\_\+code/samples/cpp/cout\+\_\+mat.\+cpp 
\end{DoxyItemize}

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat}{\tt org.\+opencv.\+core.\+Mat} 
\end{DoxySeeAlso}


\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ad81cccc01050e0cbc98d40488bd287c4}\label{classorg_1_1opencv_1_1core_1_1_mat_ad81cccc01050e0cbc98d40488bd287c4}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!Mat@{Mat}}
\index{Mat@{Mat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{Mat()}{Mat()}\hspace{0.1cm}{\footnotesize\ttfamily [1/9]}}
{\footnotesize\ttfamily org.\+opencv.\+core.\+Mat.\+Mat (\begin{DoxyParamCaption}\item[{long}]{addr }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_aa03d10c0ff4945578646472c11ab3811}\label{classorg_1_1opencv_1_1core_1_1_mat_aa03d10c0ff4945578646472c11ab3811}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!Mat@{Mat}}
\index{Mat@{Mat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{Mat()}{Mat()}\hspace{0.1cm}{\footnotesize\ttfamily [2/9]}}
{\footnotesize\ttfamily org.\+opencv.\+core.\+Mat.\+Mat (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Various \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} constructors

These are various constructors that form a matrix. As noted in the \char`\"{}\+Automatic\+Allocation\char`\"{}, often the default constructor is enough, and the proper matrix will be allocated by an Open\+CV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with \char`\"{}\+Mat.\+create\char`\"{}. In the former case, the old content is de-\/referenced.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat}{\tt org.\+opencv.\+core.\+Mat.\+Mat} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ac10e0831f257b5f95040cf2855b11954}\label{classorg_1_1opencv_1_1core_1_1_mat_ac10e0831f257b5f95040cf2855b11954}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!Mat@{Mat}}
\index{Mat@{Mat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{Mat()}{Mat()}\hspace{0.1cm}{\footnotesize\ttfamily [3/9]}}
{\footnotesize\ttfamily org.\+opencv.\+core.\+Mat.\+Mat (\begin{DoxyParamCaption}\item[{int}]{rows,  }\item[{int}]{cols,  }\item[{int}]{type }\end{DoxyParamCaption})}

Various \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} constructors

These are various constructors that form a matrix. As noted in the \char`\"{}\+Automatic\+Allocation\char`\"{}, often the default constructor is enough, and the proper matrix will be allocated by an Open\+CV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with \char`\"{}\+Mat.\+create\char`\"{}. In the former case, the old content is de-\/referenced.


\begin{DoxyParams}{Parameters}
{\em rows} & Number of rows in a 2D array. \\
\hline
{\em cols} & Number of columns in a 2D array. \\
\hline
{\em type} & Array type. Use {\ttfamily C\+V\+\_\+8\+U\+C1,..., C\+V\+\_\+64\+F\+C4} to create 1-\/4 channel matrices, or {\ttfamily C\+V\+\_\+8\+U\+C(n),..., C\+V\+\_\+64\+F\+C(n)} to create multi-\/channel (up to {\ttfamily C\+V\+\_\+\+C\+N\+\_\+\+M\+AX} channels) matrices.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat}{\tt org.\+opencv.\+core.\+Mat.\+Mat} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ae4db7e1be7f9a6cf796243e607e1d643}\label{classorg_1_1opencv_1_1core_1_1_mat_ae4db7e1be7f9a6cf796243e607e1d643}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!Mat@{Mat}}
\index{Mat@{Mat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{Mat()}{Mat()}\hspace{0.1cm}{\footnotesize\ttfamily [4/9]}}
{\footnotesize\ttfamily org.\+opencv.\+core.\+Mat.\+Mat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{size,  }\item[{int}]{type }\end{DoxyParamCaption})}

Various \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} constructors

These are various constructors that form a matrix. As noted in the \char`\"{}\+Automatic\+Allocation\char`\"{}, often the default constructor is enough, and the proper matrix will be allocated by an Open\+CV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with \char`\"{}\+Mat.\+create\char`\"{}. In the former case, the old content is de-\/referenced.


\begin{DoxyParams}{Parameters}
{\em size} & 2D array size\+: {\ttfamily Size(cols, rows)}. In the {\ttfamily Size()} constructor, the number of rows and the number of columns go in the reverse order. \\
\hline
{\em type} & Array type. Use {\ttfamily C\+V\+\_\+8\+U\+C1,..., C\+V\+\_\+64\+F\+C4} to create 1-\/4 channel matrices, or {\ttfamily C\+V\+\_\+8\+U\+C(n),..., C\+V\+\_\+64\+F\+C(n)} to create multi-\/channel (up to {\ttfamily C\+V\+\_\+\+C\+N\+\_\+\+M\+AX} channels) matrices.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat}{\tt org.\+opencv.\+core.\+Mat.\+Mat} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ade8a0d19976457d86412752212d1dbdb}\label{classorg_1_1opencv_1_1core_1_1_mat_ade8a0d19976457d86412752212d1dbdb}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!Mat@{Mat}}
\index{Mat@{Mat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{Mat()}{Mat()}\hspace{0.1cm}{\footnotesize\ttfamily [5/9]}}
{\footnotesize\ttfamily org.\+opencv.\+core.\+Mat.\+Mat (\begin{DoxyParamCaption}\item[{int}]{rows,  }\item[{int}]{cols,  }\item[{int}]{type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{s }\end{DoxyParamCaption})}

Various \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} constructors

These are various constructors that form a matrix. As noted in the \char`\"{}\+Automatic\+Allocation\char`\"{}, often the default constructor is enough, and the proper matrix will be allocated by an Open\+CV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with \char`\"{}\+Mat.\+create\char`\"{}. In the former case, the old content is de-\/referenced.


\begin{DoxyParams}{Parameters}
{\em rows} & Number of rows in a 2D array. \\
\hline
{\em cols} & Number of columns in a 2D array. \\
\hline
{\em type} & Array type. Use {\ttfamily C\+V\+\_\+8\+U\+C1,..., C\+V\+\_\+64\+F\+C4} to create 1-\/4 channel matrices, or {\ttfamily C\+V\+\_\+8\+U\+C(n),..., C\+V\+\_\+64\+F\+C(n)} to create multi-\/channel (up to {\ttfamily C\+V\+\_\+\+C\+N\+\_\+\+M\+AX} channels) matrices. \\
\hline
{\em s} & An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator {\ttfamily Mat.\+operator=(const Scalar\& value)}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat}{\tt org.\+opencv.\+core.\+Mat.\+Mat} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_aa0a4a8f9e7d9abaaa13d250efcf12527}\label{classorg_1_1opencv_1_1core_1_1_mat_aa0a4a8f9e7d9abaaa13d250efcf12527}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!Mat@{Mat}}
\index{Mat@{Mat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{Mat()}{Mat()}\hspace{0.1cm}{\footnotesize\ttfamily [6/9]}}
{\footnotesize\ttfamily org.\+opencv.\+core.\+Mat.\+Mat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{size,  }\item[{int}]{type,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{s }\end{DoxyParamCaption})}

Various \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} constructors

These are various constructors that form a matrix. As noted in the \char`\"{}\+Automatic\+Allocation\char`\"{}, often the default constructor is enough, and the proper matrix will be allocated by an Open\+CV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with \char`\"{}\+Mat.\+create\char`\"{}. In the former case, the old content is de-\/referenced.


\begin{DoxyParams}{Parameters}
{\em size} & 2D array size\+: {\ttfamily Size(cols, rows)}. In the {\ttfamily Size()} constructor, the number of rows and the number of columns go in the reverse order. \\
\hline
{\em type} & Array type. Use {\ttfamily C\+V\+\_\+8\+U\+C1,..., C\+V\+\_\+64\+F\+C4} to create 1-\/4 channel matrices, or {\ttfamily C\+V\+\_\+8\+U\+C(n),..., C\+V\+\_\+64\+F\+C(n)} to create multi-\/channel (up to {\ttfamily C\+V\+\_\+\+C\+N\+\_\+\+M\+AX} channels) matrices. \\
\hline
{\em s} & An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator {\ttfamily Mat.\+operator=(const Scalar\& value)}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat}{\tt org.\+opencv.\+core.\+Mat.\+Mat} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a43433858be0fb9f5f5453d3723c430ab}\label{classorg_1_1opencv_1_1core_1_1_mat_a43433858be0fb9f5f5453d3723c430ab}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!Mat@{Mat}}
\index{Mat@{Mat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{Mat()}{Mat()}\hspace{0.1cm}{\footnotesize\ttfamily [7/9]}}
{\footnotesize\ttfamily org.\+opencv.\+core.\+Mat.\+Mat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}}}]{row\+Range,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}}}]{col\+Range }\end{DoxyParamCaption})}

Various \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} constructors

These are various constructors that form a matrix. As noted in the \char`\"{}\+Automatic\+Allocation\char`\"{}, often the default constructor is enough, and the proper matrix will be allocated by an Open\+CV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with \char`\"{}\+Mat.\+create\char`\"{}. In the former case, the old content is de-\/referenced.


\begin{DoxyParams}{Parameters}
{\em m} & Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors. Instead, the header pointing to {\ttfamily m} data or its sub-\/array is constructed and associated with it. The reference counter, if any, is incremented. So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of {\ttfamily m}. If you want to have an independent copy of the sub-\/array, use {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a7e40ecb438d2ec75e24e209b7bee0be2}{Mat.\+clone()}}}. \\
\hline
{\em row\+Range} & \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}} of the {\ttfamily m} rows to take. As usual, the range start is inclusive and the range end is exclusive. Use {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range_a2dd4a07a9715665aacee5c7cdf79a175}{Range.\+all()}}} to take all the rows. \\
\hline
{\em col\+Range} & \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}} of the {\ttfamily m} columns to take. Use {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range_a2dd4a07a9715665aacee5c7cdf79a175}{Range.\+all()}}} to take all the columns.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat}{\tt org.\+opencv.\+core.\+Mat.\+Mat} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ac327cd85a7a77b074525dda13723da60}\label{classorg_1_1opencv_1_1core_1_1_mat_ac327cd85a7a77b074525dda13723da60}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!Mat@{Mat}}
\index{Mat@{Mat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{Mat()}{Mat()}\hspace{0.1cm}{\footnotesize\ttfamily [8/9]}}
{\footnotesize\ttfamily org.\+opencv.\+core.\+Mat.\+Mat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}}}]{row\+Range }\end{DoxyParamCaption})}

Various \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} constructors

These are various constructors that form a matrix. As noted in the \char`\"{}\+Automatic\+Allocation\char`\"{}, often the default constructor is enough, and the proper matrix will be allocated by an Open\+CV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with \char`\"{}\+Mat.\+create\char`\"{}. In the former case, the old content is de-\/referenced.


\begin{DoxyParams}{Parameters}
{\em m} & Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors. Instead, the header pointing to {\ttfamily m} data or its sub-\/array is constructed and associated with it. The reference counter, if any, is incremented. So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of {\ttfamily m}. If you want to have an independent copy of the sub-\/array, use {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a7e40ecb438d2ec75e24e209b7bee0be2}{Mat.\+clone()}}}. \\
\hline
{\em row\+Range} & \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}} of the {\ttfamily m} rows to take. As usual, the range start is inclusive and the range end is exclusive. Use {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range_a2dd4a07a9715665aacee5c7cdf79a175}{Range.\+all()}}} to take all the rows.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat}{\tt org.\+opencv.\+core.\+Mat.\+Mat} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_aa6ed352a1abaac27fc5f4f8f467269ea}\label{classorg_1_1opencv_1_1core_1_1_mat_aa6ed352a1abaac27fc5f4f8f467269ea}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!Mat@{Mat}}
\index{Mat@{Mat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{Mat()}{Mat()}\hspace{0.1cm}{\footnotesize\ttfamily [9/9]}}
{\footnotesize\ttfamily org.\+opencv.\+core.\+Mat.\+Mat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{roi }\end{DoxyParamCaption})}

Various \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} constructors

These are various constructors that form a matrix. As noted in the \char`\"{}\+Automatic\+Allocation\char`\"{}, often the default constructor is enough, and the proper matrix will be allocated by an Open\+CV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with \char`\"{}\+Mat.\+create\char`\"{}. In the former case, the old content is de-\/referenced.


\begin{DoxyParams}{Parameters}
{\em m} & Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors. Instead, the header pointing to {\ttfamily m} data or its sub-\/array is constructed and associated with it. The reference counter, if any, is incremented. So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of {\ttfamily m}. If you want to have an independent copy of the sub-\/array, use {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a7e40ecb438d2ec75e24e209b7bee0be2}{Mat.\+clone()}}}. \\
\hline
{\em roi} & Region of interest.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mat}{\tt org.\+opencv.\+core.\+Mat.\+Mat} 
\end{DoxySeeAlso}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a76da70f4d8bbf780fc2a351bdffc06ed}\label{classorg_1_1opencv_1_1core_1_1_mat_a76da70f4d8bbf780fc2a351bdffc06ed}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!adjust\+R\+OI@{adjust\+R\+OI}}
\index{adjust\+R\+OI@{adjust\+R\+OI}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{adjust\+R\+O\+I()}{adjustROI()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+adjust\+R\+OI (\begin{DoxyParamCaption}\item[{int}]{dtop,  }\item[{int}]{dbottom,  }\item[{int}]{dleft,  }\item[{int}]{dright }\end{DoxyParamCaption})}

Adjusts a submatrix size and position within the parent matrix.

The method is complimentary to\char`\"{}\+Mat.\+locate\+R\+O\+I\char`\"{}. The typical use of these functions is to determine the submatrix position within the parent matrix and then shift the position somehow. Typically, it can be required for filtering operations when pixels outside of the R\+OI should be taken into account. When all the method parameters are positive, the R\+OI needs to grow in all directions by the specified amount, for example\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily A.\+adjust\+R\+O\+I(2, 2, 2, 2);}

{\ttfamily }

{\ttfamily }

{\ttfamily In this example, the matrix size is increased by 4 elements in each direction. The matrix is shifted by 2 elements to the left and 2 elements up, which brings in all the necessary pixels for the filtering with the 5x5 kernel. }

{\ttfamily adjust\+R\+OI} forces the adjusted R\+OI to be inside of the parent matrix that is boundaries of the adjusted R\+OI are constrained by boundaries of the parent matrix. For example, if the submatrix {\ttfamily A} is located in the first row of a parent matrix and you called {\ttfamily A.\+adjust\+R\+OI(2, 2, 2, 2)} then {\ttfamily A} will not be increased in the upward direction.

The function is used internally by the Open\+CV filtering functions, like \char`\"{}filter2\+D\char`\"{}, morphological operations, and so on.


\begin{DoxyParams}{Parameters}
{\em dtop} & Shift of the top submatrix boundary upwards. \\
\hline
{\em dbottom} & Shift of the bottom submatrix boundary downwards. \\
\hline
{\em dleft} & Shift of the left submatrix boundary to the left. \\
\hline
{\em dright} & Shift of the right submatrix boundary to the right.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-adjustroi}{\tt org.\+opencv.\+core.\+Mat.\+adjust\+R\+OI} 

\mbox{\hyperlink{classorg_1_1opencv_1_1imgproc_1_1_imgproc_aeeb280b7ea42158d887ce0d82e6ea0e4}{org.\+opencv.\+imgproc.\+Imgproc\+::copy\+Make\+Border}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a0b4dea332af31a9102b75892f66d0395}\label{classorg_1_1opencv_1_1core_1_1_mat_a0b4dea332af31a9102b75892f66d0395}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!assign\+To@{assign\+To}}
\index{assign\+To@{assign\+To}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{assign\+To()}{assignTo()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+assign\+To (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m,  }\item[{int}]{type }\end{DoxyParamCaption})}

Provides a functional form of {\ttfamily convert\+To}.

This is an internally used method called by the \char`\"{}\+Matrix\+Expressions\char`\"{} engine.


\begin{DoxyParams}{Parameters}
{\em m} & Destination array. \\
\hline
{\em type} & Desired destination array depth (or -\/1 if it should be the same as the source type).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-assignto}{\tt org.\+opencv.\+core.\+Mat.\+assign\+To} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_af363e731446cb340ff5e28e5ac8d5d6f}\label{classorg_1_1opencv_1_1core_1_1_mat_af363e731446cb340ff5e28e5ac8d5d6f}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!assign\+To@{assign\+To}}
\index{assign\+To@{assign\+To}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{assign\+To()}{assignTo()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+assign\+To (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m }\end{DoxyParamCaption})}

Provides a functional form of {\ttfamily convert\+To}.

This is an internally used method called by the \char`\"{}\+Matrix\+Expressions\char`\"{} engine.


\begin{DoxyParams}{Parameters}
{\em m} & Destination array.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-assignto}{\tt org.\+opencv.\+core.\+Mat.\+assign\+To} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ababb77842613942b86dad34ec909eacf}\label{classorg_1_1opencv_1_1core_1_1_mat_ababb77842613942b86dad34ec909eacf}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!channels@{channels}}
\index{channels@{channels}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{channels()}{channels()}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+channels (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns the number of matrix channels.

The method returns the number of matrix channels.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-channels}{\tt org.\+opencv.\+core.\+Mat.\+channels} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ab323ee864f290b7ddbd804a6fbe76ae0}\label{classorg_1_1opencv_1_1core_1_1_mat_ab323ee864f290b7ddbd804a6fbe76ae0}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!check\+Vector@{check\+Vector}}
\index{check\+Vector@{check\+Vector}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{check\+Vector()}{checkVector()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+check\+Vector (\begin{DoxyParamCaption}\item[{int}]{elem\+Channels,  }\item[{int}]{depth,  }\item[{boolean}]{require\+Continuous }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ae1237684f5ce865f9f74f2de48f73c60}\label{classorg_1_1opencv_1_1core_1_1_mat_ae1237684f5ce865f9f74f2de48f73c60}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!check\+Vector@{check\+Vector}}
\index{check\+Vector@{check\+Vector}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{check\+Vector()}{checkVector()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+check\+Vector (\begin{DoxyParamCaption}\item[{int}]{elem\+Channels,  }\item[{int}]{depth }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a336960f25d39af05618890ee00b7e28e}\label{classorg_1_1opencv_1_1core_1_1_mat_a336960f25d39af05618890ee00b7e28e}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!check\+Vector@{check\+Vector}}
\index{check\+Vector@{check\+Vector}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{check\+Vector()}{checkVector()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+check\+Vector (\begin{DoxyParamCaption}\item[{int}]{elem\+Channels }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a7e40ecb438d2ec75e24e209b7bee0be2}\label{classorg_1_1opencv_1_1core_1_1_mat_a7e40ecb438d2ec75e24e209b7bee0be2}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!clone@{clone}}
\index{clone@{clone}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{clone()}{clone()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+clone (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Creates a full copy of the array and the underlying data.

The method creates a full copy of the array. The original {\ttfamily step\mbox{[}\mbox{]}} is not taken into account. So, the array copy is a continuous array occupying {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a0aa57e546fe72e994dafe806f47f0081}{total()}}$\ast$elem\+Size()} bytes.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-clone}{\tt org.\+opencv.\+core.\+Mat.\+clone} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}\label{classorg_1_1opencv_1_1core_1_1_mat_ad1aa7a61ef1c57251d8d4031c541d5f2}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!col@{col}}
\index{col@{col}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{col()}{col()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+col (\begin{DoxyParamCaption}\item[{int}]{x }\end{DoxyParamCaption})}

Creates a matrix header for the specified matrix column.

The method makes a new header for the specified matrix column and returns it. This is an O(1) operation, regardless of the matrix size. The underlying data of the new matrix is shared with the original matrix. See also the \char`\"{}\+Mat.\+row\char`\"{} description.


\begin{DoxyParams}{Parameters}
{\em x} & A 0-\/based column index.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-col}{\tt org.\+opencv.\+core.\+Mat.\+col} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a28a58bdd7241151451c966e41da7e38b}\label{classorg_1_1opencv_1_1core_1_1_mat_a28a58bdd7241151451c966e41da7e38b}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!col\+Range@{col\+Range}}
\index{col\+Range@{col\+Range}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{col\+Range()}{colRange()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+col\+Range (\begin{DoxyParamCaption}\item[{int}]{startcol,  }\item[{int}]{endcol }\end{DoxyParamCaption})}

Creates a matrix header for the specified column span.

The method makes a new header for the specified column span of the matrix. Similarly to \char`\"{}\+Mat.\+row\char`\"{} and \char`\"{}\+Mat.\+col\char`\"{}, this is an O(1) operation.


\begin{DoxyParams}{Parameters}
{\em startcol} & An inclusive 0-\/based start index of the column span. \\
\hline
{\em endcol} & An exclusive 0-\/based ending index of the column span.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-colrange}{\tt org.\+opencv.\+core.\+Mat.\+col\+Range} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a2be44d10bfd5d8fa88d022b3b4dc773e}\label{classorg_1_1opencv_1_1core_1_1_mat_a2be44d10bfd5d8fa88d022b3b4dc773e}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!col\+Range@{col\+Range}}
\index{col\+Range@{col\+Range}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{col\+Range()}{colRange()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+col\+Range (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}}}]{r }\end{DoxyParamCaption})}

Creates a matrix header for the specified column span.

The method makes a new header for the specified column span of the matrix. Similarly to \char`\"{}\+Mat.\+row\char`\"{} and \char`\"{}\+Mat.\+col\char`\"{}, this is an O(1) operation.


\begin{DoxyParams}{Parameters}
{\em r} & \char`\"{}\+Range\char`\"{} structure containing both the start and the end indices.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-colrange}{\tt org.\+opencv.\+core.\+Mat.\+col\+Range} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_adddf469e35679e67bb350f779433ea8d}\label{classorg_1_1opencv_1_1core_1_1_mat_adddf469e35679e67bb350f779433ea8d}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!cols@{cols}}
\index{cols@{cols}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{cols()}{cols()}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+cols (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}\label{classorg_1_1opencv_1_1core_1_1_mat_aa783d679e1b68aa5f9da6434be761eb7}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!convert\+To@{convert\+To}}
\index{convert\+To@{convert\+To}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{convert\+To()}{convertTo()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+convert\+To (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m,  }\item[{int}]{rtype,  }\item[{double}]{alpha,  }\item[{double}]{beta }\end{DoxyParamCaption})}

Converts an array to another data type with optional scaling.

The method converts source pixel values to the target data type. {\ttfamily saturate\+\_\+cast$<$$>$} is applied at the end to avoid possible overflows\+:

{\itshape m(x,y) = saturate \+\_\+ cast\&ltr\+Type\&gt(alpha($\ast$this)(x,y) + beta)}


\begin{DoxyParams}{Parameters}
{\em m} & output matrix; if it does not have a proper size or type before the operation, it is reallocated. \\
\hline
{\em rtype} & desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if {\ttfamily rtype} is negative, the output matrix will have the same type as the input. \\
\hline
{\em alpha} & optional scale factor. \\
\hline
{\em beta} & optional delta added to the scaled values.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-convertto}{\tt org.\+opencv.\+core.\+Mat.\+convert\+To} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a0b77b1b98daf56bf32d799e2fc597037}\label{classorg_1_1opencv_1_1core_1_1_mat_a0b77b1b98daf56bf32d799e2fc597037}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!convert\+To@{convert\+To}}
\index{convert\+To@{convert\+To}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{convert\+To()}{convertTo()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+convert\+To (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m,  }\item[{int}]{rtype,  }\item[{double}]{alpha }\end{DoxyParamCaption})}

Converts an array to another data type with optional scaling.

The method converts source pixel values to the target data type. {\ttfamily saturate\+\_\+cast$<$$>$} is applied at the end to avoid possible overflows\+:

{\itshape m(x,y) = saturate \+\_\+ cast\&ltr\+Type\&gt(alpha($\ast$this)(x,y) + beta)}


\begin{DoxyParams}{Parameters}
{\em m} & output matrix; if it does not have a proper size or type before the operation, it is reallocated. \\
\hline
{\em rtype} & desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if {\ttfamily rtype} is negative, the output matrix will have the same type as the input. \\
\hline
{\em alpha} & optional scale factor.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-convertto}{\tt org.\+opencv.\+core.\+Mat.\+convert\+To} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_acdff78cc87bef2565f8907113d0eec11}\label{classorg_1_1opencv_1_1core_1_1_mat_acdff78cc87bef2565f8907113d0eec11}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!convert\+To@{convert\+To}}
\index{convert\+To@{convert\+To}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{convert\+To()}{convertTo()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+convert\+To (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m,  }\item[{int}]{rtype }\end{DoxyParamCaption})}

Converts an array to another data type with optional scaling.

The method converts source pixel values to the target data type. {\ttfamily saturate\+\_\+cast$<$$>$} is applied at the end to avoid possible overflows\+:

{\itshape m(x,y) = saturate \+\_\+ cast\&ltr\+Type\&gt(alpha($\ast$this)(x,y) + beta)}


\begin{DoxyParams}{Parameters}
{\em m} & output matrix; if it does not have a proper size or type before the operation, it is reallocated. \\
\hline
{\em rtype} & desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if {\ttfamily rtype} is negative, the output matrix will have the same type as the input.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-convertto}{\tt org.\+opencv.\+core.\+Mat.\+convert\+To} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_aa2d63f03533282ef5bd1f8dc0cbcbc0b}\label{classorg_1_1opencv_1_1core_1_1_mat_aa2d63f03533282ef5bd1f8dc0cbcbc0b}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!copy\+To@{copy\+To}}
\index{copy\+To@{copy\+To}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{copy\+To()}{copyTo()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+copy\+To (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m }\end{DoxyParamCaption})}

Copies the matrix to another one.

The method copies the matrix data to another matrix. Before copying the data, the method invokes {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily m.\+create(this-\/$>$\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a543d6f8a103a5f3d899030d76286f0cf}{size()}}, this-\/$>$\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type()}});}

{\ttfamily }

{\ttfamily }

{\ttfamily so that the destination matrix is reallocated if needed. While {\ttfamily m.\+copy\+To(m);} works flawlessly, the function does not handle the case of a partial overlap between the source and the destination matrices. }

When the operation mask is specified, if the {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a539b0a3690afb6b43047b50cbb787fee}{Mat.\+create}}} call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data.


\begin{DoxyParams}{Parameters}
{\em m} & Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-copyto}{\tt org.\+opencv.\+core.\+Mat.\+copy\+To} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ae1a7d7ed81f82bda92cb641c6060f2be}\label{classorg_1_1opencv_1_1core_1_1_mat_ae1a7d7ed81f82bda92cb641c6060f2be}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!copy\+To@{copy\+To}}
\index{copy\+To@{copy\+To}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{copy\+To()}{copyTo()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+copy\+To (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})}

Copies the matrix to another one.

The method copies the matrix data to another matrix. Before copying the data, the method invokes {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily m.\+create(this-\/$>$\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a543d6f8a103a5f3d899030d76286f0cf}{size()}}, this-\/$>$\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}{type()}});}

{\ttfamily }

{\ttfamily }

{\ttfamily so that the destination matrix is reallocated if needed. While {\ttfamily m.\+copy\+To(m);} works flawlessly, the function does not handle the case of a partial overlap between the source and the destination matrices. }

When the operation mask is specified, if the {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a539b0a3690afb6b43047b50cbb787fee}{Mat.\+create}}} call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data.


\begin{DoxyParams}{Parameters}
{\em m} & Destination matrix. If it does not have a proper size or type before the operation, it is reallocated. \\
\hline
{\em mask} & Operation mask. Its non-\/zero elements indicate which matrix elements need to be copied.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-copyto}{\tt org.\+opencv.\+core.\+Mat.\+copy\+To} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a539b0a3690afb6b43047b50cbb787fee}\label{classorg_1_1opencv_1_1core_1_1_mat_a539b0a3690afb6b43047b50cbb787fee}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!create@{create}}
\index{create@{create}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+create (\begin{DoxyParamCaption}\item[{int}]{rows,  }\item[{int}]{cols,  }\item[{int}]{type }\end{DoxyParamCaption})}

Allocates new array data if needed.

This is one of the key {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}} methods. Most new-\/style Open\+CV functions and methods that produce arrays call this method for each output array. The method uses the following algorithm\+:


\begin{DoxyItemize}
\item If the current array shape and the type match the new ones, return immediately. Otherwise, de-\/reference the previous data by calling \char`\"{}\+Mat.\+release\char`\"{}. 
\item Initialize the new header. 
\item Allocate the new data of {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a0aa57e546fe72e994dafe806f47f0081}{total()}}$\ast$elem\+Size()} bytes. 
\item Allocate the new, associated with the data, reference counter and set it to 1. 
\end{DoxyItemize}

Such a scheme makes the memory management robust and efficient at the same time and helps avoid extra typing for you. This means that usually there is no need to explicitly allocate output arrays. That is, instead of writing\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} color;...}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} gray(color.\+rows, color.\+cols, color.\+depth());}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(color, gray, C\+V\+\_\+\+B\+G\+R2\+G\+R\+A\+Y);}

{\ttfamily }

{\ttfamily }

{\ttfamily you can simply write\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} color;...}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} gray;}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(color, gray, C\+V\+\_\+\+B\+G\+R2\+G\+R\+A\+Y);}

{\ttfamily }

{\ttfamily }

{\ttfamily because {\ttfamily cvt\+Color}, as well as the most of Open\+CV functions, calls {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a539b0a3690afb6b43047b50cbb787fee}{Mat.\+create()}}} for the output array internally. }


\begin{DoxyParams}{Parameters}
{\em rows} & New number of rows. \\
\hline
{\em cols} & New number of columns. \\
\hline
{\em type} & New matrix type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-create}{\tt org.\+opencv.\+core.\+Mat.\+create} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_afd55f958255662f40a0bbe03813cb8b2}\label{classorg_1_1opencv_1_1core_1_1_mat_afd55f958255662f40a0bbe03813cb8b2}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!create@{create}}
\index{create@{create}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{create()}{create()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+create (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{size,  }\item[{int}]{type }\end{DoxyParamCaption})}

Allocates new array data if needed.

This is one of the key {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}} methods. Most new-\/style Open\+CV functions and methods that produce arrays call this method for each output array. The method uses the following algorithm\+:


\begin{DoxyItemize}
\item If the current array shape and the type match the new ones, return immediately. Otherwise, de-\/reference the previous data by calling \char`\"{}\+Mat.\+release\char`\"{}. 
\item Initialize the new header. 
\item Allocate the new data of {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a0aa57e546fe72e994dafe806f47f0081}{total()}}$\ast$elem\+Size()} bytes. 
\item Allocate the new, associated with the data, reference counter and set it to 1. 
\end{DoxyItemize}

Such a scheme makes the memory management robust and efficient at the same time and helps avoid extra typing for you. This means that usually there is no need to explicitly allocate output arrays. That is, instead of writing\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} color;...}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} gray(color.\+rows, color.\+cols, color.\+depth());}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(color, gray, C\+V\+\_\+\+B\+G\+R2\+G\+R\+A\+Y);}

{\ttfamily }

{\ttfamily }

{\ttfamily you can simply write\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} color;...}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} gray;}

{\ttfamily }

{\ttfamily }

{\ttfamily cvt\+Color(color, gray, C\+V\+\_\+\+B\+G\+R2\+G\+R\+A\+Y);}

{\ttfamily }

{\ttfamily }

{\ttfamily because {\ttfamily cvt\+Color}, as well as the most of Open\+CV functions, calls {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a539b0a3690afb6b43047b50cbb787fee}{Mat.\+create()}}} for the output array internally. }


\begin{DoxyParams}{Parameters}
{\em size} & Alternative new matrix size specification\+: {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}(cols, rows)} \\
\hline
{\em type} & New matrix type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-create}{\tt org.\+opencv.\+core.\+Mat.\+create} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a830b2d8626fe668db82180adf69e6145}\label{classorg_1_1opencv_1_1core_1_1_mat_a830b2d8626fe668db82180adf69e6145}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!cross@{cross}}
\index{cross@{cross}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{cross()}{cross()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+cross (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m }\end{DoxyParamCaption})}

Computes a cross-\/product of two 3-\/element vectors.

The method computes a cross-\/product of two 3-\/element vectors. The vectors must be 3-\/element floating-\/point vectors of the same shape and size. The result is another 3-\/element vector of the same shape and type as operands.


\begin{DoxyParams}{Parameters}
{\em m} & Another cross-\/product operand.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-cross}{\tt org.\+opencv.\+core.\+Mat.\+cross} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a3b5dcff6ae75137a18cd781454b1129a}\label{classorg_1_1opencv_1_1core_1_1_mat_a3b5dcff6ae75137a18cd781454b1129a}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!data\+Addr@{data\+Addr}}
\index{data\+Addr@{data\+Addr}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{data\+Addr()}{dataAddr()}}
{\footnotesize\ttfamily long org.\+opencv.\+core.\+Mat.\+data\+Addr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a9bf4679d10841047167676cde239a5b9}\label{classorg_1_1opencv_1_1core_1_1_mat_a9bf4679d10841047167676cde239a5b9}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!depth@{depth}}
\index{depth@{depth}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{depth()}{depth()}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+depth (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns the depth of a matrix element.

The method returns the identifier of the matrix element depth (the type of each individual channel). For example, for a 16-\/bit signed element array, the method returns {\ttfamily C\+V\+\_\+16S}. A complete list of matrix types contains the following values\+:


\begin{DoxyItemize}
\item {\ttfamily C\+V\+\_\+8U} -\/ 8-\/bit unsigned integers ({\ttfamily 0..255}) 
\item {\ttfamily C\+V\+\_\+8S} -\/ 8-\/bit signed integers ({\ttfamily -\/128..127}) 
\item {\ttfamily C\+V\+\_\+16U} -\/ 16-\/bit unsigned integers ({\ttfamily 0..65535}) 
\item {\ttfamily C\+V\+\_\+16S} -\/ 16-\/bit signed integers ({\ttfamily -\/32768..32767}) 
\item {\ttfamily C\+V\+\_\+32S} -\/ 32-\/bit signed integers ({\ttfamily -\/2147483648..2147483647}) 
\item {\ttfamily C\+V\+\_\+32F} -\/ 32-\/bit floating-\/point numbers ({\ttfamily -\/\+F\+L\+T\+\_\+\+M\+AX..F\+L\+T\+\_\+\+M\+AX, I\+NF, N\+AN}) 
\item {\ttfamily C\+V\+\_\+64F} -\/ 64-\/bit floating-\/point numbers ({\ttfamily -\/\+D\+B\+L\+\_\+\+M\+AX..D\+B\+L\+\_\+\+M\+AX, I\+NF, N\+AN}) 
\end{DoxyItemize}

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-depth}{\tt org.\+opencv.\+core.\+Mat.\+depth} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_aa28ea6e2ec65861e30319e443dbde298}\label{classorg_1_1opencv_1_1core_1_1_mat_aa28ea6e2ec65861e30319e443dbde298}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!diag@{diag}}
\index{diag@{diag}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{diag()}{diag()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+diag (\begin{DoxyParamCaption}\item[{int}]{d }\end{DoxyParamCaption})}

Extracts a diagonal from a matrix, or creates a diagonal matrix.

The method makes a new header for the specified matrix diagonal. The new matrix is represented as a single-\/column matrix. Similarly to \char`\"{}\+Mat.\+row\char`\"{} and \char`\"{}\+Mat.\+col\char`\"{}, this is an O(1) operation.


\begin{DoxyParams}{Parameters}
{\em d} & Single-\/column matrix that forms a diagonal matrix or index of the diagonal, with the following values\+: 
\begin{DoxyItemize}
\item d=0 is the main diagonal. 
\item d$>$0 is a diagonal from the lower half. For example, {\ttfamily d=1} means the diagonal is set immediately below the main one. 
\item d$<$0 is a diagonal from the upper half. For example, {\ttfamily d=1} means the diagonal is set immediately above the main one. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-diag}{\tt org.\+opencv.\+core.\+Mat.\+diag} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a46c17fd51fa6344e2081006c1a98b4d8}\label{classorg_1_1opencv_1_1core_1_1_mat_a46c17fd51fa6344e2081006c1a98b4d8}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!diag@{diag}}
\index{diag@{diag}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{diag()}{diag()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+diag (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Extracts a diagonal from a matrix, or creates a diagonal matrix.

The method makes a new header for the specified matrix diagonal. The new matrix is represented as a single-\/column matrix. Similarly to \char`\"{}\+Mat.\+row\char`\"{} and \char`\"{}\+Mat.\+col\char`\"{}, this is an O(1) operation.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-diag}{\tt org.\+opencv.\+core.\+Mat.\+diag} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a4accc142f642a4f5fc468bea14fc42f1}\label{classorg_1_1opencv_1_1core_1_1_mat_a4accc142f642a4f5fc468bea14fc42f1}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!diag@{diag}}
\index{diag@{diag}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{diag()}{diag()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+diag (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{d }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Extracts a diagonal from a matrix, or creates a diagonal matrix.

The method makes a new header for the specified matrix diagonal. The new matrix is represented as a single-\/column matrix. Similarly to \char`\"{}\+Mat.\+row\char`\"{} and \char`\"{}\+Mat.\+col\char`\"{}, this is an O(1) operation.


\begin{DoxyParams}{Parameters}
{\em d} & Single-\/column matrix that forms a diagonal matrix or index of the diagonal, with the following values\+: 
\begin{DoxyItemize}
\item d=0 is the main diagonal. 
\item d$>$0 is a diagonal from the lower half. For example, {\ttfamily d=1} means the diagonal is set immediately below the main one. 
\item d$<$0 is a diagonal from the upper half. For example, {\ttfamily d=1} means the diagonal is set immediately above the main one. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-diag}{\tt org.\+opencv.\+core.\+Mat.\+diag} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a9da03786400df5d6ef7ff4217f9a93f9}\label{classorg_1_1opencv_1_1core_1_1_mat_a9da03786400df5d6ef7ff4217f9a93f9}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!dims@{dims}}
\index{dims@{dims}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{dims()}{dims()}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+dims (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a053eb46b103c30891659945a6434c5db}\label{classorg_1_1opencv_1_1core_1_1_mat_a053eb46b103c30891659945a6434c5db}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!dot@{dot}}
\index{dot@{dot}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{dot()}{dot()}}
{\footnotesize\ttfamily double org.\+opencv.\+core.\+Mat.\+dot (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m }\end{DoxyParamCaption})}

Computes a dot-\/product of two vectors.

The method computes a dot-\/product of two matrices. If the matrices are not single-\/column or single-\/row vectors, the top-\/to-\/bottom left-\/to-\/right scan ordering is used to treat them as 1D vectors. The vectors must have the same size and type. If the matrices have more than one channel, the dot products from all the channels are summed together.


\begin{DoxyParams}{Parameters}
{\em m} & another dot-\/product operand.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-dot}{\tt org.\+opencv.\+core.\+Mat.\+dot} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a525efae06b8fcd10a0bb10e7c5a13212}\label{classorg_1_1opencv_1_1core_1_1_mat_a525efae06b8fcd10a0bb10e7c5a13212}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!dump@{dump}}
\index{dump@{dump}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{dump()}{dump()}}
{\footnotesize\ttfamily String org.\+opencv.\+core.\+Mat.\+dump (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_aefa109235b149088d48188cb54b891e9}\label{classorg_1_1opencv_1_1core_1_1_mat_aefa109235b149088d48188cb54b891e9}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!elem\+Size@{elem\+Size}}
\index{elem\+Size@{elem\+Size}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{elem\+Size()}{elemSize()}}
{\footnotesize\ttfamily long org.\+opencv.\+core.\+Mat.\+elem\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns the matrix element size in bytes.

The method returns the matrix element size in bytes. For example, if the matrix type is {\ttfamily C\+V\+\_\+16\+S\+C3}, the method returns {\ttfamily 3$\ast$sizeof(short)} or 6.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-elemsize}{\tt org.\+opencv.\+core.\+Mat.\+elem\+Size} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ae174b003b4f0e87a3a1dbf805962b145}\label{classorg_1_1opencv_1_1core_1_1_mat_ae174b003b4f0e87a3a1dbf805962b145}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!elem\+Size1@{elem\+Size1}}
\index{elem\+Size1@{elem\+Size1}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{elem\+Size1()}{elemSize1()}}
{\footnotesize\ttfamily long org.\+opencv.\+core.\+Mat.\+elem\+Size1 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns the size of each matrix element channel in bytes.

The method returns the matrix element channel size in bytes, that is, it ignores the number of channels. For example, if the matrix type is {\ttfamily C\+V\+\_\+16\+S\+C3}, the method returns {\ttfamily sizeof(short)} or 2.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-elemsize1}{\tt org.\+opencv.\+core.\+Mat.\+elem\+Size1} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a873fa8cc0d87ffae2b9c9ed94d79ddec}\label{classorg_1_1opencv_1_1core_1_1_mat_a873fa8cc0d87ffae2b9c9ed94d79ddec}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!empty@{empty}}
\index{empty@{empty}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily boolean org.\+opencv.\+core.\+Mat.\+empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns {\ttfamily true} if the array has no elements.

The method returns {\ttfamily true} if {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a0aa57e546fe72e994dafe806f47f0081}{Mat.\+total()}}} is 0 or if {\ttfamily Mat.\+data} is N\+U\+LL. Because of {\ttfamily pop\+\_\+back()} and {\ttfamily resize()} methods {\ttfamily M.\+total() == 0} does not imply that {\ttfamily M.\+data == N\+U\+LL}.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-empty}{\tt org.\+opencv.\+core.\+Mat.\+empty} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a4de6ffd10feb724153f1ec1231533aa9}\label{classorg_1_1opencv_1_1core_1_1_mat_a4de6ffd10feb724153f1ec1231533aa9}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!eye@{eye}}
\index{eye@{eye}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{eye()}{eye()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+eye (\begin{DoxyParamCaption}\item[{int}]{rows,  }\item[{int}]{cols,  }\item[{int}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns an identity matrix of the specified size and type.

The method returns a Matlab-\/style identity matrix initializer, similarly to \char`\"{}\+Mat.\+zeros\char`\"{}. Similarly to\char`\"{}\+Mat.\+ones\char`\"{}, you can use a scale operation to create a scaled identity matrix efficiently\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // make a 4x4 diagonal matrix with 0.\+1\textquotesingle{}s on the diagonal.}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A = Mat.\+eye(4, 4, C\+V\+\_\+32\+F)$\ast$0.1;}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em rows} & Number of rows. \\
\hline
{\em cols} & Number of columns. \\
\hline
{\em type} & Created matrix type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-eye}{\tt org.\+opencv.\+core.\+Mat.\+eye} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a3b7002cc04ec4871e280922a6de3e78a}\label{classorg_1_1opencv_1_1core_1_1_mat_a3b7002cc04ec4871e280922a6de3e78a}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!eye@{eye}}
\index{eye@{eye}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{eye()}{eye()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+eye (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{size,  }\item[{int}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns an identity matrix of the specified size and type.

The method returns a Matlab-\/style identity matrix initializer, similarly to \char`\"{}\+Mat.\+zeros\char`\"{}. Similarly to\char`\"{}\+Mat.\+ones\char`\"{}, you can use a scale operation to create a scaled identity matrix efficiently\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // make a 4x4 diagonal matrix with 0.\+1\textquotesingle{}s on the diagonal.}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A = Mat.\+eye(4, 4, C\+V\+\_\+32\+F)$\ast$0.1;}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em size} & Alternative matrix size specification as {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}(cols, rows)}. \\
\hline
{\em type} & Created matrix type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-eye}{\tt org.\+opencv.\+core.\+Mat.\+eye} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_aca52fe6f5554bfbff11c44e07952ba2d}\label{classorg_1_1opencv_1_1core_1_1_mat_aca52fe6f5554bfbff11c44e07952ba2d}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!finalize@{finalize}}
\index{finalize@{finalize}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{finalize()}{finalize()}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+finalize (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) throws Throwable\hspace{0.3cm}{\ttfamily [protected]}}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a5770a138198285c9cc0a9545bda1b0ac}\label{classorg_1_1opencv_1_1core_1_1_mat_a5770a138198285c9cc0a9545bda1b0ac}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!get@{get}}
\index{get@{get}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+get (\begin{DoxyParamCaption}\item[{int}]{row,  }\item[{int}]{col,  }\item[{byte \mbox{[}$\,$\mbox{]}}]{data }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_aa1a035119cc01d317423b60eac0012c7}\label{classorg_1_1opencv_1_1core_1_1_mat_aa1a035119cc01d317423b60eac0012c7}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!get@{get}}
\index{get@{get}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+get (\begin{DoxyParamCaption}\item[{int}]{row,  }\item[{int}]{col,  }\item[{short \mbox{[}$\,$\mbox{]}}]{data }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a2da432d61617c9a7f4c4ed6885ba3563}\label{classorg_1_1opencv_1_1core_1_1_mat_a2da432d61617c9a7f4c4ed6885ba3563}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!get@{get}}
\index{get@{get}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+get (\begin{DoxyParamCaption}\item[{int}]{row,  }\item[{int}]{col,  }\item[{int \mbox{[}$\,$\mbox{]}}]{data }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_aae0f9f38d8b37170e451cb223b5bae02}\label{classorg_1_1opencv_1_1core_1_1_mat_aae0f9f38d8b37170e451cb223b5bae02}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!get@{get}}
\index{get@{get}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+get (\begin{DoxyParamCaption}\item[{int}]{row,  }\item[{int}]{col,  }\item[{float \mbox{[}$\,$\mbox{]}}]{data }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a7878222dfb1c0b8ed9311928d2a483c2}\label{classorg_1_1opencv_1_1core_1_1_mat_a7878222dfb1c0b8ed9311928d2a483c2}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!get@{get}}
\index{get@{get}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+get (\begin{DoxyParamCaption}\item[{int}]{row,  }\item[{int}]{col,  }\item[{double \mbox{[}$\,$\mbox{]}}]{data }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a1c38398b5cd4cf9adaf6c2bac63f7d0a}\label{classorg_1_1opencv_1_1core_1_1_mat_a1c38398b5cd4cf9adaf6c2bac63f7d0a}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!get@{get}}
\index{get@{get}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{get()}{get()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily double \mbox{[}$\,$\mbox{]} org.\+opencv.\+core.\+Mat.\+get (\begin{DoxyParamCaption}\item[{int}]{row,  }\item[{int}]{col }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a6c5d603d138873bb994a328ddef257da}\label{classorg_1_1opencv_1_1core_1_1_mat_a6c5d603d138873bb994a328ddef257da}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!get\+Native\+Obj\+Addr@{get\+Native\+Obj\+Addr}}
\index{get\+Native\+Obj\+Addr@{get\+Native\+Obj\+Addr}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{get\+Native\+Obj\+Addr()}{getNativeObjAddr()}}
{\footnotesize\ttfamily long org.\+opencv.\+core.\+Mat.\+get\+Native\+Obj\+Addr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a6cf76dab73965b27be55ecf781db4721}\label{classorg_1_1opencv_1_1core_1_1_mat_a6cf76dab73965b27be55ecf781db4721}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!height@{height}}
\index{height@{height}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{height()}{height()}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+height (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ae2903c2da88b961ac9a77352577ed655}\label{classorg_1_1opencv_1_1core_1_1_mat_ae2903c2da88b961ac9a77352577ed655}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!inv@{inv}}
\index{inv@{inv}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{inv()}{inv()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+inv (\begin{DoxyParamCaption}\item[{int}]{method }\end{DoxyParamCaption})}

Inverses a matrix.

The method performs a matrix inversion by means of matrix expressions. This means that a temporary matrix inversion object is returned by the method and can be used further as a part of more complex matrix expressions or can be assigned to a matrix.


\begin{DoxyParams}{Parameters}
{\em method} & Matrix inversion method. Possible values are the following\+: 
\begin{DoxyItemize}
\item D\+E\+C\+O\+M\+P\+\_\+\+LU is the LU decomposition. The matrix must be non-\/singular. 
\item D\+E\+C\+O\+M\+P\+\_\+\+C\+H\+O\+L\+E\+S\+KY is the Cholesky {\itshape L\+L$^\wedge$T} decomposition for symmetrical positively defined matrices only. This type is about twice faster than LU on big matrices. 
\item D\+E\+C\+O\+M\+P\+\_\+\+S\+VD is the S\+VD decomposition. If the matrix is singular or even non-\/square, the pseudo inversion is computed. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-inv}{\tt org.\+opencv.\+core.\+Mat.\+inv} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a3ae81a587a404aa8b3751af8c0763515}\label{classorg_1_1opencv_1_1core_1_1_mat_a3ae81a587a404aa8b3751af8c0763515}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!inv@{inv}}
\index{inv@{inv}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{inv()}{inv()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+inv (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Inverses a matrix.

The method performs a matrix inversion by means of matrix expressions. This means that a temporary matrix inversion object is returned by the method and can be used further as a part of more complex matrix expressions or can be assigned to a matrix.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-inv}{\tt org.\+opencv.\+core.\+Mat.\+inv} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a0aaf7d8f437a0dbd73d9f9d1534404f1}\label{classorg_1_1opencv_1_1core_1_1_mat_a0aaf7d8f437a0dbd73d9f9d1534404f1}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!is\+Continuous@{is\+Continuous}}
\index{is\+Continuous@{is\+Continuous}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{is\+Continuous()}{isContinuous()}}
{\footnotesize\ttfamily boolean org.\+opencv.\+core.\+Mat.\+is\+Continuous (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Reports whether the matrix is continuous or not.

The method returns {\ttfamily true} if the matrix elements are stored continuously without gaps at the end of each row. Otherwise, it returns {\ttfamily false}. Obviously, {\ttfamily 1x1} or {\ttfamily 1xN} matrices are always continuous. Matrices created with \char`\"{}\+Mat.\+create\char`\"{} are always continuous. But if you extract a part of the matrix using \char`\"{}\+Mat.\+col\char`\"{}, \char`\"{}\+Mat.\+diag\char`\"{}, and so on, or constructed a matrix header for externally allocated data, such matrices may no longer have this property. The continuity flag is stored as a bit in the {\ttfamily Mat.\+flags} field and is computed automatically when you construct a matrix header. Thus, the continuity check is a very fast operation, though theoretically it could be done as follows\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily // alternative implementation of \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a0aaf7d8f437a0dbd73d9f9d1534404f1}{Mat.\+is\+Continuous()}}}

{\ttfamily }

{\ttfamily }

{\ttfamily bool my\+Check\+Mat\+Continuity(const Mat\& m)}

{\ttfamily }

{\ttfamily }

{\ttfamily //return (m.\+flags \& Mat.\+C\+O\+N\+T\+I\+N\+U\+O\+U\+S\+\_\+\+F\+L\+AG) != 0;}

{\ttfamily }

{\ttfamily }

{\ttfamily return m.\+rows == 1 $\vert$$\vert$ m.\+step == m.\+cols$\ast$m.\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_aefa109235b149088d48188cb54b891e9}{elem\+Size()}};}

{\ttfamily }

{\ttfamily }

{\ttfamily The method is used in quite a few of Open\+CV functions. The point is that element-\/wise operations (such as arithmetic and logical operations, math functions, alpha blending, color space transformations, and others) do not depend on the image geometry. Thus, if all the input and output arrays are continuous, the functions can process them as very long single-\/row vectors. The example below illustrates how an alpha-\/blending function can be implemented.}

{\ttfamily }

{\ttfamily }

{\ttfamily template$<$typename T$>$}

{\ttfamily }

{\ttfamily }

{\ttfamily void alpha\+Blend\+R\+G\+B\+A(const Mat\& src1, const Mat\& src2, Mat\& dst)}

{\ttfamily }

{\ttfamily }

{\ttfamily const float alpha\+\_\+scale = (float)std.\+numeric\+\_\+limits$<$\+T$>$.\+max(),}

{\ttfamily }

{\ttfamily }

{\ttfamily inv\+\_\+scale = 1.\+f/alpha\+\_\+scale;}

{\ttfamily }

{\ttfamily }

{\ttfamily C\+V\+\_\+\+Assert(src1.\+type() == src2.\+type() \&\&}

{\ttfamily }

{\ttfamily }

{\ttfamily src1.\+type() == C\+V\+\_\+\+M\+A\+K\+E\+T\+Y\+PE(Data\+Type$<$\+T$>$.\+depth, 4) \&\&}

{\ttfamily }

{\ttfamily }

{\ttfamily src1.\+size() == src2.\+size());}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} size = src1.\+size();}

{\ttfamily }

{\ttfamily }

{\ttfamily dst.\+create(size, src1.\+type());}

{\ttfamily }

{\ttfamily }

{\ttfamily // here is the idiom\+: check the arrays for continuity and,}

{\ttfamily }

{\ttfamily }

{\ttfamily // if this is the case,}

{\ttfamily }

{\ttfamily }

{\ttfamily // treat the arrays as 1D vectors}

{\ttfamily }

{\ttfamily }

{\ttfamily if(src1.\+is\+Continuous() \&\& src2.\+is\+Continuous() \&\& dst.\+is\+Continuous())}

{\ttfamily }

{\ttfamily }

{\ttfamily size.\+width $\ast$= size.\+height;}

{\ttfamily }

{\ttfamily }

{\ttfamily size.\+height = 1;}

{\ttfamily }

{\ttfamily }

{\ttfamily size.\+width $\ast$= 4;}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int i = 0; i $<$ size.\+height; i++)}

{\ttfamily }

{\ttfamily }

{\ttfamily // when the arrays are continuous,}

{\ttfamily }

{\ttfamily }

{\ttfamily // the outer loop is executed only once}

{\ttfamily }

{\ttfamily }

{\ttfamily const T$\ast$ ptr1 = src1.\+ptr$<$\+T$>$(i);}

{\ttfamily }

{\ttfamily }

{\ttfamily const T$\ast$ ptr2 = src2.\+ptr$<$\+T$>$(i);}

{\ttfamily }

{\ttfamily }

{\ttfamily T$\ast$ dptr = dst.\+ptr$<$\+T$>$(i);}

{\ttfamily }

{\ttfamily }

{\ttfamily for(int j = 0; j $<$ size.\+width; j += 4)}

{\ttfamily }

{\ttfamily }

{\ttfamily float alpha = ptr1\mbox{[}j+3\mbox{]}$\ast$inv\+\_\+scale, beta = ptr2\mbox{[}j+3\mbox{]}$\ast$inv\+\_\+scale;}

{\ttfamily }

{\ttfamily }

{\ttfamily dptr\mbox{[}j\mbox{]} = saturate\+\_\+cast$<$\+T$>$(ptr1\mbox{[}j\mbox{]}$\ast$alpha + ptr2\mbox{[}j\mbox{]}$\ast$beta);}

{\ttfamily }

{\ttfamily }

{\ttfamily dptr\mbox{[}j+1\mbox{]} = saturate\+\_\+cast$<$\+T$>$(ptr1\mbox{[}j+1\mbox{]}$\ast$alpha + ptr2\mbox{[}j+1\mbox{]}$\ast$beta);}

{\ttfamily }

{\ttfamily }

{\ttfamily dptr\mbox{[}j+2\mbox{]} = saturate\+\_\+cast$<$\+T$>$(ptr1\mbox{[}j+2\mbox{]}$\ast$alpha + ptr2\mbox{[}j+2\mbox{]}$\ast$beta);}

{\ttfamily }

{\ttfamily }

{\ttfamily dptr\mbox{[}j+3\mbox{]} = saturate\+\_\+cast$<$\+T$>$((1 -\/ (1-\/alpha)$\ast$(1-\/beta))$\ast$alpha\+\_\+scale);}

{\ttfamily }

{\ttfamily }

{\ttfamily This approach, while being very simple, can boost the performance of a simple element-\/operation by 10-\/20 percents, especially if the image is rather small and the operation is quite simple. }

Another Open\+CV idiom in this function, a call of \char`\"{}\+Mat.\+create\char`\"{} for the destination array, that allocates the destination array unless it already has the proper size and type. And while the newly allocated arrays are always continuous, you still need to check the destination array because \char`\"{}\+Mat.\+create\char`\"{} does not always allocate a new matrix.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-iscontinuous}{\tt org.\+opencv.\+core.\+Mat.\+is\+Continuous} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a5a8e2cf2e6d2951ba8c939a4c351793a}\label{classorg_1_1opencv_1_1core_1_1_mat_a5a8e2cf2e6d2951ba8c939a4c351793a}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!is\+Submatrix@{is\+Submatrix}}
\index{is\+Submatrix@{is\+Submatrix}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{is\+Submatrix()}{isSubmatrix()}}
{\footnotesize\ttfamily boolean org.\+opencv.\+core.\+Mat.\+is\+Submatrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a51784a0e99c00a52e8be330cf05710f8}\label{classorg_1_1opencv_1_1core_1_1_mat_a51784a0e99c00a52e8be330cf05710f8}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!locate\+R\+OI@{locate\+R\+OI}}
\index{locate\+R\+OI@{locate\+R\+OI}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{locate\+R\+O\+I()}{locateROI()}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+locate\+R\+OI (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{whole\+Size,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_point}{Point}}}]{ofs }\end{DoxyParamCaption})}

Locates the matrix header within a parent matrix.

After you extracted a submatrix from a matrix using \char`\"{}\+Mat.\+row\char`\"{}, \char`\"{}\+Mat.\+col\char`\"{}, \char`\"{}\+Mat.\+row\+Range\char`\"{}, \char`\"{}\+Mat.\+col\+Range\char`\"{}, and others, the resultant submatrix points just to the part of the original big matrix. However, each submatrix contains information (represented by {\ttfamily datastart} and {\ttfamily dataend} fields) that helps reconstruct the original matrix size and the position of the extracted submatrix within the original matrix. The method {\ttfamily locate\+R\+OI} does exactly that.


\begin{DoxyParams}{Parameters}
{\em whole\+Size} & Output parameter that contains the size of the whole matrix containing {\ttfamily $\ast$this} as a part. \\
\hline
{\em ofs} & Output parameter that contains an offset of {\ttfamily $\ast$this} inside the whole matrix.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-locateroi}{\tt org.\+opencv.\+core.\+Mat.\+locate\+R\+OI} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a43e95787eea4de307230ceeb14bba8f6}\label{classorg_1_1opencv_1_1core_1_1_mat_a43e95787eea4de307230ceeb14bba8f6}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!mul@{mul}}
\index{mul@{mul}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{mul()}{mul()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+mul (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m,  }\item[{double}]{scale }\end{DoxyParamCaption})}

Performs an element-\/wise multiplication or division of the two matrices.

The method returns a temporary object encoding per-\/element array multiplication, with optional scale. Note that this is not a matrix multiplication that corresponds to a simpler \char`\"{}$\ast$\char`\"{} operator. Example\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} C = A.\+mul(5/B); // equivalent to divide(\+A, B, C, 5)}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em m} & Another array of the same type and the same size as {\ttfamily $\ast$this}, or a matrix expression. \\
\hline
{\em scale} & Optional scale factor.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mul}{\tt org.\+opencv.\+core.\+Mat.\+mul} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_afa27812124a1a17a0b4c003637b7a27b}\label{classorg_1_1opencv_1_1core_1_1_mat_afa27812124a1a17a0b4c003637b7a27b}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!mul@{mul}}
\index{mul@{mul}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{mul()}{mul()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+mul (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m }\end{DoxyParamCaption})}

Performs an element-\/wise multiplication or division of the two matrices.

The method returns a temporary object encoding per-\/element array multiplication, with optional scale. Note that this is not a matrix multiplication that corresponds to a simpler \char`\"{}$\ast$\char`\"{} operator. Example\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} C = A.\+mul(5/B); // equivalent to divide(\+A, B, C, 5)}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em m} & Another array of the same type and the same size as {\ttfamily $\ast$this}, or a matrix expression.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-mul}{\tt org.\+opencv.\+core.\+Mat.\+mul} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a34d703df023730d043298601b6962f57}\label{classorg_1_1opencv_1_1core_1_1_mat_a34d703df023730d043298601b6962f57}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!ones@{ones}}
\index{ones@{ones}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{ones()}{ones()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+ones (\begin{DoxyParamCaption}\item[{int}]{rows,  }\item[{int}]{cols,  }\item[{int}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns an array of all 1\textquotesingle{}s of the specified size and type.

The method returns a Matlab-\/style 1\textquotesingle{}s array initializer, similarly to\char`\"{}\+Mat.\+zeros\char`\"{}. Note that using this method you can initialize an array with an arbitrary value, using the following Matlab idiom\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A = Mat.\+ones(100, 100, C\+V\+\_\+8\+U)$\ast$3; // make 100x100 matrix filled with 3.}

{\ttfamily }

{\ttfamily }

{\ttfamily The above operation does not form a 100x100 matrix of 1\textquotesingle{}s and then multiply it by 3. Instead, it just remembers the scale factor (3 in this case) and use it when actually invoking the matrix initializer. }


\begin{DoxyParams}{Parameters}
{\em rows} & Number of rows. \\
\hline
{\em cols} & Number of columns. \\
\hline
{\em type} & Created matrix type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-ones}{\tt org.\+opencv.\+core.\+Mat.\+ones} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a2a4ac31b342315b5849762dba8a2d79d}\label{classorg_1_1opencv_1_1core_1_1_mat_a2a4ac31b342315b5849762dba8a2d79d}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!ones@{ones}}
\index{ones@{ones}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{ones()}{ones()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+ones (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{size,  }\item[{int}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns an array of all 1\textquotesingle{}s of the specified size and type.

The method returns a Matlab-\/style 1\textquotesingle{}s array initializer, similarly to\char`\"{}\+Mat.\+zeros\char`\"{}. Note that using this method you can initialize an array with an arbitrary value, using the following Matlab idiom\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A = Mat.\+ones(100, 100, C\+V\+\_\+8\+U)$\ast$3; // make 100x100 matrix filled with 3.}

{\ttfamily }

{\ttfamily }

{\ttfamily The above operation does not form a 100x100 matrix of 1\textquotesingle{}s and then multiply it by 3. Instead, it just remembers the scale factor (3 in this case) and use it when actually invoking the matrix initializer. }


\begin{DoxyParams}{Parameters}
{\em size} & Alternative to the matrix size specification {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}(cols, rows)}. \\
\hline
{\em type} & Created matrix type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-ones}{\tt org.\+opencv.\+core.\+Mat.\+ones} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a137ee1d0feab4d3db45755e2b6d46c91}\label{classorg_1_1opencv_1_1core_1_1_mat_a137ee1d0feab4d3db45755e2b6d46c91}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!push\+\_\+back@{push\+\_\+back}}
\index{push\+\_\+back@{push\+\_\+back}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{push\+\_\+back()}{push\_back()}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+push\+\_\+back (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{m }\end{DoxyParamCaption})}

Adds elements to the bottom of the matrix.

The methods add one or more elements to the bottom of the matrix. They emulate the corresponding method of the S\+TL vector class. When {\ttfamily elem} is {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}, its type and the number of columns must be the same as in the container matrix.


\begin{DoxyParams}{Parameters}
{\em m} & Added line(s).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-push-back}{\tt org.\+opencv.\+core.\+Mat.\+push\+\_\+back} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a033211373530fc2ac99d291e405fa6f6}\label{classorg_1_1opencv_1_1core_1_1_mat_a033211373530fc2ac99d291e405fa6f6}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!put@{put}}
\index{put@{put}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{put()}{put()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+put (\begin{DoxyParamCaption}\item[{int}]{row,  }\item[{int}]{col,  }\item[{double...}]{data }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a041ac4ce88732c782e2be29306105968}\label{classorg_1_1opencv_1_1core_1_1_mat_a041ac4ce88732c782e2be29306105968}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!put@{put}}
\index{put@{put}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{put()}{put()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+put (\begin{DoxyParamCaption}\item[{int}]{row,  }\item[{int}]{col,  }\item[{float \mbox{[}$\,$\mbox{]}}]{data }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a5401cd68e743255a389b32aa94db5d1c}\label{classorg_1_1opencv_1_1core_1_1_mat_a5401cd68e743255a389b32aa94db5d1c}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!put@{put}}
\index{put@{put}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{put()}{put()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+put (\begin{DoxyParamCaption}\item[{int}]{row,  }\item[{int}]{col,  }\item[{int \mbox{[}$\,$\mbox{]}}]{data }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a4d1c54091897d06ce22114cc74299796}\label{classorg_1_1opencv_1_1core_1_1_mat_a4d1c54091897d06ce22114cc74299796}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!put@{put}}
\index{put@{put}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{put()}{put()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+put (\begin{DoxyParamCaption}\item[{int}]{row,  }\item[{int}]{col,  }\item[{short \mbox{[}$\,$\mbox{]}}]{data }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a4d0c8b7bef73cdbe148d51a2a3ed5e05}\label{classorg_1_1opencv_1_1core_1_1_mat_a4d0c8b7bef73cdbe148d51a2a3ed5e05}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!put@{put}}
\index{put@{put}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{put()}{put()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+put (\begin{DoxyParamCaption}\item[{int}]{row,  }\item[{int}]{col,  }\item[{byte \mbox{[}$\,$\mbox{]}}]{data }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_afb0f872783792b1ba415c2dfcf088a14}\label{classorg_1_1opencv_1_1core_1_1_mat_afb0f872783792b1ba415c2dfcf088a14}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!release@{release}}
\index{release@{release}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{release()}{release()}}
{\footnotesize\ttfamily void org.\+opencv.\+core.\+Mat.\+release (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Decrements the reference counter and deallocates the matrix if needed.

The method decrements the reference counter associated with the matrix data. When the reference counter reaches 0, the matrix data is deallocated and the data and the reference counter pointers are set to N\+U\+LL\textquotesingle{}s. If the matrix header points to an external data set (see \char`\"{}\+Mat.\+Mat\char`\"{}), the reference counter is N\+U\+LL, and the method has no effect in this case.

This method can be called manually to force the matrix data deallocation. But since this method is automatically called in the destructor, or by any other method that changes the data pointer, it is usually not needed. The reference counter decrement and check for 0 is an atomic operation on the platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in different threads.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-release}{\tt org.\+opencv.\+core.\+Mat.\+release} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ac272e7518dba0da8e7480df63163040b}\label{classorg_1_1opencv_1_1core_1_1_mat_ac272e7518dba0da8e7480df63163040b}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!reshape@{reshape}}
\index{reshape@{reshape}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{reshape()}{reshape()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+reshape (\begin{DoxyParamCaption}\item[{int}]{cn,  }\item[{int}]{rows }\end{DoxyParamCaption})}

Changes the shape and/or the number of channels of a 2D matrix without copying the data.

The method makes a new matrix header for {\ttfamily $\ast$this} elements. The new matrix may have a different size and/or different number of channels. Any combination is possible if\+:


\begin{DoxyItemize}
\item No extra elements are included into the new matrix and no elements are excluded. Consequently, the product {\ttfamily rows$\ast$cols$\ast$channels()} must stay the same after the transformation. 
\item No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of rows, or the operation changes the indices of elements row in some other way, the matrix must be continuous. See \char`\"{}\+Mat.\+is\+Continuous\char`\"{}. 
\end{DoxyItemize}

For example, if there is a set of 3D points stored as an S\+TL vector, and you want to represent the points as a {\ttfamily 3xN} matrix, do the following\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily std.\+vector$<$\+Point3f$>$ vec;...}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} point\+Mat = Mat(vec). // convert vector to \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}, O(1) operation}

{\ttfamily }

{\ttfamily }

{\ttfamily reshape(1). // make Nx3 1-\/channel matrix out of Nx1 3-\/channel.}

{\ttfamily }

{\ttfamily }

{\ttfamily // Also, an O(1) operation}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a8df776cc748a0006e8837fcb7a1772f0}{t()}}; // finally, transpose the Nx3 matrix.}

{\ttfamily }

{\ttfamily }

{\ttfamily // This involves copying all the elements}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em cn} & New number of channels. If the parameter is 0, the number of channels remains the same. \\
\hline
{\em rows} & New number of rows. If the parameter is 0, the number of rows remains the same.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-reshape}{\tt org.\+opencv.\+core.\+Mat.\+reshape} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a544b911ef4cf5e755658a1f8dd5f0b7d}\label{classorg_1_1opencv_1_1core_1_1_mat_a544b911ef4cf5e755658a1f8dd5f0b7d}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!reshape@{reshape}}
\index{reshape@{reshape}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{reshape()}{reshape()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+reshape (\begin{DoxyParamCaption}\item[{int}]{cn }\end{DoxyParamCaption})}

Changes the shape and/or the number of channels of a 2D matrix without copying the data.

The method makes a new matrix header for {\ttfamily $\ast$this} elements. The new matrix may have a different size and/or different number of channels. Any combination is possible if\+:


\begin{DoxyItemize}
\item No extra elements are included into the new matrix and no elements are excluded. Consequently, the product {\ttfamily rows$\ast$cols$\ast$channels()} must stay the same after the transformation. 
\item No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of rows, or the operation changes the indices of elements row in some other way, the matrix must be continuous. See \char`\"{}\+Mat.\+is\+Continuous\char`\"{}. 
\end{DoxyItemize}

For example, if there is a set of 3D points stored as an S\+TL vector, and you want to represent the points as a {\ttfamily 3xN} matrix, do the following\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily std.\+vector$<$\+Point3f$>$ vec;...}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} point\+Mat = Mat(vec). // convert vector to \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}, O(1) operation}

{\ttfamily }

{\ttfamily }

{\ttfamily reshape(1). // make Nx3 1-\/channel matrix out of Nx1 3-\/channel.}

{\ttfamily }

{\ttfamily }

{\ttfamily // Also, an O(1) operation}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a8df776cc748a0006e8837fcb7a1772f0}{t()}}; // finally, transpose the Nx3 matrix.}

{\ttfamily }

{\ttfamily }

{\ttfamily // This involves copying all the elements}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em cn} & New number of channels. If the parameter is 0, the number of channels remains the same.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-reshape}{\tt org.\+opencv.\+core.\+Mat.\+reshape} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}\label{classorg_1_1opencv_1_1core_1_1_mat_a39db00627baab6486e3065920941b9ec}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!row@{row}}
\index{row@{row}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{row()}{row()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+row (\begin{DoxyParamCaption}\item[{int}]{y }\end{DoxyParamCaption})}

Creates a matrix header for the specified matrix row.

The method makes a new header for the specified matrix row and returns it. This is an O(1) operation, regardless of the matrix size. The underlying data of the new matrix is shared with the original matrix. Here is the example of one of the classical basic matrix processing operations, {\ttfamily axpy}, used by LU and many other algorithms\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily inline void matrix\+\_\+axpy(\+Mat\& A, int i, int j, double alpha)}

{\ttfamily }

{\ttfamily }

{\ttfamily A.\+row(i) += A.\+row(j)$\ast$alpha;}

{\ttfamily }

{\ttfamily }

{\ttfamily Note\+: }

In the current implementation, the following code does not work as expected\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A;...}

{\ttfamily }

{\ttfamily }

{\ttfamily A.\+row(i) = A.\+row(j); // will not work}

{\ttfamily }

{\ttfamily }

{\ttfamily This happens because {\ttfamily A.\+row(i)} forms a temporary header that is further assigned to another header. Remember that each of these operations is O(1), that is, no data is copied. Thus, the above assignment is not true if you may have expected the j-\/th row to be copied to the i-\/th row. To achieve that, you should either turn this simple assignment into an expression or use the \char`\"{}\+Mat.\+copy\+To\char`\"{} method\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A;...}

{\ttfamily }

{\ttfamily }

{\ttfamily // works, but looks a bit obscure.}

{\ttfamily }

{\ttfamily }

{\ttfamily A.\+row(i) = A.\+row(j) + 0;}

{\ttfamily }

{\ttfamily }

{\ttfamily // this is a bit longer, but the recommended method.}

{\ttfamily }

{\ttfamily }

{\ttfamily A.\+row(j).copy\+To(A.\+row(i));}

{\ttfamily }

{\ttfamily 
\begin{DoxyParams}{Parameters}
{\em y} & A 0-\/based row index.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-row}{\tt org.\+opencv.\+core.\+Mat.\+row} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a182dbb37bbaa19e65cfcb99cf4d03fbe}\label{classorg_1_1opencv_1_1core_1_1_mat_a182dbb37bbaa19e65cfcb99cf4d03fbe}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!row\+Range@{row\+Range}}
\index{row\+Range@{row\+Range}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{row\+Range()}{rowRange()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+row\+Range (\begin{DoxyParamCaption}\item[{int}]{startrow,  }\item[{int}]{endrow }\end{DoxyParamCaption})}

Creates a matrix header for the specified row span.

The method makes a new header for the specified row span of the matrix. Similarly to \char`\"{}\+Mat.\+row\char`\"{} and \char`\"{}\+Mat.\+col\char`\"{}, this is an O(1) operation.


\begin{DoxyParams}{Parameters}
{\em startrow} & An inclusive 0-\/based start index of the row span. \\
\hline
{\em endrow} & An exclusive 0-\/based ending index of the row span.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-rowrange}{\tt org.\+opencv.\+core.\+Mat.\+row\+Range} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a05a7c23da0150252d907e58489808b51}\label{classorg_1_1opencv_1_1core_1_1_mat_a05a7c23da0150252d907e58489808b51}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!row\+Range@{row\+Range}}
\index{row\+Range@{row\+Range}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{row\+Range()}{rowRange()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+row\+Range (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}}}]{r }\end{DoxyParamCaption})}

Creates a matrix header for the specified row span.

The method makes a new header for the specified row span of the matrix. Similarly to \char`\"{}\+Mat.\+row\char`\"{} and \char`\"{}\+Mat.\+col\char`\"{}, this is an O(1) operation.


\begin{DoxyParams}{Parameters}
{\em r} & \char`\"{}\+Range\char`\"{} structure containing both the start and the end indices.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-rowrange}{\tt org.\+opencv.\+core.\+Mat.\+row\+Range} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a1e925483fbe84a9dab2499cf91c17c84}\label{classorg_1_1opencv_1_1core_1_1_mat_a1e925483fbe84a9dab2499cf91c17c84}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!rows@{rows}}
\index{rows@{rows}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{rows()}{rows()}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+rows (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a9316a305061d8ef51b7e7355d5e7440d}\label{classorg_1_1opencv_1_1core_1_1_mat_a9316a305061d8ef51b7e7355d5e7440d}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!set\+To@{set\+To}}
\index{set\+To@{set\+To}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{set\+To()}{setTo()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+set\+To (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{s }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a56d903b85bbe289ee484e1b22efa2a91}\label{classorg_1_1opencv_1_1core_1_1_mat_a56d903b85bbe289ee484e1b22efa2a91}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!set\+To@{set\+To}}
\index{set\+To@{set\+To}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{set\+To()}{setTo()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+set\+To (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_scalar}{Scalar}}}]{value,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})}

Sets all or some of the array elements to the specified value.


\begin{DoxyParams}{Parameters}
{\em value} & Assigned scalar converted to the actual array type. \\
\hline
{\em mask} & Operation mask of the same size as {\ttfamily $\ast$this}. This is an advanced variant of the {\ttfamily Mat.\+operator=(const Scalar\& s)} operator.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-setto}{\tt org.\+opencv.\+core.\+Mat.\+set\+To} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a793ccddcd93d47402e9b243ef75814b1}\label{classorg_1_1opencv_1_1core_1_1_mat_a793ccddcd93d47402e9b243ef75814b1}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!set\+To@{set\+To}}
\index{set\+To@{set\+To}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{set\+To()}{setTo()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+set\+To (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{value,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{mask }\end{DoxyParamCaption})}

Sets all or some of the array elements to the specified value.


\begin{DoxyParams}{Parameters}
{\em value} & Assigned scalar converted to the actual array type. \\
\hline
{\em mask} & Operation mask of the same size as {\ttfamily $\ast$this}. This is an advanced variant of the {\ttfamily Mat.\+operator=(const Scalar\& s)} operator.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-setto}{\tt org.\+opencv.\+core.\+Mat.\+set\+To} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a3c0458f17815dd73f81e4a8dfebacb3b}\label{classorg_1_1opencv_1_1core_1_1_mat_a3c0458f17815dd73f81e4a8dfebacb3b}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!set\+To@{set\+To}}
\index{set\+To@{set\+To}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{set\+To()}{setTo()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+set\+To (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}}}]{value }\end{DoxyParamCaption})}

Sets all or some of the array elements to the specified value.


\begin{DoxyParams}{Parameters}
{\em value} & Assigned scalar converted to the actual array type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-setto}{\tt org.\+opencv.\+core.\+Mat.\+set\+To} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a543d6f8a103a5f3d899030d76286f0cf}\label{classorg_1_1opencv_1_1core_1_1_mat_a543d6f8a103a5f3d899030d76286f0cf}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!size@{size}}
\index{size@{size}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}} org.\+opencv.\+core.\+Mat.\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns a matrix size.

The method returns a matrix size\+: {\ttfamily Size(cols, rows)}. When the matrix is more than 2-\/dimensional, the returned size is (-\/1, -\/1).

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-size}{\tt org.\+opencv.\+core.\+Mat.\+size} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a758053ee22fe72074db5934097477cfe}\label{classorg_1_1opencv_1_1core_1_1_mat_a758053ee22fe72074db5934097477cfe}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!step1@{step1}}
\index{step1@{step1}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{step1()}{step1()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily long org.\+opencv.\+core.\+Mat.\+step1 (\begin{DoxyParamCaption}\item[{int}]{i }\end{DoxyParamCaption})}

Returns a normalized step.

The method returns a matrix step divided by \char`\"{}\+Mat.\+elem\+Size1()\char`\"{}. It can be useful to quickly access an arbitrary matrix element.


\begin{DoxyParams}{Parameters}
{\em i} & a i\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-step1}{\tt org.\+opencv.\+core.\+Mat.\+step1} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a657e61de4cb505cb637e8e88b12ac479}\label{classorg_1_1opencv_1_1core_1_1_mat_a657e61de4cb505cb637e8e88b12ac479}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!step1@{step1}}
\index{step1@{step1}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{step1()}{step1()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily long org.\+opencv.\+core.\+Mat.\+step1 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns a normalized step.

The method returns a matrix step divided by \char`\"{}\+Mat.\+elem\+Size1()\char`\"{}. It can be useful to quickly access an arbitrary matrix element.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-step1}{\tt org.\+opencv.\+core.\+Mat.\+step1} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a3d3b68f34a2c1c3aaa56b1c75f09ae60}\label{classorg_1_1opencv_1_1core_1_1_mat_a3d3b68f34a2c1c3aaa56b1c75f09ae60}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!submat@{submat}}
\index{submat@{submat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{submat()}{submat()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+submat (\begin{DoxyParamCaption}\item[{int}]{row\+Start,  }\item[{int}]{row\+End,  }\item[{int}]{col\+Start,  }\item[{int}]{col\+End }\end{DoxyParamCaption})}

Extracts a rectangular submatrix.

The operators make a new header for the specified sub-\/array of {\ttfamily $\ast$this}. They are the most generalized forms of \char`\"{}\+Mat.\+row\char`\"{}, \char`\"{}\+Mat.\+col\char`\"{}, \char`\"{}\+Mat.\+row\+Range\char`\"{}, and \char`\"{}\+Mat.\+col\+Range\char`\"{}. For example, {\ttfamily A(Range(0, 10), \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range_a2dd4a07a9715665aacee5c7cdf79a175}{Range.\+all()}})} is equivalent to {\ttfamily A.\+row\+Range(0, 10)}. Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied.


\begin{DoxyParams}{Parameters}
{\em row\+Start} & a row\+Start \\
\hline
{\em row\+End} & a row\+End \\
\hline
{\em col\+Start} & a col\+Start \\
\hline
{\em col\+End} & a col\+End\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-operator}{\tt org.\+opencv.\+core.\+Mat.\+operator()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a4a17b77ce9a3b6b497912153906c2d37}\label{classorg_1_1opencv_1_1core_1_1_mat_a4a17b77ce9a3b6b497912153906c2d37}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!submat@{submat}}
\index{submat@{submat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{submat()}{submat()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+submat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}}}]{row\+Range,  }\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range}{Range}}}]{col\+Range }\end{DoxyParamCaption})}

Extracts a rectangular submatrix.

The operators make a new header for the specified sub-\/array of {\ttfamily $\ast$this}. They are the most generalized forms of \char`\"{}\+Mat.\+row\char`\"{}, \char`\"{}\+Mat.\+col\char`\"{}, \char`\"{}\+Mat.\+row\+Range\char`\"{}, and \char`\"{}\+Mat.\+col\+Range\char`\"{}. For example, {\ttfamily A(Range(0, 10), \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range_a2dd4a07a9715665aacee5c7cdf79a175}{Range.\+all()}})} is equivalent to {\ttfamily A.\+row\+Range(0, 10)}. Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied.


\begin{DoxyParams}{Parameters}
{\em row\+Range} & Start and end row of the extracted submatrix. The upper boundary is not included. To select all the rows, use {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range_a2dd4a07a9715665aacee5c7cdf79a175}{Range.\+all()}}}. \\
\hline
{\em col\+Range} & Start and end column of the extracted submatrix. The upper boundary is not included. To select all the columns, use {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range_a2dd4a07a9715665aacee5c7cdf79a175}{Range.\+all()}}}.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-operator}{\tt org.\+opencv.\+core.\+Mat.\+operator()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a37b5962d59cd8a91a081e232e07979f9}\label{classorg_1_1opencv_1_1core_1_1_mat_a37b5962d59cd8a91a081e232e07979f9}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!submat@{submat}}
\index{submat@{submat}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{submat()}{submat()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+submat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_rect}{Rect}}}]{roi }\end{DoxyParamCaption})}

Extracts a rectangular submatrix.

The operators make a new header for the specified sub-\/array of {\ttfamily $\ast$this}. They are the most generalized forms of \char`\"{}\+Mat.\+row\char`\"{}, \char`\"{}\+Mat.\+col\char`\"{}, \char`\"{}\+Mat.\+row\+Range\char`\"{}, and \char`\"{}\+Mat.\+col\+Range\char`\"{}. For example, {\ttfamily A(Range(0, 10), \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_range_a2dd4a07a9715665aacee5c7cdf79a175}{Range.\+all()}})} is equivalent to {\ttfamily A.\+row\+Range(0, 10)}. Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied.


\begin{DoxyParams}{Parameters}
{\em roi} & Extracted submatrix specified as a rectangle.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-operator}{\tt org.\+opencv.\+core.\+Mat.\+operator()} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a8df776cc748a0006e8837fcb7a1772f0}\label{classorg_1_1opencv_1_1core_1_1_mat_a8df776cc748a0006e8837fcb7a1772f0}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!t@{t}}
\index{t@{t}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{t()}{t()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+t (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Transposes a matrix.

The method performs matrix transposition by means of matrix expressions. It does not perform the actual transposition but returns a temporary matrix transposition object that can be further used as a part of more complex matrix expressions or can be assigned to a matrix\+: {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A1 = A + \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat_a4de6ffd10feb724153f1ec1231533aa9}{Mat.\+eye}}(A.\+size(), A.\+type())$\ast$lambda;}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} C = A1.\+t()$\ast$\+A1; // compute (A + lambda$\ast$I)$^\wedge$t $\ast$ (A + lamda$\ast$I)}

{\ttfamily }

{\ttfamily \begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-t}{\tt org.\+opencv.\+core.\+Mat.\+t} 
\end{DoxySeeAlso}
}\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a2652b30a9904641accc3bef6f071db2c}\label{classorg_1_1opencv_1_1core_1_1_mat_a2652b30a9904641accc3bef6f071db2c}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!to\+String@{to\+String}}
\index{to\+String@{to\+String}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{to\+String()}{toString()}}
{\footnotesize\ttfamily String org.\+opencv.\+core.\+Mat.\+to\+String (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a0aa57e546fe72e994dafe806f47f0081}\label{classorg_1_1opencv_1_1core_1_1_mat_a0aa57e546fe72e994dafe806f47f0081}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!total@{total}}
\index{total@{total}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{total()}{total()}}
{\footnotesize\ttfamily long org.\+opencv.\+core.\+Mat.\+total (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns the total number of array elements.

The method returns the number of array elements (a number of pixels if the array represents an image).

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-total}{\tt org.\+opencv.\+core.\+Mat.\+total} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}\label{classorg_1_1opencv_1_1core_1_1_mat_a555bc7243135e2883afe54e7e5e92c79}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!type@{type}}
\index{type@{type}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{type()}{type()}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns the type of a matrix element.

The method returns a matrix element type. This is an identifier compatible with the {\ttfamily Cv\+Mat} type system, like {\ttfamily C\+V\+\_\+16\+S\+C3} or 16-\/bit signed 3-\/channel array, and so on.

\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-type}{\tt org.\+opencv.\+core.\+Mat.\+type} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a865879f055007ff347401280a4fd9b73}\label{classorg_1_1opencv_1_1core_1_1_mat_a865879f055007ff347401280a4fd9b73}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!width@{width}}
\index{width@{width}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{width()}{width()}}
{\footnotesize\ttfamily int org.\+opencv.\+core.\+Mat.\+width (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_aff41070138369b96f792b19f01ab00d9}\label{classorg_1_1opencv_1_1core_1_1_mat_aff41070138369b96f792b19f01ab00d9}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!zeros@{zeros}}
\index{zeros@{zeros}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{zeros()}{zeros()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+zeros (\begin{DoxyParamCaption}\item[{int}]{rows,  }\item[{int}]{cols,  }\item[{int}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a zero array of the specified size and type.

The method returns a Matlab-\/style zero array initializer. It can be used to quickly form a constant array as a function parameter, part of a matrix expression, or as a matrix initializer. {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A;}

{\ttfamily }

{\ttfamily }

{\ttfamily A = Mat.\+zeros(3, 3, C\+V\+\_\+32\+F);}

{\ttfamily }

{\ttfamily }

{\ttfamily In the example above, a new matrix is allocated only if {\ttfamily A} is not a 3x3 floating-\/point matrix. Otherwise, the existing matrix {\ttfamily A} is filled with zeros. }


\begin{DoxyParams}{Parameters}
{\em rows} & Number of rows. \\
\hline
{\em cols} & Number of columns. \\
\hline
{\em type} & Created matrix type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-zeros}{\tt org.\+opencv.\+core.\+Mat.\+zeros} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_ae346269a0f9ee375ffe987e8d8031014}\label{classorg_1_1opencv_1_1core_1_1_mat_ae346269a0f9ee375ffe987e8d8031014}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!zeros@{zeros}}
\index{zeros@{zeros}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{zeros()}{zeros()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} org.\+opencv.\+core.\+Mat.\+zeros (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}}]{size,  }\item[{int}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a zero array of the specified size and type.

The method returns a Matlab-\/style zero array initializer. It can be used to quickly form a constant array as a function parameter, part of a matrix expression, or as a matrix initializer. {\ttfamily }

{\ttfamily }

{\ttfamily }

{\ttfamily // C++ code\+:}

{\ttfamily }

{\ttfamily }

{\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_mat}{Mat}} A;}

{\ttfamily }

{\ttfamily }

{\ttfamily A = Mat.\+zeros(3, 3, C\+V\+\_\+32\+F);}

{\ttfamily }

{\ttfamily }

{\ttfamily In the example above, a new matrix is allocated only if {\ttfamily A} is not a 3x3 floating-\/point matrix. Otherwise, the existing matrix {\ttfamily A} is filled with zeros. }


\begin{DoxyParams}{Parameters}
{\em size} & Alternative to the matrix size specification {\ttfamily \mbox{\hyperlink{classorg_1_1opencv_1_1core_1_1_size}{Size}}(cols, rows)}. \\
\hline
{\em type} & Created matrix type.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\href{http://docs.opencv.org/modules/core/doc/basic_structures.html#mat-zeros}{\tt org.\+opencv.\+core.\+Mat.\+zeros} 
\end{DoxySeeAlso}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classorg_1_1opencv_1_1core_1_1_mat_a497713e25ec636f1185e08d7692d065b}\label{classorg_1_1opencv_1_1core_1_1_mat_a497713e25ec636f1185e08d7692d065b}} 
\index{org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}!native\+Obj@{native\+Obj}}
\index{native\+Obj@{native\+Obj}!org\+::opencv\+::core\+::\+Mat@{org\+::opencv\+::core\+::\+Mat}}
\subsubsection{\texorpdfstring{native\+Obj}{nativeObj}}
{\footnotesize\ttfamily final long org.\+opencv.\+core.\+Mat.\+native\+Obj}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/\+Marcius/\+Documents/\+Git\+Hub/\+Skaitliuko-\/\+Skeneris/open\+C\+V\+Library249/src/main/java/org/opencv/core/\mbox{\hyperlink{_mat_8java}{Mat.\+java}}\end{DoxyCompactItemize}
